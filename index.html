<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Martin Odersky">
  <meta name="author" content="Philippe Altherr">
  <meta name="author" content="Vincent Cremet">
  <meta name="author" content="Gilles Dubochet">
  <meta name="author" content="Burak Emir">
  <meta name="author" content="Philipp Haller">
  <meta name="author" content="StÃ©phane Micheloud">
  <meta name="author" content="Nikolay Mihaylov">
  <meta name="author" content="Michel Schinz">
  <meta name="author" content="Erik Stenman">
  <meta name="author" content="Matthias Zenger">
  <title>The Scala Language Specification, Version 2.9</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
  <script type="text/javascript" src="resources/ScalaReference.js"></script>
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
            skipTags: ["script", "noscript", "style", "textarea"],
            inlineMath: [ ["$", "$"], ["\\(", "\\)"] ],
            processEscapes: true
        }
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <link rel="stylesheet" href="resources/blueprint-screen.css" type="text/css" media="screen, projection">
  <link rel="stylesheet" href="resources/blueprint-print.css" type="text/css" media="print">
  <!--[if lt IE 8]>
    <link rel="stylesheet" href="resources/blueprint-ie.css" type="text/css" media="screen, projection">
  <![endif]-->
  <link rel="stylesheet" href="resources/style.css" type="text/css" media="screen, projection"/>

</head>
<body>
<div class="container">
<header>
<h1 class="title">The Scala Language Specification, Version 2.9</h1>
<h3 class="date">24th May 2011</h3>
</header>
<hr>
<nav id="TOC">
<ul>
<li><a href="#preface"><span class="toc-section-number">0.1</span> Preface</a></li>
<li><a href="#lexical-syntax"><span class="toc-section-number">1</span> Lexical Syntax</a><ul>
<li><a href="#identifiers"><span class="toc-section-number">1.1</span> Identifiers</a></li>
<li><a href="#newline-characters"><span class="toc-section-number">1.2</span> Newline Characters</a></li>
<li><a href="#literals"><span class="toc-section-number">1.3</span> Literals</a><ul>
<li><a href="#integer-literals"><span class="toc-section-number">1.3.1</span> Integer Literals</a></li>
<li><a href="#floating-point-literals"><span class="toc-section-number">1.3.2</span> Floating Point Literals</a></li>
<li><a href="#boolean-literals"><span class="toc-section-number">1.3.3</span> Boolean Literals</a></li>
<li><a href="#character-literals"><span class="toc-section-number">1.3.4</span> Character Literals</a></li>
<li><a href="#string-literals"><span class="toc-section-number">1.3.5</span> String Literals</a><ul>
<li><a href="#multi-line-string-literals"><span class="toc-section-number">1.3.5.1</span> Multi-Line String Literals</a></li>
</ul></li>
<li><a href="#escape-sequences"><span class="toc-section-number">1.3.6</span> Escape Sequences</a></li>
<li><a href="#symbol-literals"><span class="toc-section-number">1.3.7</span> Symbol literals</a></li>
</ul></li>
<li><a href="#whitespace-and-comments"><span class="toc-section-number">1.4</span> Whitespace and Comments</a></li>
<li><a href="#xml-mode"><span class="toc-section-number">1.5</span> XML mode</a></li>
</ul></li>
<li><a href="#identifiers-names-and-scopes"><span class="toc-section-number">2</span> Identifiers, Names and Scopes</a></li>
<li><a href="#types"><span class="toc-section-number">3</span> Types</a><ul>
<li><a href="#paths"><span class="toc-section-number">3.1</span> Paths</a></li>
<li><a href="#value-types"><span class="toc-section-number">3.2</span> Value Types</a><ul>
<li><a href="#singleton-types"><span class="toc-section-number">3.2.1</span> Singleton Types</a></li>
<li><a href="#type-projection"><span class="toc-section-number">3.2.2</span> Type Projection</a></li>
<li><a href="#type-designators"><span class="toc-section-number">3.2.3</span> Type Designators</a></li>
<li><a href="#parameterized-types"><span class="toc-section-number">3.2.4</span> Parameterized Types</a></li>
<li><a href="#tuple-types"><span class="toc-section-number">3.2.5</span> Tuple Types</a></li>
<li><a href="#annotated-types"><span class="toc-section-number">3.2.6</span> Annotated Types</a></li>
<li><a href="#compound-types"><span class="toc-section-number">3.2.7</span> Compound Types</a></li>
<li><a href="#infix-types"><span class="toc-section-number">3.2.8</span> Infix Types</a></li>
<li><a href="#function-types"><span class="toc-section-number">3.2.9</span> Function Types</a></li>
<li><a href="#existential-types"><span class="toc-section-number">3.2.10</span> Existential Types</a><ul>
<li><a href="#simplification-rules"><span class="toc-section-number">3.2.10.1</span> Simplification Rules</a></li>
<li><a href="#existential-quantification-over-values"><span class="toc-section-number">3.2.10.2</span> Existential Quantification over Values</a></li>
<li><a href="#placeholder-syntax-for-existential-types"><span class="toc-section-number">3.2.10.3</span> Placeholder Syntax for Existential Types</a></li>
</ul></li>
</ul></li>
<li><a href="#non-value-types"><span class="toc-section-number">3.3</span> Non-Value Types</a><ul>
<li><a href="#method-types"><span class="toc-section-number">3.3.1</span> Method Types</a></li>
<li><a href="#polymorphic-method-types"><span class="toc-section-number">3.3.2</span> Polymorphic Method Types</a></li>
<li><a href="#type-constructors"><span class="toc-section-number">3.3.3</span> Type Constructors</a></li>
</ul></li>
<li><a href="#base-types-and-member-definitions"><span class="toc-section-number">3.4</span> Base Types and Member Definitions</a></li>
<li><a href="#relations-between-types"><span class="toc-section-number">3.5</span> Relations between types</a><ul>
<li><a href="#type-equivalence"><span class="toc-section-number">3.5.1</span> Type Equivalence</a></li>
<li><a href="#conformance"><span class="toc-section-number">3.5.2</span> Conformance</a></li>
<li><a href="#weak-conformance"><span class="toc-section-number">3.5.3</span> Weak Conformance</a></li>
</ul></li>
<li><a href="#volatile-types"><span class="toc-section-number">3.6</span> Volatile Types</a></li>
<li><a href="#type-erasure"><span class="toc-section-number">3.7</span> Type Erasure</a></li>
</ul></li>
<li><a href="#basic-declarations-and-definitions"><span class="toc-section-number">4</span> Basic Declarations and Definitions</a><ul>
<li><a href="#value-declarations-and-definitions"><span class="toc-section-number">4.1</span> Value Declarations and Definitions</a></li>
<li><a href="#variable-declarations-and-definitions"><span class="toc-section-number">4.2</span> Variable Declarations and Definitions</a></li>
<li><a href="#type-declarations-and-type-aliases"><span class="toc-section-number">4.3</span> Type Declarations and Type Aliases</a></li>
<li><a href="#type-parameters"><span class="toc-section-number">4.4</span> Type Parameters</a></li>
<li><a href="#variance-annotations"><span class="toc-section-number">4.5</span> Variance Annotations</a></li>
<li><a href="#function-declarations-and-definitions"><span class="toc-section-number">4.6</span> Function Declarations and Definitions</a><ul>
<li><a href="#by-name-parameters"><span class="toc-section-number">4.6.1</span> By-Name Parameters</a></li>
<li><a href="#repeated-parameters"><span class="toc-section-number">4.6.2</span> Repeated Parameters</a></li>
<li><a href="#procedures"><span class="toc-section-number">4.6.3</span> Procedures</a></li>
<li><a href="#method-return-type-inference"><span class="toc-section-number">4.6.4</span> Method Return Type Inference</a></li>
</ul></li>
<li><a href="#import-clauses"><span class="toc-section-number">4.7</span> Import Clauses</a></li>
</ul></li>
<li><a href="#classes-and-objects"><span class="toc-section-number">5</span> Classes and Objects</a><ul>
<li><a href="#templates"><span class="toc-section-number">5.1</span> Templates</a><ul>
<li><a href="#constructor-invocations"><span class="toc-section-number">5.1.1</span> Constructor Invocations</a></li>
<li><a href="#class-linearization"><span class="toc-section-number">5.1.2</span> Class Linearization</a></li>
<li><a href="#class-members"><span class="toc-section-number">5.1.3</span> Class Members</a></li>
<li><a href="#overriding"><span class="toc-section-number">5.1.4</span> Overriding</a></li>
<li><a href="#inheritance-closure"><span class="toc-section-number">5.1.5</span> Inheritance Closure</a></li>
<li><a href="#early-definitions"><span class="toc-section-number">5.1.6</span> Early Definitions</a></li>
</ul></li>
<li><a href="#modifiers"><span class="toc-section-number">5.2</span> Modifiers</a></li>
<li><a href="#class-definitions"><span class="toc-section-number">5.3</span> Class Definitions</a><ul>
<li><a href="#constructor-definitions"><span class="toc-section-number">5.3.1</span> Constructor Definitions</a></li>
</ul></li>
<li><a href="#case-classes"><span class="toc-section-number">5.4</span> Case Classes</a><ul>
<li><a href="#traits"><span class="toc-section-number">5.4.1</span> Traits</a></li>
</ul></li>
<li><a href="#object-definitions"><span class="toc-section-number">5.5</span> Object Definitions</a></li>
</ul></li>
<li><a href="#expressions"><span class="toc-section-number">6</span> Expressions</a><ul>
<li><a href="#expression-typing"><span class="toc-section-number">6.1</span> Expression Typing</a></li>
<li><a href="#literals-1"><span class="toc-section-number">6.2</span> Literals</a></li>
<li><a href="#the-null-value"><span class="toc-section-number">6.3</span> The <em>Null</em> Value</a></li>
<li><a href="#designators"><span class="toc-section-number">6.4</span> Designators</a></li>
<li><a href="#this-and-super"><span class="toc-section-number">6.5</span> This and Super</a></li>
<li><a href="#function-applications"><span class="toc-section-number">6.6</span> Function Applications</a><ul>
<li><a href="#named-and-default-arguments"><span class="toc-section-number">6.6.1</span> Named and Default Arguments</a></li>
</ul></li>
<li><a href="#method-values"><span class="toc-section-number">6.7</span> Method Values</a></li>
<li><a href="#type-applications"><span class="toc-section-number">6.8</span> Type Applications</a></li>
<li><a href="#tuples"><span class="toc-section-number">6.9</span> Tuples</a></li>
<li><a href="#instance-creation-expressions"><span class="toc-section-number">6.10</span> Instance Creation Expressions</a></li>
<li><a href="#blocks"><span class="toc-section-number">6.11</span> Blocks</a></li>
<li><a href="#prefix-infix-and-postfix-operations"><span class="toc-section-number">6.12</span> Prefix, Infix, and Postfix Operations</a><ul>
<li><a href="#prefix-operations"><span class="toc-section-number">6.12.1</span> Prefix Operations</a></li>
<li><a href="#postfix-operations"><span class="toc-section-number">6.12.2</span> Postfix Operations</a></li>
<li><a href="#infix-operations"><span class="toc-section-number">6.12.3</span> Infix Operations</a></li>
<li><a href="#assignment-operators"><span class="toc-section-number">6.12.4</span> Assignment Operators</a></li>
</ul></li>
<li><a href="#typed-expressions"><span class="toc-section-number">6.13</span> Typed Expressions</a></li>
<li><a href="#annotated-expressions"><span class="toc-section-number">6.14</span> Annotated Expressions</a></li>
<li><a href="#assignments"><span class="toc-section-number">6.15</span> Assignments</a></li>
<li><a href="#conditional-expressions"><span class="toc-section-number">6.16</span> Conditional Expressions</a></li>
<li><a href="#while-loop-expressions"><span class="toc-section-number">6.17</span> While Loop Expressions</a></li>
<li><a href="#do-loop-expressions"><span class="toc-section-number">6.18</span> Do Loop Expressions</a></li>
<li><a href="#for-comprehensions-and-for-loops"><span class="toc-section-number">6.19</span> For Comprehensions and For Loops</a></li>
<li><a href="#return-expressions"><span class="toc-section-number">6.20</span> Return Expressions</a></li>
<li><a href="#throw-expressions"><span class="toc-section-number">6.21</span> Throw Expressions</a></li>
<li><a href="#try-expressions"><span class="toc-section-number">6.22</span> Try Expressions</a></li>
<li><a href="#anonymous-functions"><span class="toc-section-number">6.23</span> Anonymous Functions</a><ul>
<li><a href="#placeholder-syntax-for-anonymous-functions"><span class="toc-section-number">6.23.1</span> Placeholder Syntax for Anonymous Functions</a></li>
</ul></li>
<li><a href="#constant-expressions"><span class="toc-section-number">6.24</span> Constant Expressions</a></li>
<li><a href="#statements"><span class="toc-section-number">6.25</span> Statements</a></li>
<li><a href="#implicit-conversions"><span class="toc-section-number">6.26</span> Implicit Conversions</a><ul>
<li><a href="#value-conversions"><span class="toc-section-number">6.26.1</span> Value Conversions</a></li>
<li><a href="#method-conversions"><span class="toc-section-number">6.26.2</span> Method Conversions</a></li>
<li><a href="#overloading-resolution"><span class="toc-section-number">6.26.3</span> Overloading Resolution</a></li>
<li><a href="#local-type-inference"><span class="toc-section-number">6.26.4</span> Local Type Inference</a></li>
<li><a href="#eta-expansion"><span class="toc-section-number">6.26.5</span> Eta Expansion</a></li>
<li><a href="#dynamic-member-selection"><span class="toc-section-number">6.26.6</span> Dynamic Member Selection</a></li>
</ul></li>
</ul></li>
<li><a href="#implicit-parameters-and-views"><span class="toc-section-number">7</span> Implicit Parameters and Views</a><ul>
<li><a href="#the-implicit-modifier"><span class="toc-section-number">7.1</span> The Implicit Modifier</a></li>
<li><a href="#implicit-parameters"><span class="toc-section-number">7.2</span> Implicit Parameters</a></li>
<li><a href="#views"><span class="toc-section-number">7.3</span> Views</a></li>
<li><a href="#context-bounds-and-view-bounds"><span class="toc-section-number">7.4</span> Context Bounds and View Bounds</a></li>
<li><a href="#manifests"><span class="toc-section-number">7.5</span> Manifests</a></li>
</ul></li>
<li><a href="#pattern-matching"><span class="toc-section-number">8</span> Pattern Matching</a><ul>
<li><a href="#patterns"><span class="toc-section-number">8.1</span> Patterns</a><ul>
<li><a href="#variable-patterns"><span class="toc-section-number">8.1.1</span> Variable Patterns</a></li>
<li><a href="#typed-patterns"><span class="toc-section-number">8.1.2</span> Typed Patterns</a></li>
<li><a href="#pattern-binders"><span class="toc-section-number">8.1.3</span> Pattern Binders</a></li>
<li><a href="#literal-patterns"><span class="toc-section-number">8.1.4</span> Literal Patterns</a></li>
<li><a href="#stable-identifier-patterns"><span class="toc-section-number">8.1.5</span> Stable Identifier Patterns</a></li>
<li><a href="#constructor-patterns"><span class="toc-section-number">8.1.6</span> Constructor Patterns</a></li>
<li><a href="#tuple-patterns"><span class="toc-section-number">8.1.7</span> Tuple Patterns</a></li>
<li><a href="#extractor-patterns"><span class="toc-section-number">8.1.8</span> Extractor Patterns</a></li>
<li><a href="#pattern-sequences"><span class="toc-section-number">8.1.9</span> Pattern Sequences</a></li>
<li><a href="#infix-operation-patterns"><span class="toc-section-number">8.1.10</span> Infix Operation Patterns</a></li>
<li><a href="#pattern-alternatives"><span class="toc-section-number">8.1.11</span> Pattern Alternatives</a></li>
<li><a href="#xml-patterns"><span class="toc-section-number">8.1.12</span> XML Patterns</a></li>
<li><a href="#regular-expression-patterns"><span class="toc-section-number">8.1.13</span> Regular Expression Patterns</a></li>
<li><a href="#irrefutable-patterns"><span class="toc-section-number">8.1.14</span> Irrefutable Patterns</a></li>
</ul></li>
<li><a href="#type-patterns"><span class="toc-section-number">8.2</span> Type Patterns</a></li>
<li><a href="#type-parameter-inference-in-patterns"><span class="toc-section-number">8.3</span> Type Parameter Inference in Patterns</a></li>
<li><a href="#pattern-matching-expressions"><span class="toc-section-number">8.4</span> Pattern Matching Expressions</a></li>
<li><a href="#pattern-matching-anonymous-functions"><span class="toc-section-number">8.5</span> Pattern Matching Anonymous Functions</a></li>
</ul></li>
<li><a href="#top-level-definitions"><span class="toc-section-number">9</span> Top-Level Definitions</a><ul>
<li><a href="#compilation-units"><span class="toc-section-number">9.1</span> Compilation Units</a></li>
<li><a href="#packagings"><span class="toc-section-number">9.2</span> Packagings</a></li>
<li><a href="#package-objects"><span class="toc-section-number">9.3</span> Package Objects</a></li>
<li><a href="#package-references"><span class="toc-section-number">9.4</span> Package References</a></li>
<li><a href="#programs"><span class="toc-section-number">9.5</span> Programs</a></li>
</ul></li>
<li><a href="#xml-expressions-and-patterns"><span class="toc-section-number">10</span> XML Expressions and Patterns</a><ul>
<li><a href="#xml-expressions"><span class="toc-section-number">10.1</span> XML expressions</a></li>
<li><a href="#xml-patterns-1"><span class="toc-section-number">10.2</span> XML patterns</a></li>
</ul></li>
<li><a href="#user-defined-annotations"><span class="toc-section-number">11</span> User-Defined Annotations</a></li>
<li><a href="#the-scala-standard-library"><span class="toc-section-number">12</span> The Scala Standard Library</a><ul>
<li><a href="#root-classes"><span class="toc-section-number">12.1</span> Root Classes</a></li>
<li><a href="#value-classes"><span class="toc-section-number">12.2</span> Value Classes</a><ul>
<li><a href="#numeric-value-types"><span class="toc-section-number">12.2.1</span> Numeric Value Types</a></li>
<li><a href="#class-boolean"><span class="toc-section-number">12.2.2</span> Class <code>Boolean</code></a></li>
<li><a href="#class-unit"><span class="toc-section-number">12.2.3</span> Class <code>Unit</code></a></li>
</ul></li>
<li><a href="#standard-reference-classes"><span class="toc-section-number">12.3</span> Standard Reference Classes</a><ul>
<li><a href="#class-string"><span class="toc-section-number">12.3.1</span> Class <code>String</code></a></li>
<li><a href="#the-tuple-classes"><span class="toc-section-number">12.3.2</span> The <code>Tuple</code> classes</a></li>
<li><a href="#the-function-classes"><span class="toc-section-number">12.3.3</span> The <code>Function</code> Classes</a></li>
<li><a href="#class-array"><span class="toc-section-number">12.3.4</span> Class <code>Array</code></a></li>
</ul></li>
<li><a href="#class-node"><span class="toc-section-number">12.4</span> Class Node</a></li>
<li><a href="#the-predef-object"><span class="toc-section-number">12.5</span> The <code>Predef</code> Object</a><ul>
<li><a href="#predefined-implicit-definitions"><span class="toc-section-number">12.5.1</span> Predefined Implicit Definitions</a></li>
</ul></li>
</ul></li>
<li><a href="#scala-syntax-summary"><span class="toc-section-number">13</span> Scala Syntax Summary</a></li>
<li><a href="#references"><span class="toc-section-number">14</span> References</a></li>
</ul>
</nav>
<h2 id="preface"><a href="#TOC"><span class="header-section-number">0.1</span> Preface</a></h2>
<p>Scala is a Java-like programming language which unifies object-oriented and functional programming. It is a pure object-oriented language in the sense that every value is an object. Types and behavior of objects are described by classes. Classes can be composed using mixin composition. Scala is designed to work seamlessly with two less pure but mainstream object-oriented languages -- Java and C#.</p>
<p>Scala is a functional language in the sense that every function is a value. Nesting of function definitions and higher-order functions are naturally supported. Scala also supports a general notion of pattern matching which can model the algebraic types used in many functional languages.</p>
<p>Scala has been designed to interoperate seamlessly with Java (an alternative implementation of Scala also works for .NET). Scala classes can call Java methods, create Java objects, inherit from Java classes and implement Java interfaces. None of this requires interface definitions or glue code.</p>
<p>Scala has been developed from 2001 in the programming methods laboratory at EPFL. Version 1.0 was released in November 2003. This document describes the second version of the language, which was released in March 2006. It acts a reference for the language definition and some core library modules. It is not intended to teach Scala or its concepts; for this there are other documents <span class="citation">(Odersky and al. 2004; Odersky 2006; Odersky and Zenger 2005a; Odersky et al. 2003; Odersky and Zenger 2005b)</span></p>
<p>Scala has been a collective effort of many people. The design and the implementation of version 1.0 was completed by Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, StÃ©phane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman, Matthias Zenger, and the author. Iulian Dragos, Gilles Dubochet, Philipp Haller, Sean McDirmid, Lex Spoon, and Geoffrey Washburn joined in the effort to develop the second version of the language and tools. Gilad Bracha, Craig Chambers, Erik Ernst, Matthias Felleisen, Shriram Krishnamurti, Gary Leavens, Sebastian Maneth, Erik Meijer, Klaus Ostermann, Didier RÃ©my, Mads Torgersen, and Philip Wadler have shaped the design of the language through lively and inspiring discussions and comments on previous versions of this document. The contributors to the Scala mailing list have also given very useful feedback that helped us improve the language and its tools.</p>
<h1 id="lexical-syntax"><a href="#TOC"><span class="header-section-number">1</span> Lexical Syntax</a></h1>
<p>Scala programs are written using the Unicode Basic Multilingual Plane (<em>BMP</em>) character set; Unicode supplementary characters are not presently supported. This chapter defines the two modes of Scala's lexical syntax, the Scala mode and the <em>XML</em> mode. If not otherwise mentioned, the following descriptions of Scala tokens refer to Scala mode, and literal characters âcâ refer to the ASCII fragment \u0000-\u007F</p>
<p>In Scala mode, <em>Unicode escapes</em> are replaced by the corresponding Unicode character with the given hexadecimal code.</p>
<pre class="grammar"><code>UnicodeEscape ::= \{\\}u{u} hexDigit hexDigit hexDigit hexDigit
hexDigit      ::= â0â | â¦ | â9â | âAâ | â¦ | âFâ | âaâ | â¦ | âfâ</code></pre>
<p>To construct tokens, characters are distinguished according to the following classes (Unicode general category given in parentheses):</p>
<ol>
<li>Whitespace characters. <code class="grammar">\u0020 | \u0009 | \u000D | \u000A</code></li>
<li>Letters, which include lower case letters(Ll), upper case letters(Lu), titlecase letters(Lt), other letters(Lo), letter numerals(Nl) and the two characters \u0024 â\$â and \u005F â_â, which both count as upper case letters</li>
<li>Digits <code class="grammar">â0â | â¦ | â9â</code></li>
<li>Parentheses <code class="grammar">â(â | â)â | â[â | â]â | â{â | â}â</code></li>
<li>Delimiter characters <code class="grammar">â`â | â'â | â&quot;â | â.â | â;â | â,â</code></li>
<li>Operator characters. These consist of all printable ASCII characters \u0020-\u007F which are in none of the sets above, mathematical symbols(Sm) and other symbols(So).</li>
</ol>
<h2 id="identifiers"><a href="#TOC"><span class="header-section-number">1.1</span> Identifiers</a></h2>
<pre class="grammar"><code>op       ::=  opchar {opchar} 
varid    ::=  lower idrest
plainid  ::=  upper idrest
           |  varid
           |  op
id       ::=  plainid
           |  â`â stringLit â`â
idrest   ::=  {letter | digit} [â_â op]</code></pre>
<p>There are three ways to form an identifier. First, an identifier can start with a letter which can be followed by an arbitrary sequence of letters and digits. This may be followed by underscore â_â characters and another string composed of either letters and digits or of operator characters. Second, an identifier can start with an operator character followed by an arbitrary sequence of operator characters. The preceding two forms are called <em>plain</em> identifiers. Finally, an identifier may also be formed by an arbitrary string between back-quotes (host systems may impose some restrictions on which strings are legal for identifiers). The identifier then is composed of all characters excluding the backquotes themselves.</p>
<p>As usual, a longest match rule applies. For instance, the string</p>
<pre class="sourceCode scala"><code class="sourceCode scala">big_bob++=`def`</code></pre>
<p>decomposes into the three identifiers <code>big_bob</code>, <code>++=</code>, and <code>def</code>. The rules for pattern matching further distinguish between <em>variable identifiers</em>, which start with a lower case letter, and <em>constant identifiers</em>, which do not.</p>
<p>The â$â character is reserved for compiler-synthesized identifiers. User programs should not define identifiers which contain â$â characters.</p>
<p>The following names are reserved words instead of being members of the syntactic class <code>id</code> of lexical identifiers.</p>
<pre><code>abstract    case        catch       class       def
do          else        extends     false       final
finally     for         forSome     if          implicit
import      lazy        match       new         null
object      override    package     private     protected
return      sealed      super       this        throw       
trait       try         true        type        val         
var         while       with        yield
_    :    =    =&gt;    &lt;-    &lt;:    &lt;%     &gt;:    #    @</code></pre>
<p>The Unicode operators \u21D2 âââ and \u2190 âââ, which have the ASCII equivalents â=&gt;â and â&lt;-â, are also reserved.</p>
<ol type="1">
<li><p>Here are examples of identifiers:</p>
<pre><code>    x         Object        maxIndex   p2p      empty_?
    +         `yield`       Î±ÏÎµÏÎ·     _y       dot_product_*
    __system  _MAX_LEN_     </code></pre></li>
<li><p>Backquote-enclosed strings are a solution when one needs to access Java identifiers that are reserved words in Scala. For instance, the statement <code>Thread.yield()</code> is illegal, since <code>yield</code> is a reserved word in Scala. However, here's a work-around: <code class="sourceCode scala">Thread.`<span class="fu">yield</span>`()</code></p></li>
</ol>
<h2 id="newline-characters"><a href="#TOC"><span class="header-section-number">1.2</span> Newline Characters</a></h2>
<pre class="grammar"><code>semi ::= â;â |  nl {nl}</code></pre>
<p>Scala is a line-oriented language where statements may be terminated by semi-colons or newlines. A newline in a Scala source text is treated as the special token ânlâ if the three following criteria are satisfied:</p>
<ol>
<li>The token immediately preceding the newline can terminate a statement.</li>
<li>The token immediately following the newline can begin a statement.</li>
<li>The token appears in a region where newlines are enabled.</li>
</ol>
<p>The tokens that can terminate a statement are: literals, identifiers and the following delimiters and reserved words:</p>
<pre><code>this    null    true    false    return    type    &lt;xml-start&gt;    
_       )       ]       }</code></pre>
<p>The tokens that can begin a statement are all Scala tokens <em>except</em> the following delimiters and reserved words:</p>
<pre><code>catch    else    extends    finally    forSome    match        
with    yield    ,    .    ;    :    =    =&gt;    &lt;-    &lt;:    &lt;%    
&gt;:    #    [    )    ]    }</code></pre>
<p>A <code class="sourceCode scala"><span class="kw">case</span></code> token can begin a statement only if followed by a <code class="sourceCode scala"><span class="kw">class</span></code> or <code class="sourceCode scala"><span class="kw">object</span></code> token.</p>
<p>Newlines are enabled in:</p>
<ol>
<li>all of a Scala source file, except for nested regions where newlines are disabled, and</li>
<li>the interval between matching <code>{</code> and <code>}</code> brace tokens, except for nested regions where newlines are disabled.</li>
</ol>
<p>Newlines are disabled in:</p>
<ol>
<li>the interval between matching <code>(</code> and <code>)</code> parenthesis tokens, except for nested regions where newlines are enabled, and</li>
<li>the interval between matching <code>[</code> and <code>]</code> bracket tokens, except for nested regions where newlines are enabled.</li>
<li>The interval between a <code class="sourceCode scala"><span class="kw">case</span></code> token and its matching <code class="sourceCode scala">=&gt;</code> token, except for nested regions where newlines are enabled.</li>
<li>Any regions analyzed in <a href="#xml-mode">XML mode</a>.</li>
</ol>
<p>Note that the brace characters of <code>{...}</code> escapes in XML and string literals are not tokens, and therefore do not enclose a region where newlines are enabled.</p>
<p>Normally, only a single <code>nl</code> token is inserted between two consecutive non-newline tokens which are on different lines, even if there are multiple lines between the two tokens. However, if two tokens are separated by at least one completely blank line (i.e a line which contains no printable characters), then two <code>nl</code> tokens are inserted.</p>
<p>The Scala grammar (given in full <a href="#scala-syntax-summary">here</a>) contains productions where optional <code>nl</code> tokens, but not semicolons, are accepted. This has the effect that a newline in one of these positions does not terminate an expression or statement. These positions can be summarized as follows:</p>
<p>Multiple newline tokens are accepted in the following places (note that a semicolon in place of the newline would be illegal in every one of these cases):</p>
<ul>
<li>between the condition of an conditional expression (<a href="#conditional-expressions">here</a>) or while loop (<a href="#while-loop-expressions">here</a>) and the next following expression,</li>
<li>between the enumerators of a for-comprehension (<a href="#for-comprehensions-and-for-loops">here</a>) and the next following expression, and</li>
<li>after the initial <code class="sourceCode scala"><span class="kw">type</span></code> keyword in a type definition or declaration (<a href="#type-declarations-and-type-aliases">here</a>).</li>
</ul>
<p>A single new line token is accepted</p>
<ul>
<li>in front of an opening brace â{â, if that brace is a legal continuation of the current statement or expression,</li>
<li>after an infix operator, if the first token on the next line can start an expression (<a href="#prefix-infix-and-postfix-operations">here</a>),</li>
<li>in front of a parameter clause (<a href="#function-declarations-and-definitions">here</a>), and</li>
<li>after an annotation (<a href="#user-defined-annotations">here</a>).</li>
</ul>
<ol start="3" type="1">
<li><p>The following code contains four well-formed statements, each on two lines. The newline tokens between the two lines are not treated as statement separators.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> (x &gt; <span class="dv">0</span>)
  x = x - <span class="dv">1</span>

<span class="kw">while</span> (x &gt; <span class="dv">0</span>)
  x  = x / <span class="dv">2</span>

<span class="kw">for</span> (x &lt;- <span class="dv">1</span> to <span class="dv">10</span>)
  <span class="fu">println</span>(x)

<span class="kw">type</span>
  IntList = List[Int]</code></pre></li>
<li><p>The following code designates an anonymous class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> Iterator[Int]
{
  <span class="kw">private</span> <span class="kw">var</span> x = <span class="dv">0</span>
  <span class="kw">def</span> hasNext = <span class="kw">true</span>
  <span class="kw">def</span> next = { x += <span class="dv">1</span>; x }
}</code></pre>
<p>With an additional newline character, the same code is interpreted as an object creation followed by a local block:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> Iterator[Int] 

{
  <span class="kw">private</span> <span class="kw">var</span> x = <span class="dv">0</span>
  <span class="kw">def</span> hasNext = <span class="kw">true</span>
  <span class="kw">def</span> next = { x += <span class="dv">1</span>; x }
}</code></pre></li>
<li><p>The following code designates a single expression:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  x &lt; <span class="dv">0</span> ||
  x &gt; <span class="dv">10</span></code></pre>
<p>With an additional newline character, the same code is interpreted as two expressions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  x &lt; <span class="dv">0</span> ||

  x &gt; <span class="dv">10</span></code></pre></li>
<li><p>The following code designates a single, curried function definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">func</span>(x: Int)
        (y: Int) = x + y</code></pre>
<p>With an additional newline character, the same code is interpreted as an abstract function definition and a syntactically illegal statement:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">func</span>(x: Int)

        (y: Int) = x + y</code></pre></li>
<li><p>The following code designates an attributed definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">@serializable
<span class="kw">protected</span> <span class="kw">class</span> Data { ... }</code></pre>
<p>With an additional newline character, the same code is interpreted as an attribute and a separate statement (which is syntactically illegal).</p>
<pre class="sourceCode scala"><code class="sourceCode scala">@serializable

<span class="kw">protected</span> <span class="kw">class</span> Data { ... }</code></pre></li>
</ol>
<h2 id="literals"><a href="#TOC"><span class="header-section-number">1.3</span> Literals</a></h2>
<p>There are literals for integer numbers, floating point numbers, characters, booleans, symbols, strings. The syntax of these literals is in each case as in Java.</p>
<!-- TODO 
  say that we take values from Java, give examples of some lits in
  particular float and double. 
-->

<pre class="grammar"><code>Literal  ::=  [â-â] integerLiteral
           |  [â-â] floatingPointLiteral
           |  booleanLiteral
           |  characterLiteral
           |  stringLiteral
           |  symbolLiteral
           |  ânullâ</code></pre>
<h3 id="integer-literals"><a href="#TOC"><span class="header-section-number">1.3.1</span> Integer Literals</a></h3>
<pre class="grammar"><code>integerLiteral  ::=  (decimalNumeral | hexNumeral | octalNumeral) [âLâ | âlâ]
decimalNumeral  ::=  â0â | nonZeroDigit {digit}
hexNumeral      ::=  â0â âxâ hexDigit {hexDigit}
octalNumeral    ::=  â0â octalDigit {octalDigit}
digit           ::=  â0â | nonZeroDigit
nonZeroDigit    ::=  â1â | â¦ | â9â
octalDigit      ::=  â0â | â¦ | â7â</code></pre>
<p>Integer literals are usually of type <code class="sourceCode scala">Int</code>, or of type <code class="sourceCode scala">Long</code> when followed by a <code>L</code> or <code>l</code> suffix. Values of type <code class="sourceCode scala">Int</code> are all integer numbers between \(-2^{31}\) and \(2^{31}-1\), inclusive. Values of type <code class="sourceCode scala">Long</code> are all integer numbers between \(-2^{63}\) and \(2^{63}-1\), inclusive. A compile-time error occurs if an integer literal denotes a number outside these ranges.</p>
<p>However, if the expected type <a href="#expression-typing"><em>pt</em></a> of a literal in an expression is either <code class="sourceCode scala">Byte</code>, <code class="sourceCode scala">Short</code>, or <code class="sourceCode scala">Char</code> and the integer number fits in the numeric range defined by the type, then the number is converted to type <em>pt</em> and the literal's type is <em>pt</em>. The numeric ranges given by these types are:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">Byte</code></td>
<td style="text-align: left;">\(-2^7\) to \(2^7-1\)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">Short</code></td>
<td style="text-align: left;">\(-2^{15}\) to \(2^{15}-1\)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">Char</code></td>
<td style="text-align: left;">\(0\) to \(2^{16}-1\)</td>
</tr>
</tbody>
</table>
<ol start="8" type="1">
<li><p>Here are some integer literals:</p>
<pre><code>0          21          0xFFFFFFFF       0777L</code></pre></li>
</ol>
<h3 id="floating-point-literals"><a href="#TOC"><span class="header-section-number">1.3.2</span> Floating Point Literals</a></h3>
<pre class="grammar"><code>floatingPointLiteral  ::=  digit {digit} â.â {digit} [exponentPart] [floatType]
                        |  â.â digit {digit} [exponentPart] [floatType]
                        |  digit {digit} exponentPart [floatType]
                        |  digit {digit} [exponentPart] floatType
exponentPart          ::=  (âEâ | âeâ) [â+â | â-â] digit {digit}
floatType             ::=  âFâ | âfâ | âDâ | âdâ</code></pre>
<p>Floating point literals are of type <code class="sourceCode scala">Float</code> when followed by a floating point type suffix <code>F</code> or <code>f</code>, and are of type <code class="sourceCode scala">Double</code> otherwise. The type <code class="sourceCode scala">Float</code> consists of all IEEE 754 32-bit single-precision binary floating point values, whereas the type <code class="sourceCode scala">Double</code> consists of all IEEE 754 64-bit double-precision binary floating point values.</p>
<p>If a floating point literal in a program is followed by a token starting with a letter, there must be at least one intervening whitespace character between the two tokens.</p>
<ol start="9" type="1">
<li><p>Here are some floating point literals:</p>
<pre><code>0.0        1e30f      3.14159f      1.0e-100      .1</code></pre></li>
<li><p>The phrase <code class="sourceCode scala"><span class="fl">1.</span>toString</code> parses as three different tokens: <code class="sourceCode scala"><span class="dv">1</span></code>, <code class="sourceCode scala">.</code>, and <code class="sourceCode scala">toString</code>. On the other hand, if a space is inserted after the period, the phrase <code class="sourceCode scala"><span class="dv">1</span>. <span class="fu">toString</span></code> parses as the floating point literal <code class="sourceCode scala"><span class="dv">1</span>.</code> followed by the identifier <code class="sourceCode scala">toString</code>.</p></li>
</ol>
<h3 id="boolean-literals"><a href="#TOC"><span class="header-section-number">1.3.3</span> Boolean Literals</a></h3>
<pre class="grammar"><code>booleanLiteral  ::=  âtrueâ | âfalseâ</code></pre>
<p>The boolean literals <code class="sourceCode scala"><span class="kw">true</span></code> and <code class="sourceCode scala"><span class="kw">false</span></code> are members of type <code class="sourceCode scala">Boolean</code>.</p>
<h3 id="character-literals"><a href="#TOC"><span class="header-section-number">1.3.4</span> Character Literals</a></h3>
<pre class="grammar"><code>characterLiteral  ::=  â&#39;â printableChar â&#39;â
                    |  â&#39;â charEscapeSeq â&#39;â</code></pre>
<p>A character literal is a single character enclosed in quotes. The character is either a printable unicode character or is described by an <a href="#escape-sequences">escape sequence</a>.</p>
<ol start="11" type="1">
<li><p>Here are some character literals:</p>
<pre><code>&#39;a&#39;    &#39;\u0041&#39;    &#39;\n&#39;    &#39;\t&#39;</code></pre></li>
</ol>
<p>Note that <code>'\u000A'</code> is <em>not</em> a valid character literal because Unicode conversion is done before literal parsing and the Unicode character \u000A (line feed) is not a printable character. One can use instead the escape sequence <code>'\n'</code> or the octal escape <code>'\12'</code> (<a href="#escape-sequences">see here</a>).</p>
<h3 id="string-literals"><a href="#TOC"><span class="header-section-number">1.3.5</span> String Literals</a></h3>
<pre class="grammar"><code>stringLiteral  ::=  â\&quot;â {stringElement} â\&quot;â
stringElement  ::=  printableCharNoDoubleQuote  |  charEscapeSeq</code></pre>
<p>A string literal is a sequence of characters in double quotes. The characters are either printable unicode character or are described by <a href="#escape-sequences">escape sequences</a>. If the string literal contains a double quote character, it must be escaped, i.e. <code>&quot;\&quot;&quot;</code>. The value of a string literal is an instance of class <code class="sourceCode scala">String</code>.</p>
<ol start="12" type="1">
<li><p>Here are some string literals:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="st">&quot;Hello,</span><span class="ch">\n</span><span class="st">World!&quot;</span>       
<span class="st">&quot;This string contains a </span><span class="ch">\&quot;</span><span class="st"> character.&quot;</span></code></pre></li>
</ol>
<h4 id="multi-line-string-literals"><a href="#TOC"><span class="header-section-number">1.3.5.1</span> Multi-Line String Literals</a></h4>
<pre><code>stringLiteral   ::=  â&quot;&quot;&quot;â multiLineChars â&quot;&quot;&quot;â
multiLineChars  ::=  {[â&quot;â] [â&quot;â] charNoDoubleQuote} {â&quot;â}</code></pre>
<p>A multi-line string literal is a sequence of characters enclosed in triple quotes <code class="sourceCode scala"><span class="st">&quot;&quot;&quot; ... &quot;&quot;&quot;</span></code>. The sequence of characters is arbitrary, except that it may contain three or more consuctive quote characters only at the very end. Characters must not necessarily be printable; newlines or other control characters are also permitted. Unicode escapes work as everywhere else, but none of the escape sequences <a href="#escape-sequences">here</a> are interpreted.</p>
<ol start="13" type="1">
<li><p>Here is a multi-line string literal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="st">&quot;&quot;&quot;the present string</span>
     spans three 
     lines.<span class="st">&quot;&quot;&quot;</span></code></pre>
<p>This would produce the string:</p>
<pre><code>the present string
     spans three 
     lines.</code></pre></li>
</ol>
<p>The Scala library contains a utility method <code>stripMargin</code> which can be used to strip leading whitespace from multi-line strings. The expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala"> <span class="st">&quot;&quot;&quot;the present string</span>
    spans three 
    lines.<span class="st">&quot;&quot;&quot;.stripMargin</span></code></pre>
<p>evaluates to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">the present string
spans three 
lines.</code></pre>
<p>Method <code>stripMargin</code> is defined in class <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.StringLike">scala.collection.immutable.StringLike</a>. Because there is a predefined <a href="#implicit-conversions">implicit conversion</a> from <code class="sourceCode scala">String</code> to <code class="sourceCode scala">StringLike</code>, the method is applicable to all strings.</p>
<h3 id="escape-sequences"><a href="#TOC"><span class="header-section-number">1.3.6</span> Escape Sequences</a></h3>
<p>The following escape sequences are recognized in character and string literals.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>\b</code></td>
<td style="text-align: left;"><code>\u0008</code>: backspace BS</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\t</code></td>
<td style="text-align: left;"><code>\u0009</code>: horizontal tab HT</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>\n</code></td>
<td style="text-align: left;"><code>\u000a</code>: linefeed LF</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\f</code></td>
<td style="text-align: left;"><code>\u000c</code>: form feed FF</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>\r</code></td>
<td style="text-align: left;"><code>\u000d</code>: carriage return CR</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\&quot;</code></td>
<td style="text-align: left;"><code>\u0022</code>: double quote &quot;</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>\'</code></td>
<td style="text-align: left;"><code>\u0027</code>: single quote '</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\\</code></td>
<td style="text-align: left;"><code>\u005c</code>: backslash <code>\</code></td>
</tr>
</tbody>
</table>
<p>A character with Unicode between 0 and 255 may also be represented by an octal escape, i.e. a backslash ââ followed by a sequence of up to three octal characters.</p>
<p>It is a compile time error if a backslash character in a character or string literal does not start a valid escape sequence.</p>
<h3 id="symbol-literals"><a href="#TOC"><span class="header-section-number">1.3.7</span> Symbol literals</a></h3>
<pre class="grammar"><code>symbolLiteral  ::=  â&#39;â plainid</code></pre>
<p>A symbol literal <code class="sourceCode scala">&#39;x</code> is a shorthand for the expression <code class="sourceCode scala">scala.<span class="fu">Symbol</span>(<span class="st">&quot;x&quot;</span>)</code>. <code>Symbol</code> is a <a href="#case-classes">case class</a>, which is defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Symbol <span class="kw">private</span> (name: String) {
  <span class="kw">override</span> <span class="kw">def</span> toString: String = <span class="st">&quot;&#39;&quot;</span> + name
}</code></pre>
<p>The <code class="sourceCode scala">apply</code> method of <code class="sourceCode scala">Symbol</code>'s companion object caches weak references to <code class="sourceCode scala">Symbol</code>s, thus ensuring that identical symbol literals are equivalent with respect to reference equality.</p>
<h2 id="whitespace-and-comments"><a href="#TOC"><span class="header-section-number">1.4</span> Whitespace and Comments</a></h2>
<p>Tokens may be separated by whitespace characters and/or comments. Comments come in two forms:</p>
<p>A single-line comment is a sequence of characters which starts with <code>//</code> and extends to the end of the line.</p>
<p>A multi-line comment is a sequence of characters between <code>/*</code> and <code>*/</code>. Multi-line comments may be nested, but are required to be properly nested. Therefore, a comment like <code>/* /* */</code> will be rejected as having an unterminated comment.</p>
<h2 id="xml-mode"><a href="#TOC"><span class="header-section-number">1.5</span> XML mode</a></h2>
<p>In order to allow literal inclusion of XML fragments, lexical analysis switches from Scala mode to XML mode when encountering an opening angle bracket '&lt;' in the following circumstance: The '&lt;' must be preceded either by whitespace, an opening parenthesis or an opening brace and immediately followed by a character starting an XML name.</p>
<pre class="grammar"><code> ( whitespace | â(â | â{â ) â&lt;â (XNameStart | â!â | â?â)

  XNameStart ::= â_â | BaseChar | Ideographic // as in W3C XML, but without â:â</code></pre>
<p>The scanner switches from XML mode to Scala mode if either</p>
<ul>
<li>the XML expression or the XML pattern started by the initial â&lt;â has been successfully parsed, or if</li>
<li>the parser encounters an embedded Scala expression or pattern and forces the Scanner back to normal mode, until the Scala expression or pattern is successfully parsed. In this case, since code and XML fragments can be nested, the parser has to maintain a stack that reflects the nesting of XML and Scala expressions adequately.</li>
</ul>
<p>Note that no Scala tokens are constructed in XML mode, and that comments are interpreted as text.</p>
<ol start="14" type="1">
<li><p>The following value definition uses an XML literal with two embedded Scala expressions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> b = &lt;book&gt;
          &lt;title&gt;The Scala Language Specification&lt;/title&gt;
          &lt;version&gt;{scalaBook.<span class="fu">version</span>}&lt;/version&gt;
          &lt;authors&gt;{scalaBook.<span class="fu">authors</span>.<span class="fu">mkList</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;, &quot;</span>, <span class="st">&quot;&quot;</span>)}&lt;/authors&gt;
        &lt;/book&gt;</code></pre></li>
</ol>
<h1 id="identifiers-names-and-scopes"><a href="#TOC"><span class="header-section-number">2</span> Identifiers, Names and Scopes</a></h1>
<p>Names in Scala identify types, values, methods, and classes which are collectively called <em>entities</em>. Names are introduced by local <a href="#basic-declarations-and-definitions">definitions and declarations</a>, <a href="#class-members">inheritance</a>, <a href="#import-clauses">import clauses</a>, or <a href="#packagings">package clauses</a> which are collectively called <em>bindings</em>.</p>
<p>Bindings of different kinds have a precedence defined on them:</p>
<ol>
<li>Definitions and declarations that are local, inherited, or made available by a package clause in the same compilation unit where the definition occurs have highest precedence.</li>
<li>Explicit imports have next highest precedence.</li>
<li>Wildcard imports have next highest precedence.</li>
<li>Definitions made available by a package clause not in the compilation unit where the definition occurs have lowest precedence.</li>
</ol>
<p>There are two different name spaces, one for <a href="#types">types</a> and one for <a href="#expressions">terms</a>. The same name may designate a type and a term, depending on the context where the name is used.</p>
<p>A binding has a <em>scope</em> in which the entity defined by a single name can be accessed using a simple name. Scopes are nested. A binding in some inner scope <em>shadows</em> bindings of lower precedence in the same scope as well as bindings of the same or lower precedence in outer scopes.</p>
<p>Note that shadowing is only a partial order. In a situation like</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x = <span class="dv">1</span>;
{ <span class="kw">import</span> p.<span class="fu">x</span>; 
  x }</code></pre>
<p>neither binding of <code>x</code> shadows the other. Consequently, the reference to <code>x</code> in the third line above would be ambiguous.</p>
<p>A reference to an unqualified (type- or term-) identifier \(x\) is bound by the unique binding, which</p>
<ul>
<li>defines an entity with name \(x\) in the same namespace as the identifier, and</li>
<li>shadows all other bindings that define entities with name \(x\) in that namespace.</li>
</ul>
<p>It is an error if no such binding exists. If \(x\) is bound by an import clause, then the simple name \(x\) is taken to be equivalent to the qualified name to which \(x\) is mapped by the import clause. If \(x\) is bound by a definition or declaration, then \(x\) refers to the entity introduced by that binding. In that case, the type of \(x\) is the type of the referenced entity.</p>
<ol start="15" type="1">
<li><p>Assume the following two definitions of a objects named <code>X</code> in packages <code>P</code> and <code>Q</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> P {
  <span class="kw">object</span> X { <span class="kw">val</span> x = <span class="dv">1</span>; <span class="kw">val</span> y = <span class="dv">2</span> }
}

<span class="kw">package</span> Q {
  <span class="kw">object</span> X { <span class="kw">val</span> x = <span class="kw">true</span>; <span class="kw">val</span> y = <span class="st">&quot;&quot;</span> }
}</code></pre>
<p>The following program illustrates different kinds of bindings and precedences between them.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> P {                  <span class="co">// `X&#39; bound by package clause</span>
<span class="kw">import</span> Console.<span class="fu">_</span>             <span class="co">// `println&#39; bound by wildcard import</span>
<span class="kw">object</span> A {                   
  <span class="fu">println</span>(<span class="st">&quot;L4: &quot;</span>+X)          <span class="co">// `X&#39; refers to `P.X&#39; here</span>
  <span class="kw">object</span> B {
    <span class="kw">import</span> Q.<span class="fu">_</span>               <span class="co">// `X&#39; bound by wildcard import</span>
    <span class="fu">println</span>(<span class="st">&quot;L7: &quot;</span>+X)        <span class="co">// `X&#39; refers to `Q.X&#39; here</span>
    <span class="kw">import</span> X.<span class="fu">_</span>               <span class="co">// `x&#39; and `y&#39; bound by wildcard import</span>
    <span class="fu">println</span>(<span class="st">&quot;L8: &quot;</span>+x)        <span class="co">// `x&#39; refers to `Q.X.x&#39; here</span>
    <span class="kw">object</span> C {
      <span class="kw">val</span> x = <span class="dv">3</span>              <span class="co">// `x&#39; bound by local definition</span>
      <span class="fu">println</span>(<span class="st">&quot;L12: &quot;</span>+x)     <span class="co">// `x&#39; refers to constant `3&#39; here</span>
      { <span class="kw">import</span> Q.<span class="fu">X</span>.<span class="fu">_</span>         <span class="co">// `x&#39; and `y&#39; bound by wildcard import</span>
<span class="co">//      println(&quot;L14: &quot;+x)   // reference to `x&#39; is ambiguous here</span>
        <span class="kw">import</span> X.<span class="fu">y</span>           <span class="co">// `y&#39; bound by explicit import</span>
        <span class="fu">println</span>(<span class="st">&quot;L16: &quot;</span>+y)   <span class="co">// `y&#39; refers to `Q.X.y&#39; here</span>
        { <span class="kw">val</span> x = <span class="st">&quot;abc&quot;</span>      <span class="co">// `x&#39; bound by local definition</span>
          <span class="kw">import</span> P.<span class="fu">X</span>.<span class="fu">_</span>       <span class="co">// `x&#39; and `y&#39; bound by wildcard import</span>
<span class="co">//        println(&quot;L19: &quot;+y) // reference to `y&#39; is ambiguous here</span>
          <span class="fu">println</span>(<span class="st">&quot;L20: &quot;</span>+x) <span class="co">// `x&#39; refers to string ``abc&#39;&#39; here</span>
}}}}}}</code></pre></li>
</ol>
<p>A reference to a qualified (type- or term-) identifier \(e.x\) refers to the member of the type \(T\) of \(e\) which has the name \(x\) in the same namespace as the identifier. It is an error if \(T\) is not a <a href="#value-types">value type</a>. The type of \(e.x\) is the member type of the referenced entity in \(T\).</p>
<h1 id="types"><a href="#TOC"><span class="header-section-number">3</span> Types</a></h1>
<pre class="grammar"><code>  Type              ::=  FunctionArgTypes â=&gt;â Type
                      |  InfixType [ExistentialClause]
  FunctionArgTypes  ::= InfixType
                      | â(â [ ParamType {â,â ParamType } ] â)â
  ExistentialClause ::=  âforSomeâ â{â ExistentialDcl {semi ExistentialDcl} â}â
  ExistentialDcl    ::=  âtypeâ TypeDcl 
                      |  âvalâ ValDcl
  InfixType         ::=  CompoundType {id [nl] CompoundType}
  CompoundType      ::=  AnnotType {âwithâ AnnotType} [Refinement]
                      |  Refinement
  AnnotType         ::=  SimpleType {Annotation}
  SimpleType        ::=  SimpleType TypeArgs
                      |  SimpleType â#â id
                      |  StableId
                      |  Path â.â âtypeâ
                      |  â(â Types â)â
  TypeArgs          ::=  â[â Types â]â
  Types             ::=  Type {â,â Type}</code></pre>
<p>We distinguish between first-order types and type constructors, which take type parameters and yield types. A subset of first-order types called <em>value types</em> represents sets of (first-class) values. Value types are either <em>concrete</em> or <em>abstract</em>.</p>
<p>Every concrete value type can be represented as a <em>class type</em>, i.e. a <a href="#type-designators">type designator</a> that refers to a <a href="#class-definitions">class or a trait</a>,<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> or as a <a href="#compound-types">compound type</a> representing an intersection of types, possibly with a <a href="#compound-types">refinement</a> that further constrains the types of its members. <!-- 
A shorthand exists for denoting [function types](#function-types) 
--> Abstract value types are introduced by <a href="#type-parameters">type parameters</a> and <a href="#type-declarations-and-type-aliases">abstract type bindings</a>. Parentheses in types can be used for grouping.</p>
<p>Non-value types capture properties of identifiers that <a href="#non-value-types">are not values</a>. For example, a <a href="#type-constructors">type constructor</a> does not directly specify a type of values. However, when a type constructor is applied to the correct type arguments, it yields a first-order type, which may be a value type.</p>
<p>Non-value types are expressed indirectly in Scala. E.g., a method type is described by writing down a method signature, which in itself is not a real type, although it gives rise to a corresponding <a href="#method-types">method type</a>. Type constructors are another example, as one can write <code class="sourceCode scala"><span class="kw">type</span> Swap[m[_, _], a,b] = m[b, a]</code>, but there is no syntax to write the corresponding anonymous type function directly.</p>
<h2 id="paths"><a href="#TOC"><span class="header-section-number">3.1</span> Paths</a></h2>
<pre class="grammar"><code>Path            ::=  StableId
                  |  [id â.â] this
StableId        ::=  id
                  |  Path â.â id
                  |  [id â.â] âsuperâ [ClassQualifier] â.â id
ClassQualifier  ::= â[â id â]â</code></pre>
<p>Paths are not types themselves, but they can be a part of named types and in that function form a central role in Scala's type system.</p>
<p>A path is one of the following.</p>
<ul>
<li>The empty path Îµ (which cannot be written explicitly in user programs).</li>
<li><code>$C$.this</code>, where \(C\) references a class. The path <code>this</code> is taken as a shorthand for <code>$C$.this</code> where \(C\) is the name of the class directly enclosing the reference.</li>
<li><code>$p$.$x$</code> where \(p\) is a path and \(x\) is a stable member of \(p\). <em>Stable members</em> are packages or members introduced by object definitions or by value definitions of <a href="#volatile-types">non-volatile types</a>.</li>
<li><code>$C$.super.$x$</code> or <code>$C$.super[$M$].$x$</code> where \(C\) references a class and \(x\) references a stable member of the super class or designated parent class \(M\) of \(C\). The prefix <code class="sourceCode scala"><span class="kw">super</span></code> is taken as a shorthand for <code>$C$.super</code> where \(C\) is the name of the class directly enclosing the reference.</li>
</ul>
<p>A <em>stable identifier</em> is a path which ends in an identifier.</p>
<h2 id="value-types"><a href="#TOC"><span class="header-section-number">3.2</span> Value Types</a></h2>
<p>Every value in Scala has a type which is of one of the following forms.</p>
<h3 id="singleton-types"><a href="#TOC"><span class="header-section-number">3.2.1</span> Singleton Types</a></h3>
<pre class="grammar"><code>SimpleType  ::=  Path â.â type</code></pre>
<p>A singleton type is of the form <code class="sourceCode scala">$p$.<span class="fu">type</span></code>, where \(p\) is a path pointing to a value expected to <a href="#expression-typing">conform</a> to <code class="sourceCode scala">scala.<span class="fu">AnyRef</span></code>. The type denotes the set of values consisting of <code class="sourceCode scala"><span class="kw">null</span></code> and the value denoted by \(p\).</p>
<p>A <em>stable type</em> is either a singleton type or a type which is declared to be a subtype of trait <code class="sourceCode scala">scala.<span class="fu">Singleton</span></code>.</p>
<h3 id="type-projection"><a href="#TOC"><span class="header-section-number">3.2.2</span> Type Projection</a></h3>
<pre class="grammar"><code>SimpleType  ::=  SimpleType â#â id</code></pre>
<p>A type projection <code class="sourceCode scala">$T$#$x$</code> references the type member named \(x\) of type \(T\).</p>
<!--
The following is no longer necessary:
If $x$ references an abstract type member, then $T$ must be a 
[stable type](#singleton-types)
-->

<h3 id="type-designators"><a href="#TOC"><span class="header-section-number">3.2.3</span> Type Designators</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleType  ::=  StableId</code></pre>
<p>A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections.</p>
<p>Specifically, the unqualified type name \(t\) where \(t\) is bound in some class, object, or package \(C\) is taken as a shorthand for <code class="sourceCode scala">$C$.<span class="fu">this</span>.<span class="fu">type</span>#$t$</code>. If \(t\) is not bound in a class, object, or package, then \(t\) is taken as a shorthand for <code>Îµ.type#$t$</code>.</p>
<p>A qualified type designator has the form <code>p.t</code> where <code>p</code> is a <a href="#paths">path</a> and <em>t</em> is a type name. Such a type designator is equivalent to the type projection <code class="sourceCode scala">p.<span class="fu">type</span>#t</code>.</p>
<ol start="16" type="1">
<li><p>Some type designators and their expansions are listed below. We assume a local type parameter \(t\), a value <code>maintable</code> with a type member <code>Node</code> and the standard class <code class="sourceCode scala">scala.<span class="fu">Int</span></code>,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">t</td>
<td style="text-align: left;">Îµ.type#t</td>
</tr>
<tr class="even">
<td style="text-align: left;">Int</td>
<td style="text-align: left;">scala.type#Int</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scala.Int</td>
<td style="text-align: left;">scala.type#Int</td>
</tr>
<tr class="even">
<td style="text-align: left;">data.maintable.Node</td>
<td style="text-align: left;">data.maintable.type#Node</td>
</tr>
</tbody>
</table></li>
</ol>
<h3 id="parameterized-types"><a href="#TOC"><span class="header-section-number">3.2.4</span> Parameterized Types</a></h3>
<pre class="grammar"><code>SimpleType      ::=  SimpleType TypeArgs
TypeArgs        ::=  â[â Types â]â</code></pre>
<p>A parameterized type \(T[ U_1 , \ldots , U_n ]\) consists of a type designator \(T\) and type parameters \(U_1 , \ldots , U_n\) where \(n \geq 1\). \(T\) must refer to a type constructor which takes \(n\) type parameters \(a_1 , \ldots , a_n\).</p>
<p>Say the type parameters have lower bounds \(L_1 , \ldots , L_n\) and upper bounds \(U_1 , \ldots , U_n\). The parameterized type is well-formed if each actual type parameter <em>conforms to its bounds</em>, i.e. \(Ï L_i &lt;: T_i &lt;: Ï U_i\) where \(Ï\) is the substitution \([ a_1 := T_1 , \ldots , a_n := T_n ]\).</p>
<ol start="17" type="1">
<li><p>Given the partial type definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> TreeMap[A &lt;: Comparable[A], B] { â¦ }
<span class="kw">class</span> List[A] { â¦ }
<span class="kw">class</span> I <span class="kw">extends</span> Comparable[I] { â¦ }

<span class="kw">class</span> F[M[_], X] { â¦ }
<span class="kw">class</span> S[K &lt;: String] { â¦ }
<span class="kw">class</span> G[M[ Z &lt;: I ], I] { â¦ }</code></pre>
<p>the following parameterized types are well formed:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  TreeMap[I, String]
  List[I]
  List[List[Boolean]]

  F[List, Int]
  G[S, String]</code></pre></li>
<li><p>Given the type definitions of (17), the following types are ill-formed:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">TreeMap[I]            <span class="co">// illegal: wrong number of parameters</span>
TreeMap[List[I], Int] <span class="co">// illegal: type parameter not within bound</span>

F[Int, Boolean]       <span class="co">// illegal: Int is not a type constructor</span>
F[TreeMap, Int]       <span class="co">// illegal: TreeMap takes two parameters,</span>
                      <span class="co">//   F expects a constructor taking one</span>
G[S, Int]             <span class="co">// illegal: S constrains its parameter to</span>
                      <span class="co">//   conform to String,</span>
                      <span class="co">// G expects type constructor with a parameter</span>
                      <span class="co">//   that conforms to Int</span></code></pre></li>
</ol>
<h3 id="tuple-types"><a href="#TOC"><span class="header-section-number">3.2.5</span> Tuple Types</a></h3>
<pre class="grammar"><code>SimpleType    ::=   â(â Types â)â</code></pre>
<p>A tuple type \((T_1 , \ldots , T_n)\) is an alias for the class <code>scala.Tuple$_n$[$T_1$, â¦ , $T_n$]</code>, where \(n \geq 2\).</p>
<p>Tuple classes are case classes whose fields can be accessed using selectors <code>_1</code> , â¦ , <code>_n</code>. Their functionality is abstracted in a corresponding <code>Product</code> trait. The <em>n</em>-ary tuple class and product trait are defined at least as follows in the standard Scala library (they might also add other methods and implement other traits).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Tuple$n$[+T1, â¦ , +$T_n$](_1: T1, â¦ , _n: $T_n$) 
<span class="kw">extends</span> Product_n[T1, â¦ , $T_n$] {}

<span class="kw">trait</span> Product_n[+T1, â¦ , +$T_n$] {
  <span class="kw">override</span> <span class="kw">def</span> arity = $n$
  <span class="kw">def</span> _1: T1
  â¦
  <span class="kw">def</span> _n: $T_n$
}</code></pre>
<h3 id="annotated-types"><a href="#TOC"><span class="header-section-number">3.2.6</span> Annotated Types</a></h3>
<pre class="grammar"><code>AnnotType  ::=  SimpleType {Annotation}</code></pre>
<p>An annotated type \(T\) <code>$a_1 , \ldots , a_n$</code> attaches <a href="#user-defined-annotations">annotations</a> \(a_1 , \ldots , a_n\) to the type \(T\).</p>
<ol start="19" type="1">
<li><p>The following type adds the <code class="sourceCode scala">@suspendable</code> annotation to the type <code class="sourceCode scala">String</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">String @suspendable</code></pre></li>
</ol>
<h3 id="compound-types"><a href="#TOC"><span class="header-section-number">3.2.7</span> Compound Types</a></h3>
<pre class="grammar"><code>CompoundType    ::=  AnnotType {âwithâ AnnotType} [Refinement]
                  |  Refinement
Refinement      ::=  [nl] â{â RefineStat {semi RefineStat} â}â
RefineStat      ::=  Dcl
                  |  âtypeâ TypeDef
                  |</code></pre>
<p>A compound type <code>$T_1$ with â¦ with $T_n$ { $R$ }</code> represents objects with members as given in the component types \(T_1 , \ldots , T_n\) and the refinement <code>{ $R$ }</code>. A refinement <code>{ $R$ }</code> contains declarations and type definitions. If a declaration or definition overrides a declaration or definition in one of the component types \(T_1 , \ldots , T_n\), the usual rules for <a href="#overriding">overriding</a> apply; otherwise the declaration or definition is said to be âstructuralâ.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p>Within a method declaration in a structural refinement, the type of any value parameter may only refer to type parameters or abstract types that are contained inside the refinement. That is, it must refer either to a type parameter of the method itself, or to a type definition within the refinement. This restriction does not apply to the function's result type.</p>
<p>If no refinement is given, the empty refinement is implicitly added, i.e.Â  <code class="sourceCode scala">$T_1$ <span class="kw">with</span> â¦ <span class="kw">with</span> $T_n$</code> is a shorthand for <code class="sourceCode scala">$T_1$ <span class="kw">with</span> â¦ <span class="kw">with</span> $T_n$ {}</code>.</p>
<p>A compound type may also consist of just a refinement <code>{ $R$ }</code> with no preceding component types. Such a type is equivalent to <code class="sourceCode scala">AnyRef{ R }</code>.</p>
<ol start="20" type="1">
<li><p>The following example shows how to declare and use a function which parameter's type contains a refinement with structural declarations.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Bird</span> (<span class="kw">val</span> name: String) <span class="kw">extends</span> Object {
    <span class="kw">def</span> <span class="fu">fly</span>(height: Int) = â¦
â¦
}
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Plane</span> (<span class="kw">val</span> callsign: String) <span class="kw">extends</span> Object {
    <span class="kw">def</span> <span class="fu">fly</span>(height: Int) = â¦
â¦
}
<span class="kw">def</span> <span class="fu">takeoff</span>(
        runway: Int,
      r: { <span class="kw">val</span> callsign: String; <span class="kw">def</span> <span class="fu">fly</span>(height: Int) }) = {
  tower.<span class="fu">print</span>(r.<span class="fu">callsign</span> + <span class="st">&quot; requests take-off on runway &quot;</span> + runway)
  tower.<span class="fu">read</span>(r.<span class="fu">callsign</span> + <span class="st">&quot; is clear for take-off&quot;</span>)
  r.<span class="fu">fly</span>(<span class="dv">1000</span>)
}
<span class="kw">val</span> bird = <span class="kw">new</span> <span class="fu">Bird</span>(<span class="st">&quot;Polly the parrot&quot;</span>){ <span class="kw">val</span> callsign = name }
<span class="kw">val</span> a380 = <span class="kw">new</span> <span class="fu">Plane</span>(<span class="st">&quot;TZ-987&quot;</span>)
<span class="fu">takeoff</span>(<span class="dv">42</span>, bird)
<span class="fu">takeoff</span>(<span class="dv">89</span>, a380)</code></pre>
<p>Although <code>Bird</code> and <code>Plane</code> do not share any parent class other than <code>Object</code>, the parameter <em>r</em> of function <code>takeoff</code> is defined using a refinement with structural declarations to accept any object that declares a value <code>callsign</code> and a <code>fly</code> function.</p></li>
</ol>
<h3 id="infix-types"><a href="#TOC"><span class="header-section-number">3.2.8</span> Infix Types</a></h3>
<pre class="grammar"><code>InfixType     ::=  CompoundType {id [nl] CompoundType}</code></pre>
<p>An infix type <code>$T_1$ \mathit{op} $T_2$</code> consists of an infix operator \(\mathit{op}\) which gets applied to two type operands \(T_1\) and \(T_2\). The type is equivalent to the type application <code>$\mathit{op}$[$T_1$, $T_2$]</code>. The infix operator \(\mathit{op}\) may be an arbitrary identifier, except for <code>*</code>, which is reserved as a postfix modifier denoting a <a href="#repeated-parameters">repeated parameter type</a>.</p>
<p>All type infix operators have the same precedence; parentheses have to be used for grouping. The <a href="#prefix-infix-and-postfix-operations">associativity</a> of a type operator is determined as for term operators: type operators ending in a colon â:â are right-associative; all other operators are left-associative.</p>
<p>In a sequence of consecutive type infix operations \(t_0 \, \mathit{op} \, t_1 \, \mathit{op_2} \, \ldots \, \mathit{op_n} \, t_n\), all operators \(\mathit{op}_1 , \ldots , \mathit{op}_n\) must have the same associativity. If they are all left-associative, the sequence is interpreted as \((\ldots (t_0 \mathit{op_1} t_1) \mathit{op_2} \ldots) \mathit{op_n} t_n\), otherwise it is interpreted as \(t_0 \mathit{op_1} (t_1 \mathit{op_2} ( \ldots \mathit{op_n} t_n) \ldots)\).</p>
<h3 id="function-types"><a href="#TOC"><span class="header-section-number">3.2.9</span> Function Types</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">Type              ::=  FunctionArgs â=&gt;â Type
FunctionArgs      ::=  InfixType
                    |  â(â [ ParamType {â,â ParamType } ] â)â</code></pre>
<p>The type \((T_1 , \ldots , T_n) \Rightarrow U\) represents the set of function values that take arguments of types \(T1 , \ldots , Tn\) and yield results of type \(U\). In the case of exactly one argument type \(T \Rightarrow U\) is a shorthand for \((T) \Rightarrow U\).<br>An argument type of the form \(\Rightarrow T\) represents a <a href="#by-name-parameters">call-by-name parameter</a> of type \(T\).</p>
<p>Function types associate to the right, e.g. \(S \Rightarrow T \Rightarrow U\) is the same as \(S \Rightarrow (T \Rightarrow U)\).</p>
<p>Function types are shorthands for class types that define <code>apply</code> functions. Specifically, the \(n\)-ary function type \((T_1 , \ldots , T_n) \Rightarrow U\) is a shorthand for the class type <code>Function$_n$[T1 , â¦ , $T_n$, U]</code>. Such class types are defined in the Scala library for \(n\) between 0 and 9 as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">trait</span> Function_n[-T1 , â¦ , -T$_n$, +R] {
  <span class="kw">def</span> <span class="fu">apply</span>(x1: T1 , â¦ , x$_n$: T$_n$): R 
  <span class="kw">override</span> <span class="kw">def</span> toString = <span class="st">&quot;&lt;function&gt;&quot;</span> 
}</code></pre>
<p>Hence, function types are <a href="#variance-annotations">covariant</a> in their result type and contravariant in their argument types.</p>
<h3 id="existential-types"><a href="#TOC"><span class="header-section-number">3.2.10</span> Existential Types</a></h3>
<pre class="grammar"><code>Type               ::= InfixType ExistentialClauses
ExistentialClauses ::= âforSomeâ â{â ExistentialDcl 
                       {semi ExistentialDcl} â}â
ExistentialDcl     ::= âtypeâ TypeDcl 
                    |  âvalâ ValDcl</code></pre>
<p>An existential type has the form <code>$T$ forSome { $Q$ }</code> where \(Q\) is a sequence of <a href="#type-declarations-and-type-aliases">type declarations</a>.</p>
<p>Let \(t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1 , \ldots , t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n\) be the types declared in \(Q\) (any of the type parameter sections <code>[ $\mathit{tps}_i$ ]</code> might be missing). The scope of each type \(t_i\) includes the type \(T\) and the existential clause \(Q\). The type variables \(t_i\) are said to be <em>bound</em> in the type <code>$T$ forSome { $Q$ }</code>. Type variables which occur in a type \(T\) but which are not bound in \(T\) are said to be <em>free</em> in \(T\).</p>
<p>A <em>type instance</em> of <code>$T$ forSome { $Q$ }</code> is a type \(\sigma T\) where \(\sigma\) is a substitution over \(t_1 , \ldots , t_n\) such that, for each \(i\), \(\sigma L_i &lt;: \sigma t_i &lt;: \sigma U_i\). The set of values denoted by the existential type <code>$T$ forSome {$\,Q\,$}</code> is the union of the set of values of all its type instances.</p>
<p>A <em>skolemization</em> of <code>$T$ forSome { $Q$ }</code> is a type instance \(\sigma T\), where \(\sigma\) is the substitution \([t&#39;_1/t_1 , \ldots , t&#39;_n/t_n]\) and each \(t&#39;_i\) is a fresh abstract type with lower bound \(\sigma L_i\) and upper bound \(\sigma U_i\).</p>
<h4 id="simplification-rules"><a href="#TOC"><span class="header-section-number">3.2.10.1</span> Simplification Rules</a></h4>
<p>Existential types obey the following four equivalences:</p>
<ol>
<li>Multiple for-clauses in an existential type can be merged. E.g., <code>$T$ forSome { $Q$ } forSome { $Q'$ }</code> is equivalent to <code>$T$ forSome { $Q$ ; $Q'$}</code>.</li>
<li>Unused quantifications can be dropped. E.g., <code>$T$ forSome { $Q$ ; $Q'$}</code> where none of the types defined in \(Q&#39;\) are referred to by \(T\) or \(Q\), is equivalent to <code>$T$ forSome {$ Q $}</code>.</li>
<li>An empty quantification can be dropped. E.g., <code>$T$ forSome { }</code> is equivalent to \(T\).</li>
<li>An existential type <code>$T$ forSome { $Q$ }</code> where \(Q\) contains a clause <code>type $t[\mathit{tps}] &gt;: L &lt;: U$</code> is equivalent to the type <code>$T'$ forSome { $Q$ }</code> where \(T&#39;\) results from \(T\) by replacing every <a href="#variance-annotations">covariant occurrence</a> of \(t\) in \(T\) by \(U\) and by replacing every contravariant occurrence of \(t\) in \(T\) by \(L\).</li>
</ol>
<h4 id="existential-quantification-over-values"><a href="#TOC"><span class="header-section-number">3.2.10.2</span> Existential Quantification over Values</a></h4>
<p>As a syntactic convenience, the bindings clause in an existential type may also contain value declarations <code>val $x$: $T$</code>. An existential type <code>$T$ forSome { $Q$; val $x$: $S\,$;$\,Q'$ }</code> is treated as a shorthand for the type <code>$T'$ forSome { $Q$; type $t$ &lt;: $S$ with Singleton; $Q'$ }</code>, where \(t\) is a fresh type name and \(T&#39;\) results from \(T\) by replacing every occurrence of <code>$x$.type</code> with \(t\).</p>
<h4 id="placeholder-syntax-for-existential-types"><a href="#TOC"><span class="header-section-number">3.2.10.3</span> Placeholder Syntax for Existential Types</a></h4>
<pre class="grammar"><code>WildcardType   ::=  â_â TypeBounds</code></pre>
<p>Scala supports a placeholder syntax for existential types. A <em>wildcard type</em> is of the form <code>_$\;$&gt;:$\,L\,$&lt;:$\,U$</code>. Both bound clauses may be omitted. If a lower bound clause <code>&gt;:$\,L$</code> is missing, <code>&gt;:$\,$scala.Nothing</code> is assumed. If an upper bound clause <code>&lt;:$\,U$</code> is missing, <code>&lt;:$\,$scala.Any</code> is assumed. A wildcard type is a shorthand for an existentially quantified type variable, where the existential quantification is implicit.</p>
<p>A wildcard type must appear as type argument of a parameterized type. Let \(T = p.c[\mathit{targs},T,\mathit{targs}&#39;]\) be a parameterized type where \(\mathit{targs}, \mathit{targs}&#39;\) may be empty and \(T\) is a wildcard type <code>_$\;$&gt;:$\,L\,$&lt;:$\,U$</code>. Then \(T\) is equivalent to the existential type</p>
<pre><code>$p.c[\mathit{targs},t,\mathit{targs}&#39;]$ forSome { type $t$ &gt;: $L$ &lt;: $U$ }</code></pre>
<p>where \(t\) is some fresh type variable. Wildcard types may also appear as parts of <a href="#infix-types">infix types</a> , <a href="#function-types">function types</a>, or <a href="#tuple-types">tuple types</a>. Their expansion is then the expansion in the equivalent parameterized type.</p>
<ol start="21" type="1">
<li><p>Assume the class definitions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Ref[T]
<span class="kw">abstract</span> <span class="kw">class</span> Outer { <span class="kw">type</span> T } .</code></pre>
<p>Here are some examples of existential types:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Ref[T] <span class="kw">forSome</span> { <span class="kw">type</span> T &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span> }
Ref[x.<span class="fu">T</span>] <span class="kw">forSome</span> { <span class="kw">val</span> x: Outer }
Ref[x_type # T] <span class="kw">forSome</span> { <span class="kw">type</span> x_type &lt;: Outer <span class="kw">with</span> Singleton }</code></pre>
<p>The last two types in this list are equivalent. An alternative formulation of the first type above using wildcard syntax is:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Ref[_ &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span>]</code></pre></li>
<li><p>The type <code>List[List[_]]</code> is equivalent to the existential type</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[List[t] <span class="kw">forSome</span> { <span class="kw">type</span> t }] . </code></pre></li>
<li><p>Assume a covariant type</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> List[+T]</code></pre>
<p>The type</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[T] <span class="kw">forSome</span> { <span class="kw">type</span> T &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span> }</code></pre>
<p>is equivalent (by simplification rule 4 above) to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[java.<span class="fu">lang</span>.<span class="fu">Number</span>] <span class="kw">forSome</span> { <span class="kw">type</span> T &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span> }</code></pre>
<p>which is in turn equivalent (by simplification rules 2 and 3 above) to <code>List[java.lang.Number]</code>.</p></li>
</ol>
<h2 id="non-value-types"><a href="#TOC"><span class="header-section-number">3.3</span> Non-Value Types</a></h2>
<p>The types explained in the following do not denote sets of values, nor do they appear explicitly in programs. They are introduced in this report as the internal types of defined identifiers.</p>
<h3 id="method-types"><a href="#TOC"><span class="header-section-number">3.3.1</span> Method Types</a></h3>
<p>A method type is denoted internally as \((\mathit{Ps})U\), where \((\mathit{Ps})\) is a sequence of parameter names and types \((p_1:T_1 , \ldots , p_n:T_n)\) for some \(n \geq 0\) and \(U\) is a (value or method) type. This type represents named methods that take arguments named \(p_1 , \ldots , p_n\) of types \(T_1 , \ldots , T_n\) and that return a result of type \(U\).</p>
<p>Method types associate to the right: \((\mathit{Ps}_1)(\mathit{Ps}_2)U\) is treated as \((\mathit{Ps}_1)((\mathit{Ps}_2)U)\).</p>
<p>A special case are types of methods without any parameters. They are written here <code>=&gt; T</code>. Parameterless methods name expressions that are re-evaluated each time the parameterless method name is referenced.</p>
<p>Method types do not exist as types of values. If a method name is used as a value, its type is <a href="#implicit-conversions">implicitly converted</a> to a corresponding function type.</p>
<ol start="24" type="1">
<li><p>The declarations</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> a: Int
<span class="kw">def</span> <span class="fu">b</span> (x: Int): Boolean
<span class="kw">def</span> <span class="fu">c</span> (x: Int) (y: String, z: String): String</code></pre>
<p>produce the typings</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a: =&gt; Int
b: (Int) Boolean
c: (Int) (String, String) String</code></pre></li>
</ol>
<h3 id="polymorphic-method-types"><a href="#TOC"><span class="header-section-number">3.3.2</span> Polymorphic Method Types</a></h3>
<p>A polymorphic method type is denoted internally as <code>[$\mathit{tps}\,$]$T$</code> where <code>[$\mathit{tps}\,$]</code> is a type parameter section <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]</code> for some \(n \geq 0\) and \(T\) is a (value or method) type. This type represents named methods that take type arguments <code>$S_1 , \ldots , S_n$</code> which <a href="#parameterized-types">conform</a> to the lower bounds <code>$L_1 , \ldots , L_n$</code> and the upper bounds <code>$U_1 , \ldots , U_n$</code> and that yield results of type \(T\).</p>
<ol start="25" type="1">
<li><p>The declarations</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> empty[A]: List[A]
<span class="kw">def</span> union[A &lt;: Comparable[A]] (x: Set[A], xs: Set[A]): Set[A]</code></pre>
<p>produce the typings</p>
<pre class="sourceCode scala"><code class="sourceCode scala">empty : [A &gt;: Nothing &lt;: Any] List[A]
union : [A &gt;: Nothing &lt;: Comparable[A]] (x: Set[A], xs: Set[A]) Set[A]  .</code></pre></li>
</ol>
<h3 id="type-constructors"><a href="#TOC"><span class="header-section-number">3.3.3</span> Type Constructors</a></h3>
<p>A type constructor is represented internally much like a polymorphic method type. <code>[$\pm$ $a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , \pm a_n$ &gt;: $L_n$ &lt;: $U_n$] $T$</code> represents a type that is expected by a <a href="#type-params">type constructor parameter</a> or an <a href="#type-declarations-and-type-aliases">abstract type constructor binding</a> with the corresponding type parameter clause.</p>
<ol start="26" type="1">
<li><p>Consider this fragment of the <code class="sourceCode scala">Iterable[+X]</code> class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Iterable[+X] {
  <span class="kw">def</span> flatMap[newType[+X] &lt;: Iterable[X], S](f: X =&gt; newType[S]): newType[S]
}</code></pre>
<p>Conceptually, the type constructor <code>Iterable</code> is a name for the anonymous type <code>[+X] Iterable[X]</code>, which may be passed to the <code>newType</code> type constructor parameter in <code>flatMap</code>.</p></li>
</ol>
<h2 id="base-types-and-member-definitions"><a href="#TOC"><span class="header-section-number">3.4</span> Base Types and Member Definitions</a></h2>
<p>Types of class members depend on the way the members are referenced. Central here are three notions, namely: #. the notion of the set of base types of a type \(T\), #. the notion of a type \(T\) in some class \(C\) seen from some prefix type \(S\), #. the notion of the set of member bindings of some type \(T\).</p>
<p>These notions are defined mutually recursively as follows.</p>
<ol>
<li><p>The set of <em>base types</em> of a type is a set of class types, given as follows.</p>
<ul>
<li>The base types of a class type \(C\) with parents \(T_1 , \ldots , T_n\) are \(C\) itself, as well as the base types of the compound type <code>$T_1$ with â¦ with $T_n$ { $R$ }</code>.</li>
<li>The base types of an aliased type are the base types of its alias.</li>
<li>The base types of an abstract type are the base types of its upper bound.</li>
<li>The base types of a parameterized type <code>$C$[$T_1 , \ldots , T_n$]</code> are the base types of type \(C\), where every occurrence of a type parameter \(a_i\) of \(C\) has been replaced by the corresponding parameter type \(T_i\).</li>
<li>The base types of a singleton type <code>$p$.type</code> are the base types of the type of \(p\).</li>
<li>The base types of a compound type <code>$T_1$ with $\ldots$ with $T_n$ { $R$ }</code> are the <em>reduced union</em> of the base classes of all \(T_i\)'s. This means: Let the multi-set \(\mathscr{S}\) be the multi-set-union of the base types of all \(T_i\)'s. If \(\mathscr{S}\) contains several type instances of the same class, say <code>$S^i$#$C$[$T^i_1 , \ldots , T^i_n$]</code> \((i \in I)\), then all those instances are replaced by one of them which conforms to all others. It is an error if no such instance exists. It follows that the reduced union, if it exists, produces a set of class types, where different types are instances of different classes.</li>
<li>The base types of a type selection <code>$S$#$T$</code> are determined as follows. If \(T\) is an alias or abstract type, the previous clauses apply. Otherwise, \(T\) must be a (possibly parameterized) class type, which is defined in some class \(B\). Then the base types of <code>$S$#$T$</code> are the base types of \(T\) in \(B\) seen from the prefix type \(S\).</li>
<li>The base types of an existential type <code>$T$ forSome { $Q$ }</code> are all types <code>$S$ forSome { $Q$ }</code> where \(S\) is a base type of \(T\).</li>
</ul></li>
<li>The notion of a type \(T\) <em>in class \(C\) seen from some prefix type \(S\)</em> makes sense only if the prefix type \(S\) has a type instance of class \(C\) as a base type, say <code>$S'$#$C$[$T_1 , \ldots , T_n$]</code>. Then we define as follows.
<ul>
<li>If <code>$S$ = $\epsilon$.type</code>, then \(T\) in \(C\) seen from \(S\) is \(T\) itself.</li>
<li>Otherwise, if \(S\) is an existential type <code>$S'$ forSome { $Q$ }</code>, and \(T\) in \(C\) seen from \(S&#39;\) is \(T&#39;\), then \(T\) in \(C\) seen from \(S\) is <code>$T'$ forSome {$\,Q\,$}</code>.</li>
<li>Otherwise, if \(T\) is the \(i\)'th type parameter of some class \(D\), then
<ul>
<li>If \(S\) has a base type <code>$D$[$U_1 , \ldots , U_n$]</code>, for some type parameters <code>[$U_1 , \ldots , U_n$]</code>, then \(T\) in \(C\) seen from \(S\) is \(U_i\).</li>
<li>Otherwise, if \(C\) is defined in a class \(C&#39;\), then \(T\) in \(C\) seen from \(S\) is the same as \(T\) in \(C&#39;\) seen from \(S&#39;\).</li>
<li>Otherwise, if \(C\) is not defined in another class, then<br> \(T\) in \(C\) seen from \(S\) is \(T\) itself.</li>
</ul></li>
<li>Otherwise, if \(T\) is the singleton type <code>$D$.this.type</code> for some class \(D\) then
<ul>
<li>If \(D\) is a subclass of \(C\) and \(S\) has a type instance of class \(D\) among its base types, then \(T\) in \(C\) seen from \(S\) is \(S\).</li>
<li>Otherwise, if \(C\) is defined in a class \(C&#39;\), then \(T\) in \(C\) seen from \(S\) is the same as \(T\) in \(C&#39;\) seen from \(S&#39;\).</li>
<li>Otherwise, if \(C\) is not defined in another class, then<br> \(T\) in \(C\) seen from \(S\) is \(T\) itself.</li>
</ul></li>
<li>If \(T\) is some other type, then the described mapping is performed to all its type components.</li>
</ul>
<p>If \(T\) is a possibly parameterized class type, where \(T\)'s class is defined in some other class \(D\), and \(S\) is some prefix type, then we use <code>$T$ seen from $S$'' as a shorthand for</code>\(T\) in \(D\) seen from \(S\)''.</p></li>
<li><p>The <em>member bindings</em> of a type \(T\) are (1) all bindings \(d\) such that there exists a type instance of some class \(C\) among the base types of \(T\) and there exists a definition or declaration \(d&#39;\) in \(C\) such that \(d\) results from \(d&#39;\) by replacing every type \(T&#39;\) in \(d&#39;\) by \(T&#39;\) in \(C\) seen from \(T\), and (2) all bindings of the type's <a href="#compound-types">refinement</a>, if it has one.</p></li>
</ol>
<p>The <em>definition</em> of a type projection <code>$S$#$t$</code> is the member binding \(d_t\) of the type \(t\) in \(S\). In that case, we also say that ~\(S\)#\(t\)` <em>is defined by</em> \(d_t\). share a to</p>
<h2 id="relations-between-types"><a href="#TOC"><span class="header-section-number">3.5</span> Relations between types</a></h2>
<p>We define two relations between types.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Type equivalence</td>
<td style="text-align: left;">\(T \equiv U\)</td>
<td style="text-align: left;">\(T\) and \(U\) are interchangeable in all contexts.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Conformance</td>
<td style="text-align: left;">\(T &lt;: U\)</td>
<td style="text-align: left;">Type \(T\) conforms to type \(U\).</td>
</tr>
</tbody>
</table>
<h3 id="type-equivalence"><a href="#TOC"><span class="header-section-number">3.5.1</span> Type Equivalence</a></h3>
<p>Equivalence \((\equiv)\) between types is the smallest congruence<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> such that the following holds:</p>
<ul>
<li>If \(t\) is defined by a type alias <code>type $t$ = $T$</code>, then \(t\) is equivalent to \(T\).</li>
<li>If a path \(p\) has a singleton type <code>$q$.type</code>, then <code>$p$.type $\equiv q$.type</code>.</li>
<li>If \(O\) is defined by an object definition, and \(p\) is a path consisting only of package or object selectors and ending in \(O\), then <code>$O$.this.type $\equiv p$.type</code>.</li>
<li>Two <a href="#compound-types">compound types</a> are equivalent if the sequences of their component are pairwise equivalent, and occur in the same order, and their refinements are equivalent. Two refinements are equivalent if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements.</li>
<li>Two <a href="#method-types">method types</a> are equivalent if they have equivalent result types, both have the same number of parameters, and corresponding parameters have equivalent types. Note that the names of parameters do not matter for method type equivalence.</li>
<li>Two <a href="#polymorphic-method-types">polymorphic method types</a> are equivalent if they have the same number of type parameters, and, after renaming one set of type parameters by another, the result types as well as lower and upper bounds of corresponding type parameters are equivalent.</li>
<li>Two <a href="#existential-types">existential types</a> are equivalent if they have the same number of quantifiers, and, after renaming one list of type quantifiers by another, the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent.</li>
<li>Two <a href="#type-constructors">type constructors</a> are equivalent if they have the same number of type parameters, and, after renaming one list of type parameters by another, the result types as well as variances, lower and upper bounds of corresponding type parameters are equivalent.</li>
</ul>
<h3 id="conformance"><a href="#TOC"><span class="header-section-number">3.5.2</span> Conformance</a></h3>
<p>The conformance relation \((&lt;:)\) is the smallest transitive relation that satisfies the following conditions.</p>
<ul>
<li>Conformance includes equivalence. If \(T \equiv U\) then \(T &lt;: U\).</li>
<li>For every value type \(T\), <code>scala.Nothing &lt;: $T$ &lt;: scala.Any</code>.</li>
<li><p>For every type constructor \(T\) (with any number of type parameters), <code>scala.Nothing &lt;: $T$ &lt;: scala.Any</code>.</p></li>
<li>For every class type \(T\) such that <code>$T$ &lt;: scala.AnyRef</code> and not <code>$T$ &lt;: scala.NotNull</code> one has <code>scala.Null &lt;: $T$</code>.</li>
<li>A type variable or abstract type \(t\) conforms to its upper bound and its lower bound conforms to \(t\).</li>
<li>A class type or parameterized type conforms to any of its base-types.</li>
<li>A singleton type <code>$p$.type</code> conforms to the type of the path \(p\).</li>
<li>A singleton type <code>$p$.type</code> conforms to the type <code>scala.Singleton</code>.</li>
<li>A type projection <code>$T$#$t$</code> conforms to <code>$U$#$t$</code> if \(T\) conforms to \(U\).</li>
<li>A parameterized type <code>$T$[$T_1$ , â¦ , $T_n$]</code> conforms to <code>$T$[$U_1$ , â¦ , $U_n$]</code> if the following three conditions hold for \(i \in \{ 1 , \ldots , n \}\):
<ol>
<li>If the \(i\)'th type parameter of \(T\) is declared covariant, then \(T_i &lt;: U_i\).</li>
<li>If the \(i\)'th type parameter of \(T\) is declared contravariant, then \(U_i &lt;: T_i\).</li>
<li>If the \(i\)'th type parameter of \(T\) is declared neither covariant nor contravariant, then \(U_i \equiv T_i\).</li>
</ol></li>
<li>A compound type <code>$T_1$ with $\ldots$ with $T_n$ {$R\,$}</code> conforms to each of its component types \(T_i\).</li>
<li>If \(T &lt;: U_i\) for \(i \in \{ 1 , \ldots , n \}\) and for every binding \(d\) of a type or value \(x\) in \(R\) there exists a member binding of \(x\) in \(T\) which subsumes \(d\), then \(T\) conforms to the compound type <code>$U_1$ with $\ldots$ with $U_n$ {$R\,$}</code>.</li>
<li>The existential type <code>$T$ forSome {$\,Q\,$}</code> conforms to \(U\) if its <a href="#existential-types">skolemization</a> conforms to \(U\).</li>
<li>The type \(T\) conforms to the existential type <code>$U$ forSome {$\,Q\,$}</code> if \(T\) conforms to one of the <a href="#existential-types">type instances</a> of <code>$U$ forSome {$\,Q\,$}</code>.</li>
<li>If \(T_i \equiv T&#39;_i\) for \(i \in \{ 1 , \ldots , n\}\) and \(U\) conforms to \(U&#39;\) then the method type \((p_1:T_1 , \ldots , p_n:T_n) U\) conforms to \((p&#39;_1:T&#39;_1 , \ldots , p&#39;_n:T&#39;_n) U&#39;\).</li>
<li>The polymorphic type \([a_1 &gt;: L_1 &lt;: U_1 , \ldots , a_n &gt;: L_n &lt;: U_n] T\) conforms to the polymorphic type \([a_1 &gt;: L&#39;_1 &lt;: U&#39;_1 , \ldots , a_n &gt;: L&#39;_n &lt;: U&#39;_n] T&#39;\) if, assuming \(L&#39;_1 &lt;: a_1 &lt;: U&#39;_1 , \ldots , L&#39;_n &lt;: a_n &lt;: U&#39;_n\) one has \(T &lt;: T&#39;\) and \(L_i &lt;: L&#39;_i\) and \(U&#39;_i &lt;: U_i\) for \(i \in \{ 1 , \ldots , n \}\).</li>
<li>Type constructors \(T\) and \(T&#39;\) follow a similar discipline. We characterize \(T\) and \(T&#39;\) by their type parameter clauses \([a_1 , \ldots , a_n]\) and \([a&#39;_1 , \ldots , a&#39;_n ]\), where an \(a_i\) or \(a&#39;_i\) may include a variance annotation, a higher-order type parameter clause, and bounds. Then, \(T\) conforms to \(T&#39;\) if any list \([t_1 , \ldots , t_n]\) -- with declared variances, bounds and higher-order type parameter clauses -- of valid type arguments for \(T&#39;\) is also a valid list of type arguments for \(T\) and \(T[t_1 , \ldots , t_n] &lt;: T&#39;[t_1 , \ldots , t_n]\). Note that this entails that:
<ul>
<li>The bounds on \(a_i\) must be weaker than the corresponding bounds declared for \(a&#39;_i\).</li>
<li>The variance of \(a_i\) must match the variance of \(a&#39;_i\), where covariance matches covariance, contravariance matches contravariance and any variance matches invariance.</li>
<li>Recursively, these restrictions apply to the corresponding higher-order type parameter clauses of \(a_i\) and \(a&#39;_i\).</li>
</ul></li>
</ul>
<p>A declaration or definition in some compound type of class type \(C\) <em>subsumes</em> another declaration of the same name in some compound type or class type \(C&#39;\), if one of the following holds.</p>
<ul>
<li>A value declaration or definition that defines a name \(x\) with type \(T\) subsumes a value or method declaration that defines \(x\) with type \(T&#39;\), provided \(T &lt;: T&#39;\).</li>
<li>A method declaration or definition that defines a name \(x\) with type \(T\) subsumes a method declaration that defines \(x\) with type \(T&#39;\), provided \(T &lt;: T&#39;\).</li>
<li>A type alias <code>type $t$[$T_1$ , â¦ , $T_n$] = $T$</code> subsumes a type alias <code>type $t$[$T_1$ , â¦ , $T_n$] = $T'$</code> if \(T \equiv T&#39;\).</li>
<li>A type declaration <code>type $t$[$T_1$ , â¦ , $T_n$] &gt;: $L$ &lt;: $U$</code> subsumes a type declaration <code>type $t$[$T_1$ , â¦ , $T_n$] &gt;: $L'$ &lt;: $U'$</code> if \(L&#39; &lt;: L\) and \(U &lt;: U&#39;\).</li>
<li>A type or class definition that binds a type name \(t\) subsumes an abstract type declaration <code>type t[$T_1$ , â¦ , $T_n$] &gt;: L &lt;: U</code> if \(L &lt;: t &lt;: U\).</li>
</ul>
<p>The \((&lt;:)\) relation forms pre-order between types, i.e.Â it is transitive and reflexive. <em>least upper bounds</em> and <em>greatest lower bounds</em> of a set of types are understood to be relative to that order.</p>
<blockquote>
<p><strong>Note</strong>: The least upper bound or greatest lower bound of a set of types does not always exist. For instance, consider the class definitions</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> A[+T] {}
<span class="kw">class</span> B <span class="kw">extends</span> A[B]
<span class="kw">class</span> C <span class="kw">extends</span> A[C]</code></pre>
<blockquote>
<p>Then the types <code>A[Any], A[A[Any]], A[A[A[Any]]], ...</code> form a descending sequence of upper bounds for <code>B</code> and <code>C</code>. The least upper bound would be the infinite limit of that sequence, which does not exist as a Scala type. Since cases like this are in general impossible to detect, a Scala compiler is free to reject a term which has a type specified as a least upper or greatest lower bound, and that bound would be more complex than some compiler-set limit.<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup></p>
<p>The least upper bound or greatest lower bound might also not be unique. For instance <code>A with B</code> and <code>B with A</code> are both greatest lower of <code>A</code> and <code>B</code>. If there are several least upper bounds or greatest lower bounds, the Scala compiler is free to pick any one of them.</p>
</blockquote>
<h3 id="weak-conformance"><a href="#TOC"><span class="header-section-number">3.5.3</span> Weak Conformance</a></h3>
<p>In some situations Scala uses a more general conformance relation. A type \(S\) <em>weakly conforms</em> to a type \(T\), written \(S &lt;:_w T\), if \(S &lt;: T\) or both \(S\) and \(T\) are primitive number types and \(S\) precedes \(T\) in the following ordering.</p>
<pre><code>Byte  $&lt;:_w$ Short 
Short $&lt;:_w$ Int
Char  $&lt;:_w$ Int
Int   $&lt;:_w$ Long
Long  $&lt;:_w$ Float
Float $&lt;:_w$ Double</code></pre>
<p>A <em>weak least upper bound</em> is a least upper bound with respect to weak conformance.</p>
<h2 id="volatile-types"><a href="#TOC"><span class="header-section-number">3.6</span> Volatile Types</a></h2>
<p>Type volatility approximates the possibility that a type parameter or abstract type instance of a type does not have any non-null values. A value member of a volatile type cannot appear in a <a href="#paths">path</a>.</p>
<p>A type is <em>volatile</em> if it falls into one of four categories:</p>
<p>A compound type <code>$T_1$ with â¦ with $T_n$ {$R\,$}</code> is volatile if one of the following two conditions hold.</p>
<ol>
<li>One of \(T_2 , \ldots , T_n\) is a type parameter or abstract type, or</li>
<li>\(T_1\) is an abstract type and and either the refinement \(R\) or a type \(T_j\) for \(j &gt; 1\) contributes an abstract member to the compound type, or</li>
<li>one of \(T_1 , \ldots , T_n\) is a singleton type.</li>
</ol>
<p>Here, a type \(S\) <em>contributes an abstract member</em> to a type \(T\) if \(S\) contains an abstract member that is also a member of \(T\). A refinement \(R\) contributes an abstract member to a type \(T\) if \(R\) contains an abstract declaration which is also a member of \(T\).</p>
<p>A type designator is volatile if it is an alias of a volatile type, or if it designates a type parameter or abstract type that has a volatile type as its upper bound.</p>
<p>A singleton type <code>$p$.type</code> is volatile, if the underlying type of path \(p\) is volatile.</p>
<p>An existential type <code>$T$ forSome {$\,Q\,$}</code> is volatile if \(T\) is volatile.</p>
<h2 id="type-erasure"><a href="#TOC"><span class="header-section-number">3.7</span> Type Erasure</a></h2>
<p>A type is called <em>generic</em> if it contains type arguments or type variables. <em>Type erasure</em> is a mapping from (possibly generic) types to non-generic types. We write \(|T|\) for the erasure of type \(T\). The erasure mapping is defined as follows.</p>
<ul>
<li>The erasure of an alias type is the erasure of its right-hand side.</li>
<li>The erasure of an abstract type is the erasure of its upper bound.</li>
<li>The erasure of the parameterized type <code>scala.Array$[T_1]$</code> is <code>scala.Array$[|T_1|]$</code>.</li>
<li>The erasure of every other parameterized type \(T[T_1 , \ldots , T_n]\) is \(|T|\).</li>
<li>The erasure of a singleton type <code>$p$.type</code> is the erasure of the type of \(p\).</li>
<li>The erasure of a type projection <code>$T$#$x$</code> is <code>|$T$|#$x$</code>.</li>
<li>The erasure of a compound type <code>$T_1$ with $\ldots$ with $T_n$ {$R\,$}</code> is the erasure of the intersection dominator of \(T_1 , \ldots , T_n\).</li>
<li>The erasure of an existential type <code>$T$ forSome {$\,Q\,$}</code> is \(|T|\).</li>
</ul>
<p>The <em>intersection dominator</em> of a list of types \(T_1 , \ldots , T_n\) is computed as follows. Let \(T_{i_1} , \ldots , T_{i_m}\) be the subsequence of types \(T_i\)<br>which are not supertypes of some other type \(T_j\). If this subsequence contains a type designator \(T_c\) that refers to a class which is not a trait, the intersection dominator is \(T_c\). Otherwise, the intersection dominator is the first element of the subsequence, \(T_{i_1}\).</p>
<h1 id="basic-declarations-and-definitions"><a href="#TOC"><span class="header-section-number">4</span> Basic Declarations and Definitions</a></h1>
<pre class="grammar"><code>Dcl         ::=  âvalâ ValDcl
              |  âvarâ VarDcl
              |  âdefâ FunDcl
              |  âtypeâ {nl} TypeDcl
PatVarDef   ::=  âvalâ PatDef
              |  âvarâ VarDef
Def         ::=  PatVarDef
              |  âdefâ FunDef
              |  âtypeâ {nl} TypeDef
              |  TmplDef</code></pre>
<p>A <em>declaration</em> introduces names and assigns them types. It can form part of a <a href="#templates">class definition</a> or of a refinement in a <a href="#compound-types">compound type</a>.</p>
<p>A <em>definition</em> introduces names that denote terms or types. It can form part of an object or class definition or it can be local to a block. Both declarations and definitions produce <em>bindings</em> that associate type names with type definitions or bounds, and that associate term names with types.</p>
<p>The scope of a name introduced by a declaration or definition is the whole statement sequence containing the binding. However, there is a restriction on forward references in blocks: In a statement sequence \(s_1 \ldots s_n\) making up a block, if a simple name in \(s_i\) refers to an entity defined by \(s_j\) where \(j \geq i\), then for all \(s_k\) between and including \(s_i\) and \(s_j\),</p>
<ul>
<li>\(s_k\) cannot be a variable definition.</li>
<li>If \(s_k\) is a value definition, it must be lazy.</li>
</ul>
<h2 id="value-declarations-and-definitions"><a href="#TOC"><span class="header-section-number">4.1</span> Value Declarations and Definitions</a></h2>
<pre class="grammar"><code>Dcl          ::=  âvalâ ValDcl
ValDcl       ::=  ids â:â Type
PatVarDef    ::=  âvalâ PatDef 
PatDef       ::=  Pattern2 {â,â Pattern2} [â:â Type] â=â Expr
ids          ::=  id {â,â id}</code></pre>
<p>A value declaration <code>val $x$: $T$</code> introduces \(x\) as a name of a value of type \(T\).</p>
<p>A value definition <code>val $x$: $T$ = $e$</code> defines \(x\) as a name of the value that results from the evaluation of \(e\). If the value definition is not recursive, the type \(T\) may be omitted, in which case the <a href="#expression-typing">packed type</a> of expression \(e\) is assumed. If a type \(T\) is given, then \(e\) is expected to conform to it.</p>
<p>Evaluation of the value definition implies evaluation of its right-hand side \(e\), unless it has the modifier <code>lazy</code>. The effect of the value definition is to bind \(x\) to the value of \(e\) converted to type \(T\). A <code>lazy</code> value definition evaluates its right hand side \(e\) the first time the value is accessed.</p>
<p>A <em>constant value definition</em> is of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">val</span> x = e</code></pre>
<p>where <code>e</code> is a <a href="#constant-expressions">constant expression</a>. The <code>final</code> modifier must be present and no type annotation may be given. References to the constant value <code>x</code> are themselves treated as constant expressions; in the generated code they are replaced by the definition's right-hand side <code>e</code>.</p>
<p>Value definitions can alternatively have a <a href="#patterns">pattern</a> as left-hand side. If \(p\) is some pattern other than a simple name or a name followed by a colon and a type, then the value definition <code>val $p$ = $e$</code> is expanded as follows:</p>
<ol type="1">
<li>If the pattern \(p\) has bound variables \(x_1 , \ldots , x_n\), where \(n &gt; 1\):</li>
</ol>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> $\$ x$ = $e$ <span class="kw">match</span> {<span class="kw">case</span> $p$ =&gt; {$x_1 , \ldots , x_n$}}
<span class="kw">val</span> $x_1$ = $\$ x$.<span class="fu">_1</span>
$\ldots$
<span class="kw">val</span> $x_n$ = $\$ x$.<span class="fu">_n</span>  .</code></pre>
<p>Here, \(\$ x\) is a fresh name.</p>
<ol start="2" type="1">
<li>If \(p\) has a unique bound variable \(x\):</li>
</ol>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> $x$ = $e$ <span class="kw">match</span> { <span class="kw">case</span> $p$ =&gt; $x$ }</code></pre>
<ol start="3" type="1">
<li>If \(p\) has no bound variables:</li>
</ol>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$ <span class="kw">match</span> { <span class="kw">case</span> $p$ =&gt; ()}</code></pre>
<ol start="27" type="1">
<li><p>The following are examples of value definitions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> pi = <span class="fl">3.1415</span> 
<span class="kw">val</span> pi: Double = <span class="fl">3.1415</span>   <span class="co">// equivalent to first definition</span>
<span class="kw">val</span> Some(x) = <span class="fu">f</span>()         <span class="co">// a pattern definition</span>
<span class="kw">val</span> x :: xs = mylist      <span class="co">// an infix pattern definition</span></code></pre>
<p>The last two definitions have the following expansions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x = <span class="fu">f</span>() <span class="kw">match</span> { <span class="kw">case</span> Some(x) =&gt; x }

<span class="kw">val</span> x$\$$ = mylist <span class="kw">match</span> { <span class="kw">case</span> x :: xs =&gt; {x, xs} }
<span class="kw">val</span> x = x$\$$.<span class="fu">_1</span> 
<span class="kw">val</span> xs = x$\$$.<span class="fu">_2</span> </code></pre></li>
</ol>
<p>The name of any declared or defined value may not end in <code>_=</code>.</p>
<p>A value declaration <code>val $x_1 , \ldots , x_n$: $T$</code> is a shorthand for the sequence of value declarations <code>val $x_1$: $T$; ...; val $x_n$: $T$</code>. A value definition <code>val $p_1 , \ldots , p_n$ = $e$</code> is a shorthand for the sequence of value definitions <code>val $p_1$ = $e$; ...; val $p_n$ = $e$</code>. A value definition <code>val $p_1 , \ldots , p_n: T$ = $e$</code> is a shorthand for the sequence of value definitions <code>val $p_1: T$ = $e$; ...; val $p_n: T$ = $e$</code>.</p>
<h2 id="variable-declarations-and-definitions"><a href="#TOC"><span class="header-section-number">4.2</span> Variable Declarations and Definitions</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">Dcl            ::=  âvarâ VarDcl
PatVarDef      ::=  âvarâ VarDef
VarDcl         ::=  ids â:â Type
VarDef         ::=  PatDef
                 |  ids â:â Type â=â â_â</code></pre>
<p>A variable declaration <code>var $x$: $T$</code> is equivalent to declarations of a <em>getter function</em> \(x\) and a <em>setter function</em> <code>$x$_=</code>, defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> $x$: $T$ 
<span class="kw">def</span> $x$_= ($y$: $T$): Unit</code></pre>
<p>An implementation of a class containing variable declarations may define these variables using variable definitions, or it may define setter and getter functions directly.</p>
<p>A variable definition <code>var $x$: $T$ = $e$</code> introduces a mutable variable with type \(T\) and initial value as given by the expression \(e\). The type \(T\) can be omitted, in which case the type of \(e\) is assumed. If \(T\) is given, then \(e\) is expected to <a href="#expression-typing">conform to it</a>.</p>
<p>Variable definitions can alternatively have a <a href="#patterns">pattern</a> as left-hand side. A variable definition <code>var $p$ = $e$</code> where \(p\) is a pattern other than a simple name or a name followed by a colon and a type is expanded in the same way as a <a href="#value-declarations-and-definitions">value definition</a> <code>val $p$ = $e$</code>, except that the free names in \(p\) are introduced as mutable variables, not values.</p>
<p>The name of any declared or defined variable may not end in <code>_=</code>.</p>
<p>A variable definition <code>var $x$: $T$ = _</code> can appear only as a member of a template. It introduces a mutable field with type Â \(T\) and a default initial value. The default value depends on the type \(T\) as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;">if \(T\) is <code>Int</code> or one of its subrange types</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0L</code></td>
<td style="text-align: left;">if \(T\) is <code>Long</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0.0f</code></td>
<td style="text-align: left;">if \(T\) is <code>Float</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0.0d</code></td>
<td style="text-align: left;">if \(T\) is <code>Double</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>false</code></td>
<td style="text-align: left;">if \(T\) is <code>Boolean</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>{}</code></td>
<td style="text-align: left;">if \(T\) is <code>Unit</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>null</code></td>
<td style="text-align: left;">for all other types \(T\)</td>
</tr>
</tbody>
</table>
<p>When they occur as members of a template, both forms of variable definition also introduce a getter function \(x\) which returns the value currently assigned to the variable, as well as a setter function <code>$x$_=</code> which changes the value currently assigned to the variable. The functions have the same signatures as for a variable declaration. The template then has these getter and setter functions as members, whereas the original variable cannot be accessed directly as a template member.</p>
<ol start="28" type="1">
<li><p>The following example shows how <em>properties</em> can be simulated in Scala. It defines a class <code>TimeOfDayVar</code> of time values with updatable integer fields representing hours, minutes, and seconds. Its implementation contains tests that allow only legal values to be assigned to these fields. The user code, on the other hand, accesses these fields just like normal variables.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> TimeOfDayVar {
  <span class="kw">private</span> <span class="kw">var</span> h: Int = <span class="dv">0</span> 
  <span class="kw">private</span> <span class="kw">var</span> m: Int = <span class="dv">0</span> 
  <span class="kw">private</span> <span class="kw">var</span> s: Int = <span class="dv">0</span> 

  <span class="kw">def</span> hours              =  h 
  <span class="kw">def</span> hours_= (h: Int)   =  <span class="kw">if</span> (<span class="dv">0</span> &lt;= h &amp;&amp; h &lt; <span class="dv">24</span>) <span class="kw">this</span>.<span class="fu">h</span> = h 
                            <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DateError</span>() 

  <span class="kw">def</span> minutes            =  m 
  <span class="kw">def</span> minutes_= (m: Int) =  <span class="kw">if</span> (<span class="dv">0</span> &lt;= m &amp;&amp; m &lt; <span class="dv">60</span>) <span class="kw">this</span>.<span class="fu">m</span> = m
                            <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DateError</span>() 

  <span class="kw">def</span> seconds            =  s 
  <span class="kw">def</span> seconds_= (s: Int) =  <span class="kw">if</span> (<span class="dv">0</span> &lt;= s &amp;&amp; s &lt; <span class="dv">60</span>) <span class="kw">this</span>.<span class="fu">s</span> = s
                            <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DateError</span>() 
}
<span class="kw">val</span> d = <span class="kw">new</span> TimeOfDayVar 
d.<span class="fu">hours</span> = <span class="dv">8</span>; d.<span class="fu">minutes</span> = <span class="dv">30</span>; d.<span class="fu">seconds</span> = <span class="dv">0</span> 
d.<span class="fu">hours</span> = <span class="dv">25</span>                  <span class="co">// throws a DateError exception</span></code></pre></li>
</ol>
<p>A variable declaration <code>var $x_1 , \ldots , x_n$: $T$</code> is a shorthand for the sequence of variable declarations <code>var $x_1$: $T$; ...; var $x_n$: $T$</code>. A variable definition <code>var $x_1 , \ldots , x_n$ = $e$</code> is a shorthand for the sequence of variable definitions <code>var $x_1$ = $e$; ...; var $x_n$ = $e$</code>. A variable definition <code>var $x_1 , \ldots , x_n: T$ = $e$</code> is a shorthand for the sequence of variable definitions <code>var $x_1: T$ = $e$; ...; var $x_n: T$ = $e$</code>.</p>
<h2 id="type-declarations-and-type-aliases"><a href="#TOC"><span class="header-section-number">4.3</span> Type Declarations and Type Aliases</a></h2>
<!-- TODO: Higher-kinded tdecls should have a separate section -->

<pre class="grammar"><code>Dcl        ::=  âtypeâ {nl} TypeDcl
TypeDcl    ::=  id [TypeParamClause] [â&gt;:â Type] [â&lt;:â Type]
Def        ::=  type {nl} TypeDef
TypeDef    ::=  id [TypeParamClause] â=â Type</code></pre>
<p>A <em>type declaration</em> <code>type $t$[$\mathit{tps}\,$] &gt;: $L$ &lt;: $U$</code> declares \(t\) to be an abstract type with lower bound type \(L\) and upper bound type \(U\). If the type parameter clause <code>[$\mathit{tps}\,$]</code> is omitted, \(t\) abstracts over a first-order type, otherwise \(t\) stands for a type constructor that accepts type arguments as described by the type parameter clause.</p>
<p>If a type declaration appears as a member declaration of a type, implementations of the type may implement \(t\) with any type \(T\) for which \(L \conforms T \conforms U\). It is a compile-time error if \(L\) does not conform to \(U\). Either or both bounds may be omitted. If the lower bound \(L\) is absent, the bottom type <code>scala.Nothing</code> is assumed. If the upper bound \(U\) is absent, the top type <code>scala.Any</code> is assumed.</p>
<p>A type constructor declaration imposes additional restrictions on the concrete types for which \(t\) may stand. Besides the bounds \(L\) and \(U\), the type parameter clause may impose higher-order bounds and variances, as governed by the <a href="#conformance">conformance of type constructors</a>.</p>
<p>The scope of a type parameter extends over the bounds <code>&gt;: $L$ &lt;: $U$</code> and the type parameter clause \(\mathit{tps}\) itself. A higher-order type parameter clause (of an abstract type constructor \(tc\)) has the same kind of scope, restricted to the declaration of the type parameter \(tc\).</p>
<p>To illustrate nested scoping, these declarations are all equivalent: <code>type t[m[x] &lt;: Bound[x], Bound[x]]</code>, <code>type t[m[x] &lt;: Bound[x], Bound[y]]</code> and <code>type t[m[x] &lt;: Bound[x], Bound[_]]</code>, as the scope of, e.g., the type parameter of \(m\) is limited to the declaration of \(m\). In all of them, \(t\) is an abstract type member that abstracts over two type constructors: \(m\) stands for a type constructor that takes one type parameter and that must be a subtype of \(Bound\), \(t\)'s second type constructor parameter. <code>t[MutableList, Iterable]</code> is a valid use of \(t\).</p>
<p>A <em>type alias</em> <code>type $t$ = $T$</code> defines \(t\) to be an alias name for the type \(T\). The left hand side of a type alias may have a type parameter clause, e.g. <code>type $t$[$\mathit{tps}\,$] = $T$</code>. The scope of a type parameter extends over the right hand side \(T\) and the type parameter clause \(\mathit{tps}\) itself.</p>
<p>The scope rules for <a href="#basic-declarations-and-definitions">definitions</a> and <a href="#function-declarations-and-definitions">type parameters</a> make it possible that a type name appears in its own bound or in its right-hand side. However, it is a static error if a type alias refers recursively to the defined type constructor itself.<br>That is, the type \(T\) in a type alias <code>type $t$[$\mathit{tps}\,$] = $T$</code> may not refer directly or indirectly to the name \(t\). It is also an error if an abstract type is directly or indirectly its own upper or lower bound.</p>
<ol start="29" type="1">
<li><p>The following are legal type declarations and definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> IntList = List[Integer]
<span class="kw">type</span> T &lt;: Comparable[T]
<span class="kw">type</span> Two[A] = Tuple2[A, A]
<span class="kw">type</span> MyCollection[+X] &lt;: Iterable[X]</code></pre>
<p>The following are illegal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Abs = Comparable[Abs]      <span class="co">// recursive type alias</span>

<span class="kw">type</span> S &lt;: T                     <span class="co">// S, T are bounded by themselves.</span>
<span class="kw">type</span> T &lt;: S

<span class="kw">type</span> T &gt;: Comparable[T.<span class="fu">That</span>]    <span class="co">// Cannot select from T.</span>
                                <span class="co">// T is a type, not a value</span>
<span class="kw">type</span> MyCollection &lt;: Iterable   <span class="co">// Type constructor members must explicitly </span>
                                <span class="co">// state their type parameters.</span></code></pre></li>
</ol>
<p>If a type alias <code>type $t$[$\mathit{tps}\,$] = $S$</code> refers to a class type \(S\), the name \(t\) can also be used as a constructor for objects of type \(S\).</p>
<ol start="30" type="1">
<li><p>The <code>Predef</code> object contains a definition which establishes <code>Pair</code> as an alias of the parameterized class <code>Tuple2</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Pair[+A, +B] = Tuple2[A, B] 
<span class="kw">object</span> Pair {
  <span class="kw">def</span> apply[A, B](x: A, y: B) = <span class="fu">Tuple2</span>(x, y)
  <span class="kw">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}</code></pre>
<p>As a consequence, for any two types \(S\) and \(T\), the type <code>Pair[$S$, $T\,$]</code> is equivalent to the type <code>Tuple2[$S$, $T\,$]</code>. <code>Pair</code> can also be used as a constructor instead of <code>Tuple2</code>, as in:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: Pair[Int, String] = <span class="kw">new</span> Pair(<span class="dv">1</span>, <span class="st">&quot;abc&quot;</span>)</code></pre></li>
</ol>
<h2 id="type-parameters"><a href="#TOC"><span class="header-section-number">4.4</span> Type Parameters</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">TypeParamClause  ::= â[â VariantTypeParam {â,â VariantTypeParam} â]â
VariantTypeParam ::= {Annotation} [â+â | â-â] TypeParam
TypeParam        ::= (id | â_â) [TypeParamClause] [â&gt;:â Type] [â&lt;:â Type] [â:â Type]</code></pre>
<p>Type parameters appear in type definitions, class definitions, and function definitions. In this section we consider only type parameter definitions with lower bounds <code>&gt;: $L$</code> and upper bounds <code>&lt;: $U$</code> whereas a discussion of context bounds <code>: $U$</code> and view bounds <code>&lt;% $U$</code> is deferred to <a href="#context-bounds-and-view-bounds">here</a>.</p>
<p>The most general form of a first-order type parameter is <code>$@a_1 \ldots @a_n$ $\pm$ $t$ &gt;: $L$ &lt;: $U$</code>. Here, \(L\), and \(U\) are lower and upper bounds that constrain possible type arguments for the parameter. It is a compile-time error if \(L\) does not conform to \(U\). \(\pm\) is a <em>variance</em>, i.e.Â an optional prefix of either <code>+</code>, or <code>-</code>. One or more annotations may precede the type parameter.</p>
<p></p>
<p> The names of all type parameters must be pairwise different in their enclosing type parameter clause. The scope of a type parameter includes in each case the whole type parameter clause. Therefore it is possible that a type parameter appears as part of its own bounds or the bounds of other type parameters in the same clause. However, a type parameter may not be bounded directly or indirectly by itself.<br> A type constructor parameter adds a nested type parameter clause to the type parameter. The most general form of a type constructor parameter is <code>$@a_1\ldots@a_n$ $\pm$ $t[\mathit{tps}\,]$ &gt;: $L$ &lt;: $U$</code>.</p>
<p>The above scoping restrictions are generalized to the case of nested type parameter clauses, which declare higher-order type parameters. Higher-order type parameters (the type parameters of a type parameter \(t\)) are only visible in their immediately surrounding parameter clause (possibly including clauses at a deeper nesting level) and in the bounds of \(t\). Therefore, their names must only be pairwise different from the names of other visible parameters. Since the names of higher-order type parameters are thus often irrelevant, they may be denoted with a â_â, which is nowhere visible.</p>
<ol start="31" type="1">
<li><p>Here are some well-formed type parameter clauses:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">[S, T]
[@specialized T, U]
[Ex &lt;: Throwable]
[A &lt;: Comparable[B], B &lt;: A]
[A, B &gt;: A, C &gt;: A &lt;: B]
[M[X], N[X]]
[M[_], N[_]] <span class="co">// equivalent to previous clause</span>
[M[X &lt;: Bound[X]], Bound[_]]
[M[+X] &lt;: Iterable[X]]</code></pre>
<p>The following type parameter clauses are illegal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">[A &gt;: A]                  <span class="co">// illegal, `A&#39; has itself as bound</span>
[A &lt;: B, B &lt;: C, C &lt;: A]  <span class="co">// illegal, `A&#39; has itself as bound</span>
[A, B, C &gt;: A &lt;: B]       <span class="co">// illegal lower bound `A&#39; of `C&#39; does</span>
                          <span class="co">// not conform to upper bound `B&#39;.</span></code></pre></li>
</ol>
<h2 id="variance-annotations"><a href="#TOC"><span class="header-section-number">4.5</span> Variance Annotations</a></h2>
<p>Variance annotations indicate how instances of parameterized types vary with respect to <a href="#conformance">subtyping</a>. A â+â variance indicates a covariant dependency, a â-â variance indicates a contravariant dependency, and a missing variance indication indicates an invariant dependency.</p>
<p>A variance annotation constrains the way the annotated type variable may appear in the type or class which binds the type parameter. In a type definition <code>type $T$[$\mathit{tps}\,$] = $S$</code>, or a type declaration <code>type $T$[$\mathit{tps}\,$] &gt;: $L$ &lt;: $U$</code> type parameters labeled â+â must only appear in covariant position whereas type parameters labeled â-â must only appear in contravariant position. Analogously, for a class definition <code>class $C$[$\mathit{tps}\,$]($\mathit{ps}\,$) extends $T$ { $x$: $S$ =&gt; ...}</code>, type parameters labeled â+â must only appear in covariant position in the self type \(S\) and the template \(T\), whereas type parameters labeled â-â must only appear in contravariant position.</p>
<p>The variance position of a type parameter in a type or template is defined as follows. Let the opposite of covariance be contravariance, and the opposite of invariance be itself. The top-level of the type or template is always in covariant position. The variance position changes at the following constructs.</p>
<ul>
<li>The variance position of a method parameter is the opposite of the variance position of the enclosing parameter clause.</li>
<li>The variance position of a type parameter is the opposite of the variance position of the enclosing type parameter clause.</li>
<li>The variance position of the lower bound of a type declaration or type parameter is the opposite of the variance position of the type declaration or parameter.<br></li>
<li>The type of a mutable variable is always in invariant position.</li>
<li>The prefix \(S\) of a type selection <code>$S$#$T$</code> is always in invariant position.</li>
<li>For a type argument \(T\) of a type <code>$S$[$\ldots T \ldots$ ]</code>: If the corresponding type parameter is invariant, then \(T\) is in invariant position. If the corresponding type parameter is contravariant, the variance position of \(T\) is the opposite of the variance position of the enclosing type <code>$S$[$\ldots T \ldots$ ]</code>.</li>
</ul>
<!-- TODO: handle type aliases --> 

<p>References to the type parameters in <a href="#modifiers">object-private values, variables, or methods</a> of the class are not checked for their variance position. In these members the type parameter may appear anywhere without restricting its legal variance annotations.</p>
<ol start="32" type="1">
<li><p>The following variance annotation is legal.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> P[+A, +B] {
  <span class="kw">def</span> fst: A; <span class="kw">def</span> snd: B
}</code></pre>
<p>With this variance annotation, type instances of \(P\) subtype covariantly with respect to their arguments. For instance,</p>
<pre class="sourceCode scala"><code class="sourceCode scala">P[IOException, String] &lt;: P[Throwable, AnyRef]</code></pre>
<p>If the members of \(P\) are mutable variables, the same variance annotation becomes illegal.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Q[+A, +B](x: A, y: B) { 
  <span class="kw">var</span> fst: A = x           <span class="co">// **** error: illegal variance:</span>
  <span class="kw">var</span> snd: B = y           <span class="co">// `A&#39;, `B&#39; occur in invariant position.</span>
}</code></pre>
<p>If the mutable variables are object-private, the class definition becomes legal again:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> R[+A, +B](x: A, y: B) { 
  <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> fst: A = x        <span class="co">// OK</span>
  <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> snd: B = y        <span class="co">// OK</span>
}</code></pre></li>
<li><p>The following variance annotation is illegal, since \(a\) appears in contravariant position in the parameter of <code>append</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Sequence[+A] {
  <span class="kw">def</span> <span class="fu">append</span>(x: Sequence[A]): Sequence[A]  
                  <span class="co">// **** error: illegal variance: </span>
                  <span class="co">// `A&#39; occurs in contravariant position.</span>
}</code></pre>
<p>The problem can be avoided by generalizing the type of <code>append</code> by means of a lower bound:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Sequence[+A] {
  <span class="kw">def</span> append[B &gt;: A](x: Sequence[B]): Sequence[B] 
}</code></pre></li>
<li><p>Here is a case where a contravariant type parameter is useful.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> OutputChannel[-A] {
  <span class="kw">def</span> <span class="fu">write</span>(x: A): Unit
}</code></pre>
<p>With that annotation, we have that <code>OutputChannel[AnyRef]</code> conforms to <code>OutputChannel[String]</code>.<br>That is, a channel on which one can write any object can substitute for a channel on which one can write only strings.</p></li>
</ol>
<h2 id="function-declarations-and-definitions"><a href="#TOC"><span class="header-section-number">4.6</span> Function Declarations and Definitions</a></h2>
<pre class="grammar"><code>Dcl                ::=  âdefâ FunDcl
FunDcl             ::=  FunSig â:â Type
Def                ::=  âdefâ FunDef
FunDef             ::=  FunSig [â:â Type] â=â Expr 
FunSig             ::=  id [FunTypeParamClause] ParamClauses
FunTypeParamClause ::=  â[â TypeParam {â,â TypeParam} â]â 
ParamClauses       ::=  {ParamClause} [[nl] â(â âimplicitâ Params â)â]
ParamClause        ::=  [nl] â(â [Params] â)â} 
Params             ::=  Param {â,â Param}
Param              ::=  {Annotation} id [â:â ParamType] [â=â Expr]
ParamType          ::=  Type 
                     |  â=&gt;â Type 
                     |  Type â*â</code></pre>
<p>A function declaration has the form <code>def $f\,\mathit{psig}$: $T$</code>, where \(f\) is the function's name, \(\mathit{psig}\) is its parameter signature and \(T\) is its result type. A function definition <code>def $f\,\mathit{psig}$: $T$ = $e$</code> also includes a <em>function body</em> \(e\), i.e.Â an expression which defines the function's result. A parameter signature consists of an optional type parameter clause <code>[$\mathit{tps}\,$]</code>, followed by zero or more value parameter clauses <code>($\mathit{ps}_1$)$\ldots$($\mathit{ps}_n$)</code>. Such a declaration or definition introduces a value with a (possibly polymorphic) method type whose parameter types and result type are as given.</p>
<p>The type of the function body is expected to <a href="#expr-typing">conform</a> to the function's declared result type, if one is given. If the function definition is not recursive, the result type may be omitted, in which case it is determined from the packed type of the function body.</p>
<p>A type parameter clause \(\mathit{tps}\) consists of one or more <a href="#type-declarations-and-type-aliases">type declarations</a>, which introduce type parameters, possibly with bounds. The scope of a type parameter includes the whole signature, including any of the type parameter bounds as well as the function body, if it is present.</p>
<p>A value parameter clause \(\mathit{ps}\) consists of zero or more formal parameter bindings such as <code>$x$: $T$</code> or <code>$x: T = e$</code>, which bind value parameters and associate them with their types. Each value parameter declaration may optionally define a default argument. The default argument expression \(e\) is type-checked with an expected type \(T&#39;\) obtained by replacing all occurences of the function's type parameters in \(T\) by the undefined type.</p>
<p>For every parameter \(p_{i,j}\) with a default argument a method named <code>$f\$$default$\$$n</code> is generated which computes the default argument expression. Here, \(n\) denotes the parameter's position in the method declaration. These methods are parametrized by the type parameter clause <code>[$\mathit{tps}\,$]</code> and all value parameter clauses <code>($\mathit{ps}_1$)$\ldots$($\mathit{ps}_{i-1}$)</code> preceeding \(p_{i,j}\). The <code>$f\$$default$\$$n</code> methods are inaccessible for user programs.</p>
<p>The scope of a formal value parameter name \(x\) comprises all subsequent parameter clauses, as well as the method return type and the function body, if they are given.<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup> Both type parameter names and value parameter names must be pairwise distinct.</p>
<ol start="35" type="1">
<li><p>In the method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> compare[T](a: T = <span class="dv">0</span>)(b: T = a) = (a == b)</code></pre>
<p>the default expression <code>0</code> is type-checked with an undefined expected type. When applying <code>compare()</code>, the default value <code>0</code> is inserted and <code>T</code> is instantiated to <code>Int</code>. The methods computing the default arguments have the form:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> compare$\$$default$\$$<span class="dv">1</span>[T]: Int = <span class="dv">0</span>
<span class="kw">def</span> compare$\$$default$\$$<span class="dv">2</span>[T](a: T): T = a</code></pre></li>
</ol>
<h3 id="by-name-parameters"><a href="#TOC"><span class="header-section-number">4.6.1</span> By-Name Parameters</a></h3>
<pre class="grammar"><code>ParamType          ::=  â=&gt;â Type</code></pre>
<p>The type of a value parameter may be prefixed by <code>=&gt;</code>, e.g.<br><code>$x$: =&gt; $T$</code>. The type of such a parameter is then the parameterless method type <code>=&gt; $T$</code>. This indicates that the corresponding argument is not evaluated at the point of function application, but instead is evaluated at each use within the function. That is, the argument is evaluated using <em>call-by-name</em>.</p>
<p>The by-name modifier is disallowed for parameters of classes that carry a <code>val</code> or <code>var</code> prefix, including parameters of case classes for which a <code>val</code> prefix is implicitly generated. The by-name modifier is also disallowed for <a href="#implicit-parameters">implicit parameters</a>.</p>
<ol start="36" type="1">
<li><p>The declaration</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">whileLoop</span> (cond: =&gt; Boolean) (stat: =&gt; Unit): Unit</code></pre>
<p>indicates that both parameters of <code>whileLoop</code> are evaluated using call-by-name.</p></li>
</ol>
<h3 id="repeated-parameters"><a href="#TOC"><span class="header-section-number">4.6.2</span> Repeated Parameters</a></h3>
<pre class="grammar"><code>ParamType          ::=  Type â*â</code></pre>
<p>The last value parameter of a parameter section may be suffixed by â*â, e.g. <code>(..., $x$:$T$*)</code>. The type of such a <em>repeated</em> parameter inside the method is then the sequence type <code>scala.Seq[$T$]</code>. Methods with repeated parameters <code>$T$*</code> take a variable number of arguments of type \(T\). That is, if a method \(m\) with type <code>($p_1:T_1 , \ldots , p_n:T_n, p_s:S$*)$U$</code> is applied to arguments \((e_1 , \ldots , e_k)\) where \(k \geq n\), then \(m\) is taken in that application to have type \((p_1:T_1 , \ldots , p_n:T_n, p_s:S , \ldots , p_{s&#39;}S)U\), with \(k - n\) occurrences of type \(S\) where any parameter names beyond \(p_s\) are fresh. The only exception to this rule is if the last argument is marked to be a <em>sequence argument</em> via a <code>_*</code> type annotation. If \(m\) above is applied to arguments <code>($e_1 , \ldots , e_n, e'$: _*)</code>, then the type of \(m\) in that application is taken to be <code>($p_1:T_1, \ldots , p_n:T_n,p_{s}:$scala.Seq[$S$])</code>.</p>
<p>It is not allowed to define any default arguments in a parameter section with a repeated parameter.</p>
<ol start="37" type="1">
<li><p>The following method definition computes the sum of the squares of a variable number of integer arguments.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sum</span>(args: Int*) = {
  <span class="kw">var</span> result = <span class="dv">0</span>
  <span class="kw">for</span> (arg &lt;- args) result += arg * arg
  result
}</code></pre>
<p>The following applications of this method yield <code>0</code>, <code>1</code>, <code>6</code>, in that order.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>()
<span class="fu">sum</span>(<span class="dv">1</span>)
<span class="fu">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p>Furthermore, assume the definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p>The following application of method <code>sum</code> is ill-formed:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(xs)       <span class="co">// ***** error: expected: Int, found: List[Int]</span></code></pre>
<p>By contrast, the following application is well formed and yields again the result <code>6</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(xs: _*) </code></pre></li>
</ol>
<h3 id="procedures"><a href="#TOC"><span class="header-section-number">4.6.3</span> Procedures</a></h3>
<pre class="grammar"><code>FunDcl   ::=  FunSig
FunDef   ::=  FunSig [nl] â{â Block â}â</code></pre>
<p>Special syntax exists for procedures, i.e.Â functions that return the  value . A procedure declaration is a function declaration where the result type is omitted. The result type is then implicitly completed to the  type. E.g., <code>def $f$($\mathit{ps}$)</code> is equivalent to <code>def $f$($\mathit{ps}$): Unit</code>.</p>
<p>A procedure definition is a function definition where the result type and the equals sign are omitted; its defining expression must be a block. E.g., <code>def $f$($\mathit{ps}$) {$\mathit{stats}$}</code> is equivalent to <code>def $f$($\mathit{ps}$): Unit = {$\mathit{stats}$}</code>.</p>
<ol start="38" type="1">
<li><p>Here is a declaration and a definition of a procedure named <code>write</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Writer { 
  <span class="kw">def</span> <span class="fu">write</span>(str: String)
}
<span class="kw">object</span> Terminal <span class="kw">extends</span> Writer {
  <span class="kw">def</span> <span class="fu">write</span>(str: String) { System.<span class="fu">out</span>.<span class="fu">println</span>(str) }
}</code></pre>
<p>The code above is implicitly completed to the following code:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Writer { 
  <span class="kw">def</span> <span class="fu">write</span>(str: String): Unit
}
<span class="kw">object</span> Terminal <span class="kw">extends</span> Writer {
  <span class="kw">def</span> <span class="fu">write</span>(str: String): Unit = { System.<span class="fu">out</span>.<span class="fu">println</span>(str) }
}</code></pre></li>
</ol>
<h3 id="method-return-type-inference"><a href="#TOC"><span class="header-section-number">4.6.4</span> Method Return Type Inference</a></h3>
<p>A class member definition \(m\) that overrides some other function \(m&#39;\) in a base class of \(C\) may leave out the return type, even if it is recursive. In this case, the return type \(R&#39;\) of the overridden function \(m&#39;\), seen as a member of \(C\), is taken as the return type of \(m\) for each recursive invocation of \(m\). That way, a type \(R\) for the right-hand side of \(m\) can be determined, which is then taken as the return type of \(m\). Note that \(R\) may be different from \(R&#39;\), as long as \(R\) conforms to \(R&#39;\).</p>
<ol start="39" type="1">
<li><p>Assume the following definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> I {
  <span class="kw">def</span> <span class="fu">factorial</span>(x: Int): Int
}
<span class="kw">class</span> C <span class="kw">extends</span> I {
  <span class="kw">def</span> <span class="fu">factorial</span>(x: Int) = <span class="kw">if</span> (x == <span class="dv">0</span>) <span class="dv">1</span> <span class="kw">else</span> x * <span class="fu">factorial</span>(x - <span class="dv">1</span>)
}</code></pre>
<p>Here, it is OK to leave out the result type of <code>factorial</code> in <code>C</code>, even though the method is recursive.</p></li>
</ol>
<h2 id="import-clauses"><a href="#TOC"><span class="header-section-number">4.7</span> Import Clauses</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">Import          ::= âimportâ ImportExpr {â,â ImportExpr}
ImportExpr      ::= StableId â.â (id | â_â | ImportSelectors)
ImportSelectors ::= â{â {ImportSelector â,â} 
                    (ImportSelector | â_â) â}â
ImportSelector  ::= id [â=&gt;â id | â=&gt;â â_â]</code></pre>
<p>An import clause has the form <code>import $p$.$I$</code> where \(p\) is a <a href="#paths">stable identifier</a> and \(I\) is an import expression. The import expression determines a set of names of importable members of \(p\) which are made available without qualification. A member \(m\) of \(p\) is <em>importable</em> if it is not <a href="#modifiers">object-private</a>. The most general form of an import expression is a list of {}</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ $x_1$ =&gt; $y_1 , \ldots , x_n$ =&gt; $y_n$, _ } </code></pre>
<p>for \(n \geq 0\), where the final wildcard â_â may be absent. It makes available each importable member <code>$p$.$x_i$</code> under the unqualified name \(y_i\). I.e.Â every import selector <code>$x_i$ =&gt; $y_i$</code> renames <code>$p$.$x_i$</code> to \(y_i\). If a final wildcard is present, all importable members \(z\) of \(p\) other than <code>$x_1 , \ldots , x_n,y_1 , \ldots , y_n$</code> are also made available under their own unqualified names.</p>
<p>Import selectors work in the same way for type and term members. For instance, an import clause <code>import $p$.{$x$ =&gt; $y\,$}</code> renames the term name <code>$p$.$x$</code> to the term name \(y\) and the type name <code>$p$.$x$</code> to the type name \(y\). At least one of these two names must reference an importable member of \(p\).</p>
<p>If the target in an import selector is a wildcard, the import selector hides access to the source member. For instance, the import selector <code>$x$ =&gt; _</code> ârenamesâ \(x\) to the wildcard symbol (which is unaccessible as a name in user programs), and thereby effectively prevents unqualified access to \(x\). This is useful if there is a final wildcard in the same import selector list, which imports all members not mentioned in previous import selectors.</p>
<p>The scope of a binding introduced by an import-clause starts immediately after the import clause and extends to the end of the enclosing block, template, package clause, or compilation unit, whichever comes first.</p>
<p>Several shorthands exist. An import selector may be just a simple name \(x\). In this case, \(x\) is imported without renaming, so the import selector is equivalent to <code>$x$ =&gt; $x$</code>. Furthermore, it is possible to replace the whole import selector list by a single identifier or wildcard. The import clause <code>import $p$.$x$</code> is equivalent to <code>import $p$.{$x\,$}</code>, i.e.Â it makes available without qualification the member \(x\) of \(p\). The import clause <code>import $p$._</code> is equivalent to <code>import $p$.{_}</code>, i.e.Â it makes available without qualification all members of \(p\) (this is analogous to <code>import $p$.*</code> in Java).</p>
<p>An import clause with multiple import expressions <code>import $p_1$.$I_1 , \ldots , p_n$.$I_n$</code> is interpreted as a sequence of import clauses <code>import $p_1$.$I_1$; $\ldots$; import $p_n$.$I_n$</code>.</p>
<ol start="40" type="1">
<li><p>Consider the object definition:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.scala} object M { def z = 0, one = 1<br> def add(x: Int, y: Int): Int = x + y } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Then the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">import</span> M.{one, z =&gt; zero, _}; <span class="fu">add</span>(zero, one) }</code></pre>
<p>is equivalent to the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ M.<span class="fu">add</span>(M.<span class="fu">z</span>, M.<span class="fu">one</span>) } </code></pre></li>
</ol>
<h1 id="classes-and-objects"><a href="#TOC"><span class="header-section-number">5</span> Classes and Objects</a></h1>
<pre class="grammar"><code>TmplDef          ::= [`case&#39;] `class&#39; ClassDef
                  |  [`case&#39;] `object&#39; ObjectDef
                  |  `trait&#39; TraitDef</code></pre>
<p><a href="#class-definitions">Classes</a> and <a href="#object-definitions">objects</a> are both defined in terms of <em>templates</em>.</p>
<h2 id="templates"><a href="#TOC"><span class="header-section-number">5.1</span> Templates</a></h2>
<pre class="grammar"><code>ClassTemplate   ::=  [EarlyDefs] ClassParents [TemplateBody]
TraitTemplate   ::=  [EarlyDefs] TraitParents [TemplateBody]
ClassParents    ::=  Constr {`with&#39; AnnotType}
TraitParents    ::=  AnnotType {`with&#39; AnnotType}
TemplateBody    ::=  [nl] `{&#39; [SelfType] TemplateStat {semi TemplateStat} `}&#39;
SelfType        ::=  id [`:&#39; Type] `=&gt;&#39;
                 |   this `:&#39; Type `=&gt;&#39;</code></pre>
<p>A template defines the type signature, behavior and initial state of a trait or class of objects or of a single object. Templates form part of instance creation expressions, class definitions, and object definitions. A template <code>$sc$ with $mt_1$ with $\ldots$ with $mt_n$ { $\mathit{stats}$ }</code> consists of a constructor invocation \(sc\) which defines the template's <em>superclass</em>, trait references <code>$mt_1 , \ldots , mt_n$</code> \((n \geq 0)\), which define the template's <em>traits</em>, and a statement sequence \(\mathit{stats}\) which contains initialization code and additional member definitions for the template.</p>
<p>Each trait reference \(mt_i\) must denote a <a href="#traits">trait</a>. By contrast, the superclass constructor \(sc\) normally refers to a class which is not a trait. It is possible to write a list of parents that starts with a trait reference, e.g. <code>$mt_1$ with $\ldots$ with $mt_n$</code>. In that case the list of parents is implicitly extended to include the supertype of \(mt_1\) as first parent type. The new supertype must have at least one constructor that does not take parameters. In the following, we will always assume that this implicit extension has been performed, so that the first parent class of a template is a regular superclass constructor, not a trait reference.</p>
<p>The list of parents of every class is also always implicitly extended by a reference to the <code>scala.ScalaObject</code> trait as last mixin. E.g.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ { $\mathit{stats}$ }</code></pre>
<p>becomes</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ <span class="kw">with</span> ScalaObject { $\mathit{stats}$ }.</code></pre>
<p>The list of parents of a template must be well-formed. This means that the class denoted by the superclass constructor \(sc\) must be a subclass of the superclasses of all the traits \(mt_1 , \ldots , mt_n\). In other words, the non-trait classes inherited by a template form a chain in the inheritance hierarchy which starts with the template's superclass.</p>
<p>The <em>least proper supertype</em> of a template is the class type or <a href="#compound-types">compound type</a> consisting of all its parent class types.</p>
<p>The statement sequence \(\mathit{stats}\) contains member definitions that define new members or overwrite members in the parent classes. If the template forms part of an abstract class or trait definition, the statement part \(\mathit{stats}\) may also contain declarations of abstract members. If the template forms part of a concrete class definition, \(\mathit{stats}\) may still contain declarations of abstract type members, but not of abstract term members. Furthermore, \(\mathit{stats}\) may in any case also contain expressions; these are executed in the order they are given as part of the initialization of a template.</p>
<p>The sequence of template statements may be prefixed with a formal parameter definition and an arrow, e.g.Â <code>$x$ =&gt;</code>, or <code>$x$:$T$ =&gt;</code>. If a formal parameter is given, it can be used as an alias for the reference <code>this</code> throughout the body of the template.<br>If the formal parameter comes with a type \(T\), this definition affects the <em>self type</em> \(S\) of the underlying class or object as follows: Let \(C\) be the type of the class or trait or object defining the template. If a type \(T\) is given for the formal self parameter, \(S\) is the greatest lower bound of \(T\) and \(C\). If no type \(T\) is given, \(S\) is just \(C\). Inside the template, the type of <code>this</code> is assumed to be \(S\).</p>
<p>The self type of a class or object must conform to the self types of all classes which are inherited by the template \(t\).</p>
<p>A second form of self type annotation reads just <code>this: $S$ =&gt;</code>. It prescribes the type \(S\) for <code>this</code> without introducing an alias name for it.</p>
<ol start="41" type="1">
<li><p>Consider the following class definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Base <span class="kw">extends</span> Object {}
<span class="kw">trait</span> Mixin <span class="kw">extends</span> Base {}
<span class="kw">object</span> O <span class="kw">extends</span> Mixin {}</code></pre>
<p>In this case, the definition of <code>O</code> is expanded to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> O <span class="kw">extends</span> Base <span class="kw">with</span> Mixin {}</code></pre></li>
</ol>
<!-- TODO: Make all references to Java generic -->

<p><strong>Inheriting from Java Types</strong> <br>A template may have a Java class as its superclass and Java interfaces as its mixins.</p>
<p><strong>Template Evaluation</strong> <br>Consider a template <code>$sc$ with $mt_1$ with $mt_n$ { $\mathit{stats}$ }</code>.</p>
<p>If this is the template of a <a href="#traits">trait</a> then its <em>mixin-evaluation</em> consists of an evaluation of the statement sequence \(\mathit{stats}\).</p>
<p>If this is not a template of a trait, then its <em>evaluation</em> consists of the following steps.</p>
<ul>
<li>First, the superclass constructor \(sc\) is <a href="#constructor-invocations">evaluated</a>.</li>
<li>Then, all base classes in the template's <a href="#class-linearization">linearization</a> up to the template's superclass denoted by \(sc\) are mixin-evaluated. Mixin-evaluation happens in reverse order of occurrence in the linearization.</li>
<li>Finally the statement sequence \(\mathit{stats}\,\) is evaluated.</li>
</ul>
<p><em>Delayed Initializaton</em> <br>The initialization code of an object or class (but not a trait) that follows the superclass constructor invocation and the mixin-evaluation of the template's base classes is passed to a special hook, which is inaccessible from user code. Normally, that hook simply executes the code that is passed to it. But templates inheriting the <code>scala.DelayedInit</code> trait can override the hook by re-implementing the <code>delayedInit</code> method, which is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">delayedInit</span>(body: =&gt; Unit)</code></pre>
<h3 id="constructor-invocations"><a href="#TOC"><span class="header-section-number">5.1.1</span> Constructor Invocations</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">Constr  ::=  AnnotType {`(&#39; [Exprs] `)&#39;}</code></pre>
<p>Constructor invocations define the type, members, and initial state of objects created by an instance creation expression, or of parts of an object's definition which are inherited by a class or object definition. A constructor invocation is a function application <code>$x$.$c$[$\mathit{targs}$]($\mathit{args}_1$)$\ldots$($\mathit{args}_n$)</code>, where \(x\) is a <a href="#paths">stable identifier</a>, \(c\) is a type name which either designates a class or defines an alias type for one, \(\mathit{targs}\) is a type argument list, \(\mathit{args}_1 , \ldots , \mathit{args}_n\) are argument lists, and there is a constructor of that class which is <a href="#function-applications">applicable</a> to the given arguments. If the constructor invocation uses named or default arguments, it is transformed into a block expression using the same transformation as described <a href="sec:named-default">here</a>.</p>
<p>The prefix `<code>$x$.</code>' can be omitted. A type argument list can be given only if the class \(c\) takes type parameters. Even then it can be omitted, in which case a type argument list is synthesized using <a href="#local-type-inference">local type inference</a>. If no explicit arguments are given, an empty list <code>()</code> is implicitly supplied.</p>
<p>An evaluation of a constructor invocation <code>$x$.$c$[$\mathit{targs}$]($\mathit{args}_1$)$\ldots$($\mathit{args}_n$)</code> consists of the following steps:</p>
<ul>
<li>First, the prefix \(x\) is evaluated.</li>
<li>Then, the arguments \(\mathit{args}_1 , \ldots , \mathit{args}_n\) are evaluated from left to right.</li>
<li>Finally, the class being constructed is initialized by evaluating the template of the class referred to by \(c\).</li>
</ul>
<h3 id="class-linearization"><a href="#TOC"><span class="header-section-number">5.1.2</span> Class Linearization</a></h3>
<p>The classes reachable through transitive closure of the direct inheritance relation from a class \(C\) are called the <em>base classes</em> of \(C\). Because of mixins, the inheritance relationship on base classes forms in general a directed acyclic graph. A linearization of this graph is defined as follows.</p>
<blockquote>
<p>Let \(C\) be a class with template <code>$C_1$ with ... with $C_n$ { $\mathit{stats}$ }</code>. The <em>linearization</em> of \(C\), \(\mathcal{L}(C)\) is defined as follows:</p>
<p>\(\mathcal{L}(C) = C, \mathcal{L}(C_n) \; \vec{+} \; \ldots \; \vec{+} \; \mathcal{L}(C_1)\)</p>
<p>Here \(\vec{+}\) denotes concatenation where elements of the right operand replace identical elements of the left operand:</p>
<pre class="math"><code>\[
\begin{array}{lcll}
\{a, A\} \;\vec{+}\; B &amp;=&amp; a, (A \;\vec{+}\; B)  &amp;{\bf if} \; a \not\in B \\
                       &amp;=&amp; A \;\vec{+}\; B       &amp;{\bf if} \; a \in B
\end{array}
\]</code></pre>
</blockquote>
<ol start="42" type="1">
<li><p>Consider the following class definitions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> AbsIterator <span class="kw">extends</span> AnyRef { ... }
<span class="kw">trait</span> RichIterator <span class="kw">extends</span> AbsIterator { ... }
<span class="kw">class</span> StringIterator <span class="kw">extends</span> AbsIterator { ... }
<span class="kw">class</span> Iter <span class="kw">extends</span> StringIterator <span class="kw">with</span> RichIterator { ... }</code></pre>
<p>Then the linearization of class <code>Iter</code> is</p>
<pre><code>{ Iter, RichIterator, StringIterator, AbsIterator, ScalaObject, AnyRef, Any }</code></pre>
<p>Trait <code>ScalaObject</code> appears in this list because it is added as last mixin to every Scala class ( <a href="#templates">see here</a> ).</p>
<p>Note that the linearization of a class refines the inheritance relation: if \(C\) is a subclass of \(D\), then \(C\) precedes \(D\) in any linearization where both \(C\) and \(D\) occur.  also satisfies the property that a linearization of a class always contains the linearization of its direct superclass as a suffix. For instance, the linearization of <code>StringIterator</code> is</p>
<pre><code>{ StringIterator, AbsIterator, ScalaObject, AnyRef, Any }</code></pre>
<p>which is a suffix of the linearization of its subclass <code>Iter</code>. The same is not true for the linearization of mixins. For instance, the linearization of <code>RichIterator</code> is</p>
<pre><code>{ RichIterator, AbsIterator, ScalaObject, AnyRef, Any }</code></pre>
<p>which is not a suffix of the linearization of <code>Iter</code>.</p></li>
</ol>
<h3 id="class-members"><a href="#TOC"><span class="header-section-number">5.1.3</span> Class Members</a></h3>
<p>A class \(C\) defined by a template <code>$C_1$ with $\ldots$ with $C_n$ { $\mathit{stats}$ }</code> can define members in its statement sequence \(\mathit{stats}\) and can inherit members from all parent classes. Scala adopts Java and C#'s conventions for static overloading of methods. It is thus possible that a class defines and/or inherits several methods with the same name. To decide whether a defined member of a class \(C\) overrides a member of a parent class, or whether the two co-exist as overloaded variants in \(C\), Scala uses the following definition of <em>matching</em> on members:</p>
<blockquote>
<p><strong>Definition</strong> <br>A member definition \(M\) <em>matches</em> a member definition \(M&#39;\), if \(M\) and \(M&#39;\) bind the same name, and one of following holds.</p>
<ol>
<li>Neither \(M\) nor \(M&#39;\) is a method definition.</li>
<li>\(M\) and \(M&#39;\) define both monomorphic methods with equivalent argument types.</li>
<li>\(M\) defines a parameterless method and \(M&#39;\) defines a method with an empty parameter list <code>()</code> or <em>vice versa</em>.</li>
<li>\(M\) and \(M&#39;\) define both polymorphic methods with equal number of argument types \(\overline T\), \(\overline T&#39;\) and equal numbers of type parameters \(\overline t\), \(\overline t&#39;\), say, and \(\overline T&#39; = [\overline t&#39;/\overline t]\overline T\). by the corresponding type parameter \(t\) of \(M\).</li>
</ol>
</blockquote>
<p>Member definitions fall into two categories: concrete and abstract. Members of class \(C\) are either <em>directly defined</em> (i.e.Â they appear in \(C\)'s statement sequence \(\mathit{stats}\)) or they are <em>inherited</em>. There are two rules that determine the set of members of a class, one for each category:</p>
<blockquote>
<p>A <em>concrete member</em> of a class \(C\) is any concrete definition \(M\) in some class \(C_i \in \mathcal{L}(C)\), except if there is a preceding class \(C_j \in \mathcal{L}(C)\) where \(j &lt; i\) which directly defines a concrete member \(M&#39;\) matching \(M\).</p>
<p>An <em>abstract member</em> of a class \(C\) is any abstract definition \(M\) in some class \(C_i \in \mathcal{L}(C)\), except if \(C\) contains already a concrete member \(M&#39;\) matching \(M\), or if there is a preceding class \(C_j \in \mathcal{L}(C)\) where \(j &lt; i\) which directly defines an abstract member \(M&#39;\) matching \(M\).</p>
</blockquote>
<p>This definition also determines the <a href="#overriding">overriding</a> relationships between matching members of a class \(C\) and its parents.<br>First, a concrete definition always overrides an abstract definition. Second, for definitions \(M\) and \(M\)' which are both concrete or both abstract, \(M\) overrides \(M&#39;\) if \(M\) appears in a class that precedes (in the linearization of \(C\)) the class in which \(M&#39;\) is defined.</p>
<p>It is an error if a template directly defines two matching members. It is also an error if a template contains two members (directly defined or inherited) with the same name and the same <a href="#type-erasure">erased type</a>. Finally, a template is not allowed to contain two methods (directly defined or inherited) with the same name which both define default arguments.</p>
<ol start="43" type="1">
<li><p>Consider the trait definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> A { <span class="kw">def</span> f: Int }
<span class="kw">trait</span> B <span class="kw">extends</span> A { <span class="kw">def</span> f: Int = <span class="dv">1</span> ; <span class="kw">def</span> g: Int = <span class="dv">2</span> ; <span class="kw">def</span> h: Int = <span class="dv">3</span> }
<span class="kw">trait</span> C <span class="kw">extends</span> A { <span class="kw">override</span> <span class="kw">def</span> f: Int = <span class="dv">4</span> ; <span class="kw">def</span> g: Int }
<span class="kw">trait</span> D <span class="kw">extends</span> B <span class="kw">with</span> C { <span class="kw">def</span> h: Int }</code></pre>
<p>Then trait <code>D</code> has a directly defined abstract member <code>h</code>. It inherits member <code>f</code> from trait <code>C</code> and member <code>g</code> from trait <code>B</code>.</p></li>
</ol>
<h3 id="overriding"><a href="#TOC"><span class="header-section-number">5.1.4</span> Overriding</a></h3>
<!-- TODO: Explain that classes cannot override each other -->

<p>A member \(M\) of class \(C\) that <a href="#class-members">matches</a> a non-private member \(M&#39;\) of a base class of \(C\) is said to <em>override</em> that member. In this case the binding of the overriding member \(M\) must <a href="#conformance">subsume</a> the binding of the overridden member \(M&#39;\). Furthermore, the following restrictions on modifiers apply to \(M\) and \(M&#39;\):</p>
<ul>
<li>\(M&#39;\) must not be labeled <code>final</code>.</li>
<li>\(M\) must not be <a href="#modifiers"><code>private</code></a>.</li>
<li>If \(M\) is labeled <code>private[$C$]</code> for some enclosing class or package \(C\), then \(M&#39;\) must be labeled <code>private[$C'$]</code> for some class or package \(C&#39;\) where \(C&#39;\) equals \(C\) or \(C&#39;\) is contained in \(C\). <!-- TODO: check whether this is accurate --></li>
<li>If \(M\) is labeled <code>protected</code>, then \(M&#39;\) must also be labeled <code>protected</code>.</li>
<li>If \(M&#39;\) is not an abstract member, then \(M\) must be labeled <code>override</code>. Furthermore, one of two possibilities must hold:
<ul>
<li>either \(M\) is defined in a subclass of the class where is \(M&#39;\) is defined,</li>
<li>or both \(M\) and \(M&#39;\) override a third member \(M&#39;&#39;\) which is defined in a base class of both the classes containing \(M\) and \(M&#39;\)</li>
</ul></li>
<li>If \(M&#39;\) is <a href="#modifiers">incomplete</a> in \(C\) then \(M\) must be labeled <code>abstract override</code>.</li>
<li>If \(M\) and \(M&#39;\) are both concrete value definitions, then either none of them is marked <code>lazy</code> or both must be marked <code>lazy</code>.</li>
</ul>
<p>A special rule concerns parameterless methods. If a paramterless method defined as <code>def $f$: $T$ = ...</code> or <code>def $f$ = ...</code> overrides a method of type \(()T&#39;\) which has an empty parameter list, then \(f\) is also assumed to have an empty parameter list.</p>
<p>Another restriction applies to abstract type members: An abstract type member with a <a href="#volatile-types">volatile type</a> as its upper bound may not override an abstract type member which does not have a volatile upper bound.</p>
<p>An overriding method inherits all default arguments from the definition in the superclass. By specifying default arguments in the overriding method it is possible to add new defaults (if the corresponding parameter in the superclass does not have a default) or to override the defaults of the superclass (otherwise).</p>
<ol start="44" type="1">
<li><p>Consider the definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Root { <span class="kw">type</span> T &lt;: Root }
<span class="kw">trait</span> A <span class="kw">extends</span> Root { <span class="kw">type</span> T &lt;: A }
<span class="kw">trait</span> B <span class="kw">extends</span> Root { <span class="kw">type</span> T &lt;: B }
<span class="kw">trait</span> C <span class="kw">extends</span> A <span class="kw">with</span> B </code></pre>
<p>Then the class definition <code>C</code> is not well-formed because the binding of <code>T</code> in <code>C</code> is <code>type T &lt;: B</code>, which fails to subsume the binding <code>type T &lt;: A</code> of <code>T</code> in type <code>A</code>. The problem can be solved by adding an overriding definition of type <code>T</code> in class <code>C</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> C <span class="kw">extends</span> A <span class="kw">with</span> B { <span class="kw">type</span> T &lt;: C }</code></pre></li>
</ol>
<h3 id="inheritance-closure"><a href="#TOC"><span class="header-section-number">5.1.5</span> Inheritance Closure</a></h3>
<p>Let \(C\) be a class type. The <em>inheritance closure</em> of \(C\) is the smallest set \(\mathscr{S}\) of types such that</p>
<ul>
<li>If \(T\) is in \(\mathscr{S}\), then every type \(T&#39;\) which forms syntactically a part of \(T\) is also in \(\mathscr{S}\).</li>
<li>If \(T\) is a class type in \(\mathscr{S}\), then all <a href="#templates">parents</a> of \(T\) are also in \(\mathscr{S}\).</li>
</ul>
<p>It is a static error if the inheritance closure of a class type consists of an infinite number of types. (This restriction is necessary to make subtyping decidable <span class="citation">(Kennedy and Pierce 2007)</span>).</p>
<h3 id="early-definitions"><a href="#TOC"><span class="header-section-number">5.1.6</span> Early Definitions</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">EarlyDefs         ::= `{&#39; [EarlyDef {semi EarlyDef}] `}&#39; `with&#39;
EarlyDef          ::=  {Annotation} {Modifier} PatVarDef</code></pre>
<p>A template may start with an <em>early field definition</em> clause, which serves to define certain field values before the supertype constructor is called. In a template</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> $p_1$: $T_1$ = $e_1$
  ...
  <span class="kw">val</span> $p_n$: $T_n$ = $e_n$
} <span class="kw">with</span> $sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $mt_n$ { $\mathit{stats}$ }</code></pre>
<p>The initial pattern definitions of \(p_1 , \ldots , p_n\) are called <em>early definitions</em>. They define fields which form part of the template. Every early definition must define at least one variable.</p>
<p>An early definition is type-checked and evaluated in the scope which is in effect just before the template being defined, augmented by any type parameters of the enclosing class and by any early definitions preceding the one being defined. In particular, any reference to <code>this</code> in the right-hand side of an early definition refers to the identity of <code>this</code> just outside the template. Consequently, it is impossible that an early definition refers to the object being constructed by the template, or refers to one of its fields and methods, except for any other preceding early definition in the same section. Furthermore, references to preceding early definitions always refer to the value that's defined there, and do not take into account overriding definitions. In other words, a block of early definitions is evaluated exactly as if it was a local bock containing a number of value definitions.</p>
<p>Early definitions are evaluated in the order they are being defined before the superclass constructor of the template is called.</p>
<ol start="45" type="1">
<li><p>Early definitions are particularly useful for traits, which do not have normal constructor parameters. Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Greeting {
  <span class="kw">val</span> name: String
  <span class="kw">val</span> msg = <span class="st">&quot;How are you, &quot;</span>+name
}
<span class="kw">class</span> C <span class="kw">extends</span> {
  <span class="kw">val</span> name = <span class="st">&quot;Bob&quot;</span>
} <span class="kw">with</span> Greeting {
  <span class="fu">println</span>(msg)
}</code></pre>
<p>In the code above, the field <code>name</code> is initialized before the constructor of <code>Greeting</code> is called. Therefore, field <code>msg</code> in class <code>Greeting</code> is properly initialized to <code>&quot;How are you, Bob&quot;</code>.</p>
<p>If <code>name</code> had been initialized instead in <code>C</code>'s normal class body, it would be initialized after the constructor of <code>Greeting</code>. In that case, <code>msg</code> would be initialized to <code>&quot;How are you, &lt;null&gt;&quot;</code>.</p></li>
</ol>
<h2 id="modifiers"><a href="#TOC"><span class="header-section-number">5.2</span> Modifiers</a></h2>
<pre class="grammar"><code>Modifier          ::=  LocalModifier 
                    |  AccessModifier
                    |  `override&#39;
LocalModifier     ::=  `abstract&#39;
                    |  `final&#39;
                    |  `sealed&#39;
                    |  `implicit&#39;
                    |  `lazy&#39;
AccessModifier    ::=  (`private&#39; | `protected&#39;) [AccessQualifier]
AccessQualifier   ::=  `[&#39; (id | `this&#39;) `]&#39;</code></pre>
<p>Member definitions may be preceded by modifiers which affect the accessibility and usage of the identifiers bound by them. If several modifiers are given, their order does not matter, but the same modifier may not occur more than once. Modifiers preceding a repeated definition apply to all constituent definitions. The rules governing the validity and meaning of a modifier are as follows.</p>
<ul>
<li>The <code>private</code> modifier can be used with any definition or declaration in a template. Such members can be accessed only from within the directly enclosing template and its companion module or <a href="#object-definitions">companion class</a>. They are not inherited by subclasses and they may not override definitions in parent classes.</li>
</ul>
<p>The modifier can be <em>qualified</em> with an identifier \(C\) (e.g. <code>private[$C$]</code>) that must denote a class or package enclosing the definition. Members labeled with such a modifier are accessible respectively only from code inside the package \(C\) or only from code inside the class \(C\) and its <a href="#object-definitions">companion module</a>. Such members are also inherited only from templates inside \(C\).</p>
<p>An different form of qualification is <code>private[this]</code>. A member \(M\) marked with this modifier can be accessed only from within the object in which it is defined. That is, a selection \(p.M\) is only legal if the prefix is <code>this</code> or <code>$O$.this</code>, for some class \(O\) enclosing the reference. In addition, the restrictions for unqualified <code>private</code> apply.</p>
<p>Members marked private without a qualifier are called <em>class-private</em>, whereas members labeled with <code>private[this]</code> are called <em>object-private</em>. A member <em>is private</em> if it is either class-private or object-private, but not if it is marked <code>private[$C$]</code> where \(C\) is an identifier; in the latter case the member is called <em>qualified private</em>.</p>
<p>Class-private or object-private members may not be abstract, and may not have <code>protected</code> or <code>override</code> modifiers.</p>
<ul>
<li>The <code>protected</code> modifier applies to class member definitions. Protected members of a class can be accessed from within
<ul>
<li>the template of the defining class,</li>
<li>all templates that have the defining class as a base class,</li>
<li>the companion module of any of those classes. A <code>protected</code> modifier can be qualified with an identifier \(C\) (e.g. <code>protected[$C$]</code>) that must denote a class or package enclosing the definition. Members labeled with such a modifier are also accessible respectively from all code inside the package \(C\) or from all code inside the class \(C\) and its <a href="#object-definitions">companion module</a>.</li>
</ul></li>
</ul>
<p>A protected identifier \(x\) may be used as a member name in a selection <code>$r$.$x$</code> only if one of the following applies: - The access is within the template defining the member, or, if a qualification \(C\) is given, inside the package \(C\), or the class \(C\), or its companion module, or - \(r\) is one of the reserved words <code>this</code> and <code>super</code>, or - \(r\)'s type conforms to a type-instance of the class which contains the access.</p>
<p>A different form of qualification is <code>protected[this]</code>. A member \(M\) marked with this modifier can be accessed only from within the object in which it is defined. That is, a selection \(p.M\) is only legal if the prefix is <code>this</code> or <code>$O$.this</code>, for some class \(O\) enclosing the reference. In addition, the restrictions for unqualified <code>protected</code> apply.</p>
<ul>
<li><p>The <code>override</code> modifier applies to class member definitions or declarations. It is mandatory for member definitions or declarations that override some other concrete member definition in a parent class. If an <code>override</code> modifier is given, there must be at least one overridden member definition or declaration (either concrete or abstract).</p></li>
<li><p>The <code>override</code> modifier has an additional significance when combined with the <code>abstract</code> modifier. That modifier combination is only allowed for value members of traits.</p></li>
</ul>
<p>We call a member \(M\) of a template <em>incomplete</em> if it is either abstract (i.e.Â defined by a declaration), or it is labeled <code>abstract</code> and <code>override</code> and every member overridden by \(M\) is again incomplete.</p>
<p>Note that the <code>abstract override</code> modifier combination does not influence the concept whether a member is concrete or abstract. A member is <em>abstract</em> if only a declaration is given for it; it is <em>concrete</em> if a full definition is given.</p>
<ul>
<li>The <code>abstract</code> modifier is used in class definitions. It is redundant for traits, and mandatory for all other classes which have incomplete members. Abstract classes cannot be <a href="#instance-creation-expressions">instantiated</a> with a constructor invocation unless followed by mixins and/or a refinement which override all incomplete members of the class. Only abstract classes and traits can have abstract term members.</li>
</ul>
<p>The <code>abstract</code> modifier can also be used in conjunction with <code>override</code> for class member definitions. In that case the previous discussion applies.</p>
<ul>
<li><p>The <code>final</code> modifier applies to class member definitions and to class definitions. A <code>final</code> class member definition may not be overridden in subclasses. A <code>final</code> class may not be inherited by a template. <code>final</code> is redundant for object definitions. Members of final classes or objects are implicitly also final, so the <code>final</code> modifier is generally redundant for them, too. Note, however, that <a href="#value-declarations-and-definitions">constant value definitions</a> do require an explicit <code>final</code> modifier, even if they are defined in a final class or object. <code>final</code> may not be applied to incomplete members, and it may not be combined in one modifier list with <code>sealed</code>.</p></li>
<li><p>The <code>sealed</code> modifier applies to class definitions. A <code>sealed</code> class may not be directly inherited, except if the inheriting template is defined in the same source file as the inherited class. However, subclasses of a sealed class can be inherited anywhere.</p></li>
<li><p>The <code>lazy</code> modifier applies to value definitions. A <code>lazy</code> value is initialized the first time it is accessed (which might never happen at all). Attempting to access a lazy value during its initialization might lead to looping behavior. If an exception is thrown during initialization, the value is considered uninitialized, and a later access will retry to evaluate its right hand side.</p></li>
</ul>
<ol start="46" type="1">
<li><p>The following code illustrates the use of qualified private:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> outerpkg.<span class="fu">innerpkg</span>
<span class="kw">class</span> Outer {
  <span class="kw">class</span> Inner {
    <span class="kw">private</span>[Outer] <span class="kw">def</span> <span class="fu">f</span>()
    <span class="kw">private</span>[innerpkg] <span class="kw">def</span> <span class="fu">g</span>()
    <span class="kw">private</span>[outerpkg] <span class="kw">def</span> <span class="fu">h</span>()
  }
}</code></pre>
<p>Here, accesses to the method <code>f</code> can appear anywhere within <code>OuterClass</code>, but not outside it. Accesses to method <code>g</code> can appear anywhere within the package <code>outerpkg.innerpkg</code>, as would be the case for package-private methods in Java. Finally, accesses to method <code>h</code> can appear anywhere within package <code>outerpkg</code>, including packages contained in it.</p></li>
<li><p>A useful idiom to prevent clients of a class from constructing new instances of that class is to declare the class <code>abstract</code> and <code>sealed</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> m {
  <span class="kw">abstract</span> <span class="kw">sealed</span> <span class="kw">class</span> <span class="fu">C</span> (x: Int) {
    <span class="kw">def</span> nextC = <span class="kw">new</span> <span class="fu">C</span>(x + <span class="dv">1</span>) {}
  }
  <span class="kw">val</span> empty = <span class="kw">new</span> <span class="fu">C</span>(<span class="dv">0</span>) {}
}</code></pre>
<p>For instance, in the code above clients can create instances of class <code>m.C</code> only by calling the <code>nextC</code> method of an existing <code>m.C</code> object; it is not possible for clients to create objects of class <code>m.C</code> directly. Indeed the following two lines are both in error:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> m.<span class="fu">C</span>(<span class="dv">0</span>)    <span class="co">// **** error: C is abstract, so it cannot be instantiated.</span>
<span class="kw">new</span> m.<span class="fu">C</span>(<span class="dv">0</span>) {} <span class="co">// **** error: illegal inheritance from sealed class.</span></code></pre>
<p>A similar access restriction can be achieved by marking the primary constructor <code>private</code> (see ).</p></li>
</ol>
<h2 id="class-definitions"><a href="#TOC"><span class="header-section-number">5.3</span> Class Definitions</a></h2>
<pre class="grammar"><code>TmplDef           ::=  `class&#39; ClassDef 
ClassDef          ::=  id [TypeParamClause] {Annotation} 
                       [AccessModifier] ClassParamClauses ClassTemplateOpt 
ClassParamClauses ::=  {ClassParamClause} 
                       [[nl] `(&#39; implicit ClassParams `)&#39;]
ClassParamClause  ::=  [nl] `(&#39; [ClassParams] &#39;)&#39;
ClassParams       ::=  ClassParam {`,&#39; ClassParam}
ClassParam        ::=  {Annotation} [{Modifier} (`val&#39; | `var&#39;)] 
                       id [`:&#39; ParamType] [`=&#39; Expr]
ClassTemplateOpt  ::=  `extends&#39; ClassTemplate | [[`extends&#39;] TemplateBody]</code></pre>
<p>The most general form of class definition is</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> $c$[$\mathit{tps}\,$] $as$ $m$($\mathit{ps}_1$)$\ldots$($\mathit{ps}_n$) <span class="kw">extends</span> $t$    $\<span class="fu">gap</span>(n \geq <span class="dv">0</span>)$.</code></pre>
<p>Here,</p>
<ul>
<li>\(c\) is the name of the class to be defined.</li>
<li>\(\mathit{tps}\) is a non-empty list of type parameters of the class being defined. The scope of a type parameter is the whole class definition including the type parameter section itself. It is illegal to define two type parameters with the same name. The type parameter section <code>[$\mathit{tps}\,$]</code> may be omitted. A class with a type parameter section is called <em>polymorphic</em>, otherwise it is called <em>monomorphic</em>.</li>
<li>\(as\) is a possibly empty sequence of <a href="#user-defined-annotations">annotations</a>. If any annotations are given, they apply to the primary constructor of the class.</li>
<li>\(m\) is an <a href="#modifiers">access modifier</a> such as <code>private</code> or <code>protected</code>, possibly with a qualification. If such an access modifier is given it applies to the primary constructor to the class.</li>
<li><p>\((\mathit{ps}_1)\ldots(\mathit{ps}_n)\) are formal value parameter clauses for the {} of the class. The scope of a formal value parameter includes all subsequent parameter sections and the template \(t\). However, a formal value parameter may not form part of the types of any of the parent classes or members of the class template \(t\). It is illegal to define two formal value parameters with the same name. If no formal parameter sections are given, an empty parameter section <code>()</code> is assumed.</p>
If a formal parameter declaration \(x: T\) is preceded by a <code>val</code> or <code>var</code> keyword, an accessor (getter) <a href="#variable-declarations-and-definitions">definition</a> for this parameter is implicitly added to the class. The getter introduces a value member \(x\) of class \(c\) that is defined as an alias of the parameter. If the introducing keyword is <code>var</code>, a setter accessor <a href="#variable-declarations-and-definitions"><code>$x$_=</code></a> is also implicitly added to the class. In invocation of that setter <code>$x$_=($e$)</code> changes the value of the parameter to the result of evaluating \(e\). The formal parameter declaration may contain modifiers, which then carry over to the accessor definition(s). A formal parameter prefixed by <code>val</code> or <code>var</code> may not at the same time be a <a href="#by-name-parameters">call-by-name parameter</a>.</li>
<li><p>\(t\) is a <a href="#templates">template</a> of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_m$ { $\mathit{stats}$ } <span class="co">// $m \geq 0$</span></code></pre>
<p>which defines the base classes, behavior and initial state of objects of the class. The extends clause <code>extends $sc$ with $mt_1$ with $\ldots$ with $mt_m$</code> can be omitted, in which case <code>extends scala.AnyRef</code> is assumed. The class body <code>{ $\mathit{stats}$ }</code> may also be omitted, in which case the empty body <code>{}</code> is assumed.</p></li>
</ul>
<p>This class definition defines a type <code>$c$[$\mathit{tps}\,$]</code> and a constructor which when applied to parameters conforming to types \(\mathit{ps}\) initializes instances of type <code>$c$[$\mathit{tps}\,$]</code> by evaluating the template \(t\).</p>
<ol start="48" type="1">
<li><p>The following example illustrates <code>val</code> and <code>var</code> parameters of a class <code>C</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">C</span>(x: Int, <span class="kw">val</span> y: String, <span class="kw">var</span> z: List[String])
<span class="kw">val</span> c = <span class="kw">new</span> <span class="fu">C</span>(<span class="dv">1</span>, <span class="st">&quot;abc&quot;</span>, List())
c.<span class="fu">z</span> = c.<span class="fu">y</span> :: c.<span class="fu">z</span></code></pre></li>
<li><p>The following class can be created only from its companion module.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Sensitive {
  <span class="kw">def</span> <span class="fu">makeSensitive</span>(credentials: Certificate): Sensitive = 
    <span class="kw">if</span> (credentials == Admin) <span class="kw">new</span> <span class="fu">Sensitive</span>() 
    <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> SecurityViolationException
}
<span class="kw">class</span> Sensitive <span class="kw">private</span> () {
  ...
}</code></pre></li>
</ol>
<h3 id="constructor-definitions"><a href="#TOC"><span class="header-section-number">5.3.1</span> Constructor Definitions</a></h3>
<pre class="grammar"><code>FunDef         ::= `this&#39; ParamClause ParamClauses 
                   (`=&#39; ConstrExpr | [nl] ConstrBlock)
ConstrExpr     ::= SelfInvocation
                |  ConstrBlock
ConstrBlock    ::= `{&#39; SelfInvocation {semi BlockStat} `}&#39;
SelfInvocation ::= `this&#39; ArgumentExprs {ArgumentExprs}</code></pre>
<p>A class may have additional constructors besides the primary constructor. These are defined by constructor definitions of the form <code>def this($\mathit{ps}_1$)$\ldots$($\mathit{ps}_n$) = $e$</code>. Such a definition introduces an additional constructor for the enclosing class, with parameters as given in the formal parameter lists \(\mathit{ps}_1 , \ldots , \mathit{ps}_n\), and whose evaluation is defined by the constructor expression \(e\). The scope of each formal parameter is the subsequent parameter sections and the constructor expression \(e\). A constructor expression is either a self constructor invocation <code>this($\mathit{args}_1$)$\ldots$($\mathit{args}_n$)</code> or a block which begins with a self constructor invocation. The self constructor invocation must construct a generic instance of the class. I.e.Â if the class in question has name \(C\) and type parameters <code>[$\mathit{tps}\,$]</code>, then a self constructor invocation must generate an instance of <code>$C$[$\mathit{tps}\,$]</code>; it is not permitted to instantiate formal type parameters.</p>
<p>The signature and the self constructor invocation of a constructor definition are type-checked and evaluated in the scope which is in effect at the point of the enclosing class definition, augmented by any type parameters of the enclosing class and by any <a href="#early-definitions">early definitions</a> of the enclosing template. The rest of the constructor expression is type-checked and evaluated as a function body in the current class.</p>
<p>If there are auxiliary constructors of a class \(C\), they form together with \(C\)'s primary <a href="#class-definitions">constructor</a> an overloaded constructor definition. The usual rules for <a href="#overloading-resolution">overloading resolution</a> apply for constructor invocations of \(C\), including for the self constructor invocations in the constructor expressions themselves. However, unlike other methods, constructors are never inherited. To prevent infinite cycles of constructor invocations, there is the restriction that every self constructor invocation must refer to a constructor definition which precedes it (i.e.Â it must refer to either a preceding auxiliary constructor or the primary constructor of the class).</p>
<ol start="50" type="1">
<li><p>Consider the class definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> LinkedList[A]() {
  <span class="kw">var</span> head = _ 
  <span class="kw">var</span> tail = <span class="kw">null</span> 
  <span class="kw">def</span> isEmpty = tail != <span class="kw">null</span>   
  <span class="kw">def</span> <span class="kw">this</span>(head: A) = { <span class="kw">this</span>(); <span class="kw">this</span>.<span class="fu">head</span> = head }
  <span class="kw">def</span> <span class="kw">this</span>(head: A, tail: List[A]) = { <span class="kw">this</span>(head); <span class="kw">this</span>.<span class="fu">tail</span> = tail }
}</code></pre>
<p>This defines a class <code>LinkedList</code> with three constructors. The second constructor constructs an singleton list, while the third one constructs a list with a given head and tail.</p></li>
</ol>
<h2 id="case-classes"><a href="#TOC"><span class="header-section-number">5.4</span> Case Classes</a></h2>
<pre class="grammar"><code>TmplDef  ::=  `case&#39; `class&#39; ClassDef</code></pre>
<p>If a class definition is prefixed with <code>case</code>, the class is said to be a <em>case class</em>.</p>
<p>The formal parameters in the first parameter section of a case class are called <em>elements</em>; they are treated specially. First, the value of such a parameter can be extracted as a field of a constructor pattern. Second, a <code>val</code> prefix is implicitly added to such a parameter, unless the parameter carries already a <code>val</code> or <code>var</code> modifier. Hence, an accessor definition for the parameter is <a href="#class-definitions">generated</a>.</p>
<p>A case class definition of <code>$c$[$\mathit{tps}\,$]($\mathit{ps}_1\,$)$\ldots$($\mathit{ps}_n$)</code> with type parameters \(\mathit{tps}\) and value parameters \(\mathit{ps}\) implicitly generates an <a href="#extractor-patterns">extractor object</a> which is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> $c$ {
  <span class="kw">def</span> apply[$\mathit{tps}\,$]($\mathit{ps}_1\,$)$\ldots$($\mathit{ps}_n$): $c$[$\mathit{tps}\,$] = <span class="kw">new</span> $c$[$\mathit{Ts}\,$]($\mathit{xs}_1\,$)$\ldots$($\mathit{xs}_n$)
  <span class="kw">def</span> unapply[$\mathit{tps}\,$]($x$: $c$[$\mathit{tps}\,$]) =
    <span class="kw">if</span> (x eq <span class="kw">null</span>) scala.<span class="fu">None</span>
    <span class="kw">else</span> scala.<span class="fu">Some</span>($x.\<span class="fu">mathit</span>{xs}_{<span class="dv">11</span>}, \ldots , x.\<span class="fu">mathit</span>{xs}_{1k}$)
}</code></pre>
<p>Here, \(\mathit{Ts}\) stands for the vector of types defined in the type parameter section \(\mathit{tps}\), each \(\mathit{xs}_i\) denotes the parameter names of the parameter section \(\mathit{ps}_i\), and \(\mathit{xs}_{11}, \ldots , \mathit{xs}_{1k}\) denote the names of all parameters in the first parameter section \(\mathit{xs}_1\). If a type parameter section is missing in the class, it is also missing in the <code>apply</code> and <code>unapply</code> methods. The definition of <code>apply</code> is omitted if class \(c\) is <code>abstract</code>.</p>
<p>If the case class definition contains an empty value parameter list, the <code>unapply</code> method returns a <code>Boolean</code> instead of an <code>Option</code> type and is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> unapply[$\mathit{tps}\,$]($x$: $c$[$\mathit{tps}\,$]) = x ne <span class="kw">null</span></code></pre>
<p>The name of the <code>unapply</code> method is changed to <code>unapplySeq</code> if the first parameter section \(\mathit{ps}_1\) of \(c\) ends in a <a href="#repeated-parameters">repeated parameter</a>. If a companion object \(c\) exists already, no new object is created, but the <code>apply</code> and <code>unapply</code> methods are added to the existing object instead.</p>
<p>A method named <code>copy</code> is implicitly added to every case class unless the class already has a member (directly defined or inherited) with that name. The method is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> copy[$\mathit{tps}\,$]($\mathit{ps}&#39;_1\,$)$\ldots$($\mathit{ps}&#39;_n$): $c$[$\mathit{tps}\,$] = <span class="kw">new</span> $c$[$\mathit{Ts}\,$]($\mathit{xs}_1\,$)$\ldots$($\mathit{xs}_n$)</code></pre>
<p>Again, \(\Ts\) stands for the vector of types defined in the type parameter section \(\mathit{tps}\) and each \(\mathit{xs}_i\) denotes the parameter names of the parameter section \(\mathit{ps}&#39;_i\). Every value parameter \(\mathit{ps}&#39;_{i,j}\) of the <code>copy</code> method has the form <code>$x_{i,j}$:$T_{i,j}$=this.$x_{i,j}$</code>, where \(x_{i,j}\) and \(T_{i,j}\) refer to the name and type of the corresponding class parameter \(\mathit{ps}_{i,j}\).</p>
<p>Every case class implicitly overrides some method definitions of class <a href="#root-classes"><code>scala.AnyRef</code></a> unless a definition of the same method is already given in the case class itself or a concrete definition of the same method is given in some base class of the case class different from <code>AnyRef</code>. In particular:</p>
<ul>
<li>Method <code>equals: (Any)Boolean</code> is structural equality, where two instances are equal if they both belong to the case class in question and they have equal (with respect to <code>equals</code>) constructor arguments.</li>
<li>Method <code>hashCode: Int</code> computes a hash-code. If the hashCode methods of the data structure members map equal (with respect to equals) values to equal hash-codes, then the case class hashCode method does too.</li>
<li>Method <code>toString: String</code> returns a string representation which contains the name of the class and its elements.</li>
</ul>
<ol start="51" type="1">
<li><p>Here is the definition of abstract syntax for lambda calculus:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Expr 
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Var</span>   (x: String)          <span class="kw">extends</span> Expr
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Apply</span> (f: Expr, e: Expr)   <span class="kw">extends</span> Expr
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Lambda</span>(x: String, e: Expr) <span class="kw">extends</span> Expr </code></pre>
<p>This defines a class <code>Expr</code> with case classes <code>Var</code>, <code>Apply</code> and <code>Lambda</code>. A call-by-value evaluator for lambda expressions could then be written as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Env = String =&gt; Value 
<span class="kw">case</span> <span class="kw">class</span> Value(e: Expr, env: Env) 

<span class="kw">def</span> <span class="fu">eval</span>(e: Expr, env: Env): Value = e <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Var</span> (x) =&gt;
    <span class="fu">env</span>(x)
  <span class="kw">case</span> <span class="fu">Apply</span>(f, g) =&gt;
    <span class="kw">val</span> Value(<span class="fu">Lambda</span> (x, e1), env1) = <span class="fu">eval</span>(f, env) 
    <span class="kw">val</span> v = <span class="fu">eval</span>(g, env) 
    <span class="fu">eval</span> (e1, (y =&gt; <span class="kw">if</span> (y == x) v <span class="kw">else</span> <span class="fu">env1</span>(y)))
  <span class="kw">case</span> <span class="fu">Lambda</span>(_, _) =&gt;
    Value(e, env)
}</code></pre>
<p>It is possible to define further case classes that extend type <code>Expr</code> in other parts of the program, for instance</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Number(x: Int) <span class="kw">extends</span> Expr </code></pre>
<p>This form of extensibility can be excluded by declaring the base class <code>Expr</code> <code>sealed</code>; in this case, all classes that directly extend <code>Expr</code> must be in the same source file as <code>Expr</code>.</p></li>
</ol>
<h3 id="traits"><a href="#TOC"><span class="header-section-number">5.4.1</span> Traits</a></h3>
<pre class="grammar"><code>TmplDef          ::=  `trait&#39; TraitDef
TraitDef         ::=  id [TypeParamClause] TraitTemplateOpt
TraitTemplateOpt ::=  `extends&#39; TraitTemplate | [[`extends&#39;] TemplateBody]</code></pre>
<p>A trait is a class that is meant to be added to some other class as a mixin. Unlike normal classes, traits cannot have constructor parameters. Furthermore, no constructor arguments are passed to the superclass of the trait. This is not necessary as traits are initialized after the superclass is initialized.</p>
<p>Assume a trait \(D\) defines some aspect of an instance \(x\) of type \(C\) (i.e.Â \(D\) is a base class of \(C\)). Then the {} of \(D\) in \(x\) is the compound type consisting of all the base classes in \(\mathcal{L}(C)\) that succeed \(D\). The actual supertype gives the context for resolving a <a href="#this-and-super"><code>super</code> reference</a> in a trait. Note that the actual supertype depends on the type to which the trait is added in a mixin composition; it is not statically known at the time the trait is defined.</p>
<p>If \(D\) is not a trait, then its actual supertype is simply its least proper supertype (which is statically known).</p>
<ol start="52" type="1">
<li><p>The following trait defines the property of being comparable to objects of some type. It contains an abstract method <code>&lt;</code> and default implementations of the other comparison operators <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Comparable[T &lt;: Comparable[T]] { self: T =&gt;
  <span class="kw">def</span> &lt; (that: T): Boolean
  <span class="kw">def</span> &lt;=(that: T): Boolean = <span class="kw">this</span> &lt; that || <span class="kw">this</span> == that
  <span class="kw">def</span> &gt; (that: T): Boolean = that &lt; <span class="kw">this</span> 
  <span class="kw">def</span> &gt;=(that: T): Boolean = that &lt;= <span class="kw">this</span>
}</code></pre></li>
<li><p>Consider an abstract class <code>Table</code> that implements maps from a type of keys <code>A</code> to a type of values <code>B</code>. The class has a method <code>set</code> to enter a new key / value pair into the table, and a method <code>get</code> that returns an optional value matching a given key. Finally, there is a method <code>apply</code> which is like <code>get</code>, except that it returns a given default value if the table is undefined for the given key. This class is implemented as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Table[A, B](defaultValue: B) {
  <span class="kw">def</span> <span class="fu">get</span>(key: A): Option[B]
  <span class="kw">def</span> <span class="fu">set</span>(key: A, value: B)
  <span class="kw">def</span> <span class="fu">apply</span>(key: A) = <span class="fu">get</span>(key) <span class="kw">match</span> {
    <span class="kw">case</span> Some(value) =&gt; value
    <span class="kw">case</span> None =&gt; defaultValue
  }
}</code></pre>
<p>Here is a concrete implementation of the <code>Table</code> class.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> ListTable[A, B](defaultValue: B) <span class="kw">extends</span> Table[A, B](defaultValue) {
  <span class="kw">private</span> <span class="kw">var</span> elems: List[(A, B)]
  <span class="kw">def</span> <span class="fu">get</span>(key: A) = elems.<span class="fu">find</span>(.<span class="fu">_1</span>.==(key)).<span class="fu">map</span>(.<span class="fu">_2</span>)
  <span class="kw">def</span> <span class="fu">set</span>(key: A, value: B) = { elems = (key, value) :: elems }
}</code></pre>
<p>Here is a trait that prevents concurrent access to the <code>get</code> and <code>set</code> operations of its parent class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> SynchronizedTable[A, B] <span class="kw">extends</span> Table[A, B] {
  <span class="kw">abstract</span> <span class="kw">override</span> <span class="kw">def</span> <span class="fu">get</span>(key: A): B = 
    synchronized { <span class="kw">super</span>.<span class="fu">get</span>(key) }
  <span class="kw">abstract</span> <span class="kw">override</span> <span class="kw">def</span> <span class="fu">set</span>((key: A, value: B) = 
    synchronized { <span class="kw">super</span>.<span class="fu">set</span>(key, value) }
}</code></pre>
<p>Note that <code>SynchronizedTable</code> does not pass an argument to its superclass, <code>Table</code>, even though <code>Table</code> is defined with a formal parameter. Note also that the <code>super</code> calls in <code>SynchronizedTable</code>'s <code>get</code> and <code>set</code> methods statically refer to abstract methods in class <code>Table</code>. This is legal, as long as the calling method is labeled <a href="#modifiers"><code>abstract override</code></a>.</p>
<p>Finally, the following mixin composition creates a synchronized list table with strings as keys and integers as values and with a default value <code>0</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> MyTable <span class="kw">extends</span> ListTable[String, Int](<span class="dv">0</span>) <span class="kw">with</span> SynchronizedTable</code></pre>
<p>The object <code>MyTable</code> inherits its <code>get</code> and <code>set</code> method from <code>SynchronizedTable</code>. The <code>super</code> calls in these methods are re-bound to refer to the corresponding implementations in <code>ListTable</code>, which is the actual supertype of <code>SynchronizedTable</code> in <code>MyTable</code>.</p></li>
</ol>
<h2 id="object-definitions"><a href="#TOC"><span class="header-section-number">5.5</span> Object Definitions</a></h2>
<pre class="grammar"><code>ObjectDef       ::=  id ClassTemplate</code></pre>
<p>An object definition defines a single object of a new class. Its most general form is <code>object $m$ extends $t$</code>. Here, \(m\) is the name of the object to be defined, and \(t\) is a <a href="#templates">template</a> of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ { $\mathit{stats}$ }</code></pre>
<p>which defines the base classes, behavior and initial state of \(m\). The extends clause <code>extends $sc$ with $mt_1$ with $\ldots$ with $mt_n$</code> can be omitted, in which case <code>extends scala.AnyRef</code> is assumed. The class body <code>{ $\mathit{stats}$ }</code> may also be omitted, in which case the empty body <code>{}</code> is assumed.</p>
<p>The object definition defines a single object (or: <em>module</em>) conforming to the template \(t\). It is roughly equivalent to the following definition of a lazy value:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">lazy</span> <span class="kw">val</span> $m$ = <span class="kw">new</span> $sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ { <span class="kw">this</span>: $m.<span class="fu">type</span>$ =&gt; $\mathit{stats}$ }</code></pre>
<p>Note that the value defined by an object definition is instantiated lazily. The <code>new $m\Dollar$cls</code> constructor is evaluated not at the point of the object definition, but is instead evaluated the first time \(m\) is dereferenced during execution of the program (which might be never at all). An attempt to dereference \(m\) again in the course of evaluation of the constructor leads to a infinite loop or run-time error.<br>Other threads trying to dereference \(m\) while the constructor is being evaluated block until evaluation is complete.</p>
<p>The expansion given above is not accurate for top-level objects. It cannot be because variable and method definition cannot appear on the top-level outside of a <a href="#package-objects">package object</a>. Instead, top-level objects are translated to static fields.</p>
<ol start="54" type="1">
<li><p>Classes in Scala do not have static members; however, an equivalent effect can be achieved by an accompanying object definition E.g.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Point {
  <span class="kw">val</span> x: Double 
  <span class="kw">val</span> y: Double 
  <span class="kw">def</span> isOrigin = (x == <span class="fl">0.0</span> &amp;&amp; y == <span class="fl">0.0</span>) 
}
<span class="kw">object</span> Point {
  <span class="kw">val</span> origin = <span class="kw">new</span> Point() { <span class="kw">val</span> x = <span class="fl">0.0</span>; <span class="kw">val</span> y = <span class="fl">0.0</span> }
}</code></pre>
<p>This defines a class <code>Point</code> and an object <code>Point</code> which contains <code>origin</code> as a member. Note that the double use of the name <code>Point</code> is legal, since the class definition defines the name <code>Point</code> in the type name space, whereas the object definition defines a name in the term namespace.</p>
<p>This technique is applied by the Scala compiler when interpreting a Java class with static members. Such a class \(C\) is conceptually seen as a pair of a Scala class that contains all instance members of \(C\) and a Scala object that contains all static members of \(C\).</p>
<p>Generally, a <em>companion module</em> of a class is an object which has the same name as the class and is defined in the same scope and compilation unit. Conversely, the class is called the <em>companion class</em> of the module.</p></li>
</ol>
<h1 id="expressions"><a href="#TOC"><span class="header-section-number">6</span> Expressions</a></h1>
<pre class="grammar"><code>  Expr              ::=  (Bindings | id | `_&#39;) `=&gt;&#39; Expr
                      |  Expr1
  Expr1             ::=  `if&#39; `(&#39; Expr `)&#39; {nl} Expr [[semi] else Expr]
                      |  `while&#39; `(&#39; Expr `)&#39; {nl} Expr
                      |  `try&#39; `{&#39; Block `}&#39; [`catch&#39;  `{&#39; CaseClauses `}&#39;] 
                         [`finally&#39; Expr]
                      |  `do&#39; Expr [semi] `while&#39; `(&#39; Expr &#39;)&#39;
                      |  `for&#39; (`(&#39; Enumerators `)&#39; | `{&#39; Enumerators `}&#39;) 
                         {nl} [`yield&#39;] Expr
                      |  `throw&#39; Expr
                      |  `return&#39; [Expr]
                      |  [SimpleExpr `.&#39;] id `=&#39; Expr
                      |  SimpleExpr1 ArgumentExprs `=&#39; Expr
                      |  PostfixExpr
                      |  PostfixExpr Ascription
                      |  PostfixExpr `match&#39; `{&#39; CaseClauses `}&#39;
  PostfixExpr       ::=  InfixExpr [id [nl]]
  InfixExpr         ::=  PrefixExpr
                      |  InfixExpr id [nl] InfixExpr
  PrefixExpr        ::=  [`-&#39; | `+&#39; | `~&#39; | `!&#39;] SimpleExpr 
  SimpleExpr        ::=  `new&#39; (ClassTemplate | TemplateBody)
                      |  BlockExpr
                      |  SimpleExpr1 [`_&#39;]
  SimpleExpr1       ::=  Literal
                      |  Path
                      |  `_&#39;
                      |  `(&#39; [Exprs] `)&#39;
                      |  SimpleExpr `.&#39; id s
                      |  SimpleExpr TypeArgs
                      |  SimpleExpr1 ArgumentExprs
                      |  XmlExpr
  Exprs             ::=  Expr {`,&#39; Expr}
  BlockExpr         ::=  `{&#39; CaseClauses `}&#39;
                      |  `{&#39; Block `}&#39;
  Block             ::=  {BlockStat semi} [ResultExpr]
  ResultExpr        ::=  Expr1
                      |  (Bindings | ([`implicit&#39;] id | `_&#39;) `:&#39; CompoundType) `=&gt;&#39; Block
  Ascription        ::=  `:&#39; InfixType
                      |  `:&#39; Annotation {Annotation} 
                      |  `:&#39; `_&#39; `*&#39;</code></pre>
<p>Expressions are composed of operators and operands. Expression forms are discussed subsequently in decreasing order of precedence.</p>
<h2 id="expression-typing"><a href="#TOC"><span class="header-section-number">6.1</span> Expression Typing</a></h2>
<p>The typing of expressions is often relative to some <em>expected type</em> (which might be undefined). When we write ``expression \(e\) is expected to conform to type \(T\)'', we mean: (1) the expected type of \(e\) is \(T\), and (2) the type of expression \(e\) must conform to \(T\).</p>
<p>The following skolemization rule is applied universally for every expression: If the type of an expression would be an existential type \(T\), then the type of the expression is assumed instead to be a <a href="#existential-types">skolemization</a> of \(T\).</p>
<p>Skolemization is reversed by type packing. Assume an expression \(e\) of type \(T\) and let \(t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1 , \ldots , t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n\) be all the type variables created by skolemization of some part of \(e\) which are free in \(T\). Then the <em>packed type</em> of \(e\) is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$T$ <span class="kw">forSome</span> { <span class="kw">type</span> $t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1$; $\ldots$; <span class="kw">type</span> $t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n$ }.</code></pre>
<h2 id="literals-1"><a href="#TOC"><span class="header-section-number">6.2</span> Literals</a></h2>
<pre class="grammar"><code>SimpleExpr    ::=  Literal</code></pre>
<p>Typing of literals is as described <a href="#literals">here</a>; their evaluation is immediate.</p>
<h2 id="the-null-value"><a href="#TOC"><span class="header-section-number">6.3</span> The <em>Null</em> Value</a></h2>
<p>The <code>null</code> value is of type <code>scala.Null</code>, and is thus compatible with every reference type. It denotes a reference value which refers to a special â<code>null</code>â object. This object implements methods in class <code>scala.AnyRef</code> as follows:</p>
<ul>
<li><code>eq($x\,$)</code> and <code>==($x\,$)</code> return <code>true</code> iff the argument \(x\) is also the ``null'' object.</li>
<li><code>ne($x\,$)</code> and <code>!=($x\,$)</code> return true iff the argument x is not also the ``null'' object.</li>
<li><code>isInstanceOf[$T\,$]</code> always returns <code>false</code>.</li>
<li><code>asInstanceOf[$T\,$]</code> returns the `<code>null'' object itself if   $T$ conforms to</code>scala.AnyRef<code>, and throws a</code>NullPointerException` otherwise.</li>
</ul>
<p>A reference to any other member of the `<code>null'' object causes a</code>NullPointerException` to be thrown.</p>
<h2 id="designators"><a href="#TOC"><span class="header-section-number">6.4</span> Designators</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr  ::=  Path
              |  SimpleExpr `.&#39; <span class="fu">id</span></code></pre>
<p>A designator refers to a named term. It can be a <em>simple name</em> or a <em>selection</em>.</p>
<p>A simple name \(x\) refers to a value as specified <a href="#identifiers-names-and-scopes">here</a>. If \(x\) is bound by a definition or declaration in an enclosing class or object \(C\), it is taken to be equivalent to the selection <code>$C$.this.$x$</code> where \(C\) is taken to refer to the class containing \(x\) even if the type name \(C\) is <a href="#identifiers-names-and-scopes">shadowed</a> at the occurrence of \(x\).</p>
<p>If \(r\) is a <a href="#paths">stable identifier</a> of type \(T\), the selection \(r.x\) refers statically to a term member \(m\) of \(r\) that is identified in \(T\) by the name \(x\).</p>
<p>For other expressions \(e\), \(e.x\) is typed as if it was <code>{ val $y$ = $e$; $y$.$x$ }</code>, for some fresh name \(y\).</p>
<p>The expected type of a designator's prefix is always undefined. The type of a designator is the type \(T\) of the entity it refers to, with the following exception: The type of a <a href="#paths">path</a> \(p\) which occurs in a context where a <a href="#singleton-types">stable type</a> is required is the singleton type <code>$p$.type</code>.</p>
<p>The contexts where a stable type is required are those that satisfy one of the following conditions:</p>
<ol>
<li>The path \(p\) occurs as the prefix of a selection and it does not designate a constant, or</li>
<li>The expected type \(\mathit{pt}\) is a stable type, or</li>
<li>The expected type \(\mathit{pt}\) is an abstract type with a stable type as lower bound, and the type \(T\) of the entity referred to by \(p\) does not conform to \(\mathit{pt}\), or</li>
<li>The path \(p\) designates a module.</li>
</ol>
<p>The selection \(e.x\) is evaluated by first evaluating the qualifier expression \(e\), which yields an object \(r\), say. The selection's result is then the member of \(r\) that is either defined by \(m\) or defined by a definition overriding \(m\). If that member has a type which conforms to <code>scala.NotNull</code>, the member's value must be initialized to a value different from <code>null</code>, otherwise a <code>scala.UnitializedError</code> is thrown.</p>
<h2 id="this-and-super"><a href="#TOC"><span class="header-section-number">6.5</span> This and Super</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr  ::=  [id `.&#39;] `this&#39;
              |  [id &#39;.&#39;] `super&#39; [ClassQualifier] `.&#39; <span class="fu">id</span></code></pre>
<p>The expression <code>this</code> can appear in the statement part of a template or compound type. It stands for the object being defined by the innermost template or compound type enclosing the reference. If this is a compound type, the type of <code>this</code> is that compound type. If it is a template of a class or object definition with simple name \(C\), the type of this is the same as the type of <code>$C$.this</code>.</p>
<p>The expression <code>$C$.this</code> is legal in the statement part of an enclosing class or object definition with simple name \(C\). It stands for the object being defined by the innermost such definition. If the expression's expected type is a stable type, or <code>$C$.this</code> occurs as the prefix of a selection, its type is <code>$C$.this.type</code>, otherwise it is the self type of class \(C\).</p>
<p>A reference <code>super.$m$</code> refers statically to a method or type \(m\) in the least proper supertype of the innermost template containing the reference. It evaluates to the member \(m&#39;\) in the actual supertype of that template which is equal to \(m\) or which overrides \(m\). The statically referenced member \(m\) must be a type or a method.</p>
<p>If it is a method, it must be concrete, or the template containing the reference must have a member \(m&#39;\) which overrides \(m\) and which is labeled <code>abstract override</code>.</p>
<p>A reference <code>$C$.super.$m$</code> refers statically to a method or type \(m\) in the least proper supertype of the innermost enclosing class or object definition named \(C\) which encloses the reference. It evaluates to the member \(m&#39;\) in the actual supertype of that class or object which is equal to \(m\) or which overrides \(m\). The statically referenced member \(m\) must be a type or a method. If the statically referenced member \(m\) is a method, it must be concrete, or the innermost enclosing class or object definition named \(C\) must have a member \(m&#39;\) which overrides \(m\) and which is labeled <code>abstract override</code>.</p>
<p>The <code>super</code> prefix may be followed by a trait qualifier <code>[$T\,$]</code>, as in <code>$C$.super[$T\,$].$x$</code>. This is called a <em>static super reference</em>. In this case, the reference is to the type or method of \(x\) in the parent trait of \(C\) whose simple name is \(T\). That member must be uniquely defined. If it is a method, it must be concrete.</p>
<ol start="55" type="1">
<li><p>Consider the following class definitions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Root { <span class="kw">def</span> x = <span class="st">&quot;Root&quot;</span> }
<span class="kw">class</span> A <span class="kw">extends</span> Root { <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;A&quot;</span> ; <span class="kw">def</span> superA = <span class="kw">super</span>.<span class="fu">x</span> }
<span class="kw">trait</span> B <span class="kw">extends</span> Root { <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;B&quot;</span> ; <span class="kw">def</span> superB = <span class="kw">super</span>.<span class="fu">x</span> }
<span class="kw">class</span> C <span class="kw">extends</span> Root <span class="kw">with</span> B { 
  <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;C&quot;</span> ; <span class="kw">def</span> superC = <span class="kw">super</span>.<span class="fu">x</span>
}
<span class="kw">class</span> D <span class="kw">extends</span> A <span class="kw">with</span> B {
  <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;D&quot;</span> ; <span class="kw">def</span> superD = <span class="kw">super</span>.<span class="fu">x</span>
}</code></pre>
<p>The linearization of class <code>C</code> is <code>{C, B, Root}</code> and the linearization of class <code>D</code> is <code>{D, B, A, Root}</code>. Then we have:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(<span class="kw">new</span> A).<span class="fu">superA</span> == <span class="st">&quot;Root&quot;</span>, 
                          (<span class="kw">new</span> C).<span class="fu">superB</span> = <span class="st">&quot;Root&quot;</span>, (<span class="kw">new</span> C).<span class="fu">superC</span> = <span class="st">&quot;B&quot;</span>,
(<span class="kw">new</span> D).<span class="fu">superA</span> == <span class="st">&quot;Root&quot;</span>, (<span class="kw">new</span> D).<span class="fu">superB</span> = <span class="st">&quot;A&quot;</span>,    (<span class="kw">new</span> D).<span class="fu">superD</span> = <span class="st">&quot;B&quot;</span>,</code></pre>
<p>Note that the <code>superB</code> function returns different results depending on whether <code>B</code> is mixed in with class <code>Root</code> or <code>A</code>.</p></li>
</ol>
<h2 id="function-applications"><a href="#TOC"><span class="header-section-number">6.6</span> Function Applications</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr    ::=  SimpleExpr1 ArgumentExprs
ArgumentExprs ::=  `(&#39; [Exprs] `)&#39;
                |  `(&#39; [Exprs `,&#39;] PostfixExpr `:&#39; `_&#39; `*&#39; &#39;)&#39;
                |  [nl] BlockExpr
Exprs         ::=  Expr {`,&#39; Expr}</code></pre>
<p>An application <code>$f$($e_1 , \ldots , e_m$)</code> applies the function \(f\) to the argument expressions \(e_1 , \ldots , e_m\). If \(f\) has a method type <code>($p_1$:$T_1 , \ldots , p_n$:$T_n$)$U$</code>, the type of each argument expression \(e_i\) is typed with the corresponding parameter type \(T_i\) as expected type. Let \(S_i\) be type type of argument \(e_i\) \((i = 1 , \ldots , m)\). If \(f\) is a polymorphic method, <a href="#local-type-inference">local type inference</a> is used to determine type arguments for \(f\). If \(f\) has some value type, the application is taken to be equivalent to <code>$f$.apply($e_1 , \ldots , e_m$)</code>, i.e.Â the application of an <code>apply</code> method defined by \(f\).</p>
<p>The function \(f\) must be <em>applicable</em> to its arguments \(e_1 , \ldots , e_n\) of types \(S_1 , \ldots , S_n\).</p>
<p>If \(f\) has a method type \((p_1:T_1 , \ldots , p_n:T_n)U\) we say that an argument expression \(e_i\) is a <em>named</em> argument if it has the form \(x_i=e&#39;_i\) and \(x_i\) is one of the parameter names \(p_1 , \ldots , p_n\). The function \(f\) is applicable if all of the follwing conditions hold:</p>
<ul>
<li>For every named argument \(x_i=e&#39;_i\) the type \(S_i\) is compatible with the parameter type \(T_j\) whose name \(p_j\) matches \(x_i\).</li>
<li>For every positional argument \(e_i\) the type \(S_i\) is compatible with \(T_i\).</li>
<li>If the expected type is defined, the result type \(U\) is compatible to it.</li>
</ul>
<p>If \(f\) is a polymorphic method it is applicable if <a href="#local-type-inference">local type inference</a> can determine type arguments so that the instantiated method is applicable. If \(f\) has some value type it is applicable if it has a method member named <code>apply</code> which is applicable.</p>
<p>Evaluation of <code>$f$($e_1 , \ldots , e_n$)</code> usually entails evaluation of \(f\) and \(e_1 , \ldots , e_n\) in that order. Each argument expression is converted to the type of its corresponding formal parameter. After that, the application is rewritten to the function's right hand side, with actual arguments substituted for formal parameters. The result of evaluating the rewritten right-hand side is finally converted to the function's declared result type, if one is given.</p>
<p>The case of a formal parameter with a parameterless method type <code>=&gt;$T$</code> is treated specially. In this case, the corresponding actual argument expression \(e\) is not evaluated before the application. Instead, every use of the formal parameter on the right-hand side of the rewrite rule entails a re-evaluation of \(e\). In other words, the evaluation order for <code>=&gt;</code>-parameters is <em>call-by-name</em> whereas the evaluation order for normal parameters is <em>call-by-value</em>. Furthermore, it is required that \(e\)'s <a href="#expression-typing">packed type</a> conforms to the parameter type \(T\). The behavior of by-name parameters is preserved if the application is transformed into a block due to named or default arguments. In this case, the local value for that parameter has the form <code>val $y_i$ = () =&gt; $e$</code> and the argument passed to the function is <code>$y_i$()</code>.</p>
<p>The last argument in an application may be marked as a sequence argument, e.g.Â <code>$e$: _*</code>. Such an argument must correspond to a <a href="#repeated-parameters">repeated parameter</a> of type <code>$S$*</code> and it must be the only argument matching this parameter (i.e.Â the number of formal parameters and actual arguments must be the same). Furthermore, the type of \(e\) must conform to <code>scala.Seq[$T$]</code>, for some type \(T\) which conforms to \(S\). In this case, the argument list is transformed by replacing the sequence \(e\) with its elements. When the application uses named arguments, the vararg parameter has to be specified exactly once.</p>
<p>A function application usually allocates a new frame on the program's run-time stack. However, if a local function or a final method calls itself as its last action, the call is executed using the stack-frame of the caller.</p>
<ol start="56" type="1">
<li><p>Assume the following function which computes the sum of a variable number of arguments:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sum</span>(xs: Int*) = (<span class="dv">0</span> /: xs) ((x, y) =&gt; x + y)</code></pre>
<p>Then</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)
<span class="fu">sum</span>(List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>): _*)</code></pre>
<p>both yield <code>10</code> as result. On the other hand,</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</code></pre>
<p>would not typecheck.</p></li>
</ol>
<h3 id="named-and-default-arguments"><a href="#TOC"><span class="header-section-number">6.6.1</span> Named and Default Arguments</a></h3>
<p>If an application might uses named arguments \(p = e\) or default arguments, the following conditions must hold.</p>
<ul>
<li>The named arguments form a suffix of the argument list \(e_1 , \ldots , e_m\), i.e.Â no positional argument follows a named one.</li>
<li>The names \(x_i\) of all named arguments are pairwise distinct and no named argument defines a parameter which is already specified by a positional argument.</li>
<li>Every formal parameter \(p_j:T_j\) which is not specified by either a positional or a named argument has a default argument.</li>
</ul>
<p>If the application uses named or default arguments the following transformation is applied to convert it into an application without named or default arguments.</p>
<p>If the function \(f\) has the form <code>$p.m$[$\mathit{targs}$]</code> it is transformed into the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> q = $p$
  q.$<span class="fu">m</span>$[$\mathit{targs}$]
}</code></pre>
<p>If the function \(f\) is itself an application expression the transformation is applied recursively on \(f\). The result of transforming \(f\) is a block of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> q = $p$
  <span class="kw">val</span> $x_1$ = expr$_1$
  $\ldots$
  <span class="kw">val</span> $x_k$ = expr$_k$
  q.$<span class="fu">m</span>$[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
}</code></pre>
<p>where every argument in \((\mathit{args}_1) , \ldots , (\mathit{args}_l)\) is a reference to one of the values \(x_1 , \ldots , x_k\). To integrate the current application into the block, first a value definition using a fresh name \(y_i\) is created for every argument in \(e_1 , \ldots , e_m\), which is initialised to \(e_i\) for positional arguments and to \(e&#39;_i\) for named arguments of the form <code>$x_i=e'_i$</code>. Then, for every parameter which is not specified by the argument list, a value definition using a fresh name \(z_i\) is created, which is initialized using the method computing the <a href="#function-declarations-and-definitions">default argument</a> of this parameter.</p>
<p>Let \(\mathit{args}\) be a permutation of the generated names \(y_i\) and \(z_i\) such such that the position of each name matches the position of its corresponding parameter in the method type <code>($p_1:T_1 , \ldots , p_n:T_n$)$U$</code>. The final result of the transformation is a block of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> q = $p$
  <span class="kw">val</span> $x_1$ = expr$_1$
  $\ldots$
  <span class="kw">val</span> $x_l$ = expr$_k$
  <span class="kw">val</span> $y_1$ = $e_1$
  $\ldots$
  <span class="kw">val</span> $y_m$ = $e_m$
  <span class="kw">val</span> $z_1$ = q.$<span class="fu">m</span>$\$default\$i[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
  $\ldots$
  <span class="kw">val</span> $z_d$ = q.$<span class="fu">m</span>$\$default\$j[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
  q.$<span class="fu">m</span>$[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)($\mathit{args}$)
}</code></pre>
<h2 id="method-values"><a href="#TOC"><span class="header-section-number">6.7</span> Method Values</a></h2>
<pre class="grammar"><code>SimpleExpr    ::=  SimpleExpr1 `_&#39;</code></pre>
<p>The expression <sub><code>$e$ _</code></sub> is well-formed if \(e\) is of method type or if \(e\) is a call-by-name parameter. If \(e\) is a method with parameters, <code>$e$ _</code>~ represents \(e\) converted to a function type by <a href="#eta-expansion">eta expansion</a>. If \(e\) is a parameterless method or call-by-name parameter of type <code>=&gt;$T$</code>, <code>$e$ _</code>~ represents the function of type <code>() =&gt; $T$</code>, which evaluates \(e\) when it is applied to the empty parameterlist <code>()</code>.</p>
<ol start="57" type="1">
<li><p>The method values in the left column are each equivalent to the <a href="#anonymous-functions">anonymous functions</a> on their right.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">Math.<span class="fu">sin</span> _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; Math.<span class="fu">sin</span>(x)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">Array.<span class="fu">range</span> _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x1, x2) =&gt; Array.<span class="fu">range</span>(x1, x2)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">List.<span class="fu">map2</span> _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x1, x2) =&gt; (x3) =&gt; List.<span class="fu">map2</span>(x1, x2)(x3)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">List.<span class="fu">map2</span>(xs, ys)_</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; List.<span class="fu">map2</span>(xs, ys)(x)</code></td>
</tr>
</tbody>
</table>
<p>Note that a space is necessary between a method name and the trailing underscore because otherwise the underscore would be considered part of the name.</p></li>
</ol>
<h2 id="type-applications"><a href="#TOC"><span class="header-section-number">6.8</span> Type Applications</a></h2>
<pre class="grammar"><code>SimpleExpr    ::=  SimpleExpr TypeArgs</code></pre>
<p>A type application <code>$e$[$T_1 , \ldots , T_n$]</code> instantiates a polymorphic value \(e\) of type ~\lstinline@[\(a_1\) &gt;: \(L_1\) &lt;: \(U_1 , \ldots , a_n\) &gt;: \(L_n\) &lt;: \(U_n\)]\(S\)@~ with argument types <code>$T_1 , \ldots , T_n$</code>. Every argument type \(T_i\) must obey the corresponding bounds \(L_i\) and \(U_i\). That is, for each \(i = 1 , \ldots , n\), we must have \(\sigma L_i &lt;: T_i &lt;: \sigma U_i\), where \(\sigma\) is the substitution \([a_1 := T_1 , \ldots , a_n := T_n]\). The type of the application is \(\sigma S\).</p>
<p>If the function part \(e\) is of some value type, the type application is taken to be equivalent to <code>$e$.apply[$T_1 , \ldots ,$ T$_n$]</code>, i.e.Â the application of an <code>apply</code> method defined by \(e\).</p>
<p>Type applications can be omitted if <a href="#local-type-inference">local type inference</a> can infer best type parameters for a polymorphic functions from the types of the actual function arguments and the expected result type.</p>
<h2 id="tuples"><a href="#TOC"><span class="header-section-number">6.9</span> Tuples</a></h2>
<pre class="grammar"><code>SimpleExpr   ::=  `(&#39; [Exprs] `)&#39;</code></pre>
<p>A tuple expression <code>($e_1 , \ldots , e_n$)</code> is an alias for the class instance creation <code>scala.Tuple$n$($e_1 , \ldots , e_n$)</code>, where \(n \geq 2\).<br>The empty tuple <code>()</code> is the unique value of type <code>scala.Unit</code>.</p>
<h2 id="instance-creation-expressions"><a href="#TOC"><span class="header-section-number">6.10</span> Instance Creation Expressions</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr     ::=  `new&#39; (ClassTemplate | TemplateBody)</code></pre>
<p>A simple instance creation expression is of the form <code>new $c$</code> where \(c\) is a <a href="#constructor-invocations">constructor invocation</a>. Let \(T\) be the type of \(c\). Then \(T\) must denote a (a type instance of) a non-abstract subclass of <code>scala.AnyRef</code>. Furthermore, the <em>concrete self type</em> of the expression must conform to the <a href="#templates">self type</a> of the class denoted by \(T\). The concrete self type is normally \(T\), except if the expression <code>new $c$</code> appears as the right hand side of a value definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> $x$: $S$ = <span class="kw">new</span> $c$</code></pre>
<p>(where the type annotation <code>: $S$</code> may be missing). In the latter case, the concrete self type of the expression is the compound type <code>$T$ with $x$.type</code>.</p>
<p>The expression is evaluated by creating a fresh object of type \(T\) which is is initialized by evaluating \(c\). The type of the expression is \(T\).</p>
<p>A general instance creation expression is of the form <code>new $t$</code> for some <a href="#templates">class template</a> \(t\). Such an expression is equivalent to the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> $a$ <span class="kw">extends</span> $t$; <span class="kw">new</span> $a$ }</code></pre>
<p>where \(a\) is a fresh name of an <em>anonymous class</em> which is inaccessible to user programs.</p>
<p>There is also a shorthand form for creating values of structural types: If <code>{$D$}</code> is a class body, then <code>new {$D$}</code> is equivalent to the general instance creation expression <code>new AnyRef{$D$}</code>.</p>
<ol start="58" type="1">
<li><p>Consider the following structural instance creation expression:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> { <span class="kw">def</span> <span class="fu">getName</span>() = <span class="st">&quot;aaron&quot;</span> }</code></pre>
<p>This is a shorthand for the general instance creation expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> AnyRef{ <span class="kw">def</span> <span class="fu">getName</span>() = <span class="st">&quot;aaron&quot;</span> }</code></pre>
<p>The latter is in turn a shorthand for the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> anon\$X <span class="kw">extends</span> AnyRef{ <span class="kw">def</span> <span class="fu">getName</span>() = <span class="st">&quot;aaron&quot;</span> }; <span class="kw">new</span> anon\$X }</code></pre>
<p>where <code>anon\$X</code> is some freshly created name.</p></li>
</ol>
<h2 id="blocks"><a href="#TOC"><span class="header-section-number">6.11</span> Blocks</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">BlockExpr   ::=  `{&#39; Block `}&#39;
Block       ::=  {BlockStat semi} [ResultExpr]</code></pre>
<p>A block expression <code>{$s_1$; $\ldots$; $s_n$; $e\,$}</code> is constructed from a sequence of block statements \(s_1 , \ldots , s_n\) and a final expression \(e\). The statement sequence may not contain two definitions or declarations that bind the same name in the same namespace. The final expression can be omitted, in which case the unit value <code>()</code> is assumed.</p>
<p>The expected type of the final expression \(e\) is the expected type of the block. The expected type of all preceding statements is undefined.</p>
<p>The type of a block <code>$s_1$; $\ldots$; $s_n$; $e$</code> is <code>$T$ forSome {$\,Q\,$}</code>, where \(T\) is the type of \(e\) and \(Q\) contains <a href="#existential-types">existential clauses</a> for every value or type name which is free in \(T\) and which is defined locally in one of the statements \(s_1 , \ldots , s_n\). We say the existential clause <em>binds</em> the occurrence of the value or type name. Specifically,</p>
<ul>
<li>A locally defined type definition <code>type$\;t = T$</code> is bound by the existential clause <code>type$\;t &gt;: T &lt;: T$</code>. It is an error if \(t\) carries type parameters.</li>
<li>A locally defined value definition~ <code>val$\;x: T = e$</code> is bound by the existential clause <code>val$\;x: T$</code>.</li>
<li>A locally defined class definition <code>class$\;c$ extends$\;t$</code> is bound by the existential clause <code>type$\;c &lt;: T$</code> where \(T\) is the least class type or refinement type which is a proper supertype of the type \(c\). It is an error if \(c\) carries type parameters.</li>
<li>A locally defined object definition <code>object$\;x\;$extends$\;t$</code> is bound by the existential clause <code>val$\;x: T$</code> where \(T\) is the least class type or refinement type which is a proper supertype of the type <code>$x$.type</code>.</li>
</ul>
<p>Evaluation of the block entails evaluation of its statement sequence, followed by an evaluation of the final expression \(e\), which defines the result of the block.</p>
<ol start="59" type="1">
<li><p>Assuming a class <code>Ref[T](x: T)</code>, the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> C <span class="kw">extends</span> B {$\ldots$} ; <span class="kw">new</span> Ref(<span class="kw">new</span> C) }</code></pre>
<p>has the type <code>Ref[_1] forSome { type _1 &lt;: B }</code>. The block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> C <span class="kw">extends</span> B {$\ldots$} ; <span class="kw">new</span> C }</code></pre>
<p>simply has type <code>B</code>, because with the rules <a href="#simplification-rules">here</a> the existentially quantified type <code>_1 forSome { type _1 &lt;: B }</code> can be simplified to <code>B</code>.</p></li>
</ol>
<h2 id="prefix-infix-and-postfix-operations"><a href="#TOC"><span class="header-section-number">6.12</span> Prefix, Infix, and Postfix Operations</a></h2>
<p></p>
<pre class="grammar"><code>PostfixExpr     ::=  InfixExpr [id [nl]]
InfixExpr       ::=  PrefixExpr
                  |  InfixExpr id [nl] InfixExpr
PrefixExpr      ::=  [`-&#39; | `+&#39; | `!&#39; | `~&#39;] SimpleExpr </code></pre>
<p>Expressions can be constructed from operands and operators.</p>
<h3 id="prefix-operations"><a href="#TOC"><span class="header-section-number">6.12.1</span> Prefix Operations</a></h3>
<p>A prefix operation \(\mathit{op};e\) consists of a prefix operator \(\mathit{op}\), which must be one of the identifiers â<code>+</code>â, â<code>-</code>â, â<code>!</code>â or â<code>~</code>â. The expression \(\mathit{op};e\) is equivalent to the postfix method application <code>e.unary_$\mathit{op}$</code>.</p>
<p></p>
<p>Prefix operators are different from normal function applications in that their operand expression need not be atomic. For instance, the input sequence <code>-sin(x)</code> is read as <code>-(sin(x))</code>, whereas the function application <code>negate sin(x)</code> would be parsed as the application of the infix operator <code>sin</code> to the operands <code>negate</code> and <code>(x)</code>.</p>
<h3 id="postfix-operations"><a href="#TOC"><span class="header-section-number">6.12.2</span> Postfix Operations</a></h3>
<p>A postfix operator can be an arbitrary identifier. The postfix operation \(e;\mathit{op}\) is interpreted as \(e.\mathit{op}\).</p>
<h3 id="infix-operations"><a href="#TOC"><span class="header-section-number">6.12.3</span> Infix Operations</a></h3>
<p>An infix operator can be an arbitrary identifier. Infix operators have precedence and associativity defined as follows:</p>
<p>The <em>precedence</em> of an infix operator is determined by the operator's first character. Characters are listed below in increasing order of precedence, with characters on the same line having the same precedence.</p>
<pre><code>$\mbox{\rm\sl(all letters)}$
|
^
&amp;
&lt; &gt;
= !
:
+ -
* / %
$\mbox{\rm\sl(all other special characters)}$</code></pre>
<p>That is, operators starting with a letter have lowest precedence, followed by operators starting with `<code>|</code>', etc.</p>
<p>There's one exception to this rule, which concerns <a href="#assignment-operators"><em>assignment operators</em></a>. The precedence of an assigment operator is the same as the one of simple assignment <code>(=)</code>. That is, it is lower than the precedence of any other operator.</p>
<p>The <em>associativity</em> of an operator is determined by the operator's last character. Operators ending in a colon `<code>:</code>' are right-associative. All other operators are left-associative.</p>
<p>Precedence and associativity of operators determine the grouping of parts of an expression as follows.</p>
<ul>
<li>If there are several infix operations in an expression, then operators with higher precedence bind more closely than operators with lower precedence.</li>
<li>If there are consecutive infix operations \(e_0; \mathit{op}_1; e_1; \mathit{op}_2 \ldots \mathit{op}_n; e_n\) with operators \(\mathit{op}_1 , \ldots , \mathit{op}_n\) of the same precedence, then all these operators must have the same associativity. If all operators are left-associative, the sequence is interpreted as \((\ldots(e_0;\mathit{op}_1;e_1);\mathit{op}_2\ldots);\mathit{op}_n;e_n\). Otherwise, if all operators are right-associative, the sequence is interpreted as \(e_0;\mathit{op}_1;(e_1;\mathit{op}_2;(\ldots \mathit{op}_n;e_n)\ldots)\).</li>
<li>Postfix operators always have lower precedence than infix operators. E.g.Â \(e_1;\mathit{op}_1;e_2;\mathit{op}_2\) is always equivalent to \((e_1;\mathit{op}_1;e_2);\mathit{op}_2\).</li>
</ul>
<p>The right-hand operand of a left-associative operator may consist of several arguments enclosed in parentheses, e.g. \(e;\mathit{op};(e_1,\ldots,e_n)\). This expression is then interpreted as \(e.\mathit{op}(e_1,\ldots,e_n)\).</p>
<p>A left-associative binary operation \(e_1;\mathit{op};e_2\) is interpreted as \(e_1.\mathit{op}(e_2)\). If \(\mathit{op}\) is right-associative, the same operation is interpreted as <code>{ val $x$=$e_1$; $e_2$.$\mathit{op}$($x\,$) }</code>, where \(x\) is a fresh name.</p>
<h3 id="assignment-operators"><a href="#TOC"><span class="header-section-number">6.12.4</span> Assignment Operators</a></h3>
<p>An assignment operator is an operator symbol (syntax category <code>op</code> in <a href="#identifiers">Identifiers</a>) that ends in an equals character â<code>=</code>â, with the exception of operators for which one of the following conditions holds:</p>
<ol>
<li>the operator also starts with an equals character, or</li>
<li>the operator is one of <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(!=)</code>.</li>
</ol>
<p>Assignment operators are treated specially in that they can be expanded to assignments if no other interpretation is valid.</p>
<p>Let's consider an assignment operator such as <code>+=</code> in an infix operation <code>$l$ += $r$</code>, where \(l\), \(r\) are expressions.<br>This operation can be re-interpreted as an operation which corresponds to the assignment</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$l$ = $l$ + $r$</code></pre>
<p>except that the operation's left-hand-side \(l\) is evaluated only once.</p>
<p>The re-interpretation occurs if the following two conditions are fulfilled.</p>
<ol>
<li>The left-hand-side \(l\) does not have a member named <code>+=</code>, and also cannot be converted by an <a href="#implicit-conversions">implicit conversion</a> to a value with a member named <code>+=</code>.</li>
<li>The assignment <code>$l$ = $l$ + $r$</code> is type-correct. In particular this implies that \(l\) refers to a variable or object that can be assigned to, and that is convertible to a value with a member named <code>+</code>.</li>
</ol>
<h2 id="typed-expressions"><a href="#TOC"><span class="header-section-number">6.13</span> Typed Expressions</a></h2>
<pre class="grammar"><code>Expr1              ::=  PostfixExpr `:&#39; CompoundType</code></pre>
<p>The typed expression \(e: T\) has type \(T\). The type of expression \(e\) is expected to conform to \(T\). The result of the expression is the value of \(e\) converted to type \(T\).</p>
<ol start="60" type="1">
<li><p>Here are examples of well-typed and illegally typed expressions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="dv">1</span>: Int               <span class="co">// legal, of type Int</span>
<span class="dv">1</span>: Long              <span class="co">// legal, of type Long</span>
<span class="co">// 1: string         // ***** illegal</span></code></pre></li>
</ol>
<h2 id="annotated-expressions"><a href="#TOC"><span class="header-section-number">6.14</span> Annotated Expressions</a></h2>
<pre class="grammar"><code>Expr1              ::=  PostfixExpr `:&#39; Annotation {Annotation} </code></pre>
<p>An annotated expression ~ attaches <a href="#user-defined-annotations">annotations</a> \(a_1 , \ldots , a_n\) to the expression \(e\).</p>
<h2 id="assignments"><a href="#TOC"><span class="header-section-number">6.15</span> Assignments</a></h2>
<pre class="grammar"><code>Expr1        ::=  [SimpleExpr `.&#39;] id `=&#39; Expr
               |  SimpleExpr1 ArgumentExprs `=&#39; Expr</code></pre>
<p>The interpretation of an assignment to a simple variable <code>$x$ = $e$</code> depends on the definition of \(x\). If \(x\) denotes a mutable variable, then the assignment changes the current value of \(x\) to be the result of evaluating the expression \(e\). The type of \(e\) is expected to conform to the type of \(x\). If \(x\) is a parameterless function defined in some template, and the same template contains a setter function <code>$x$_=</code> as member, then the assignment <code>$x$ = $e$</code> is interpreted as the invocation <code>$x$_=($e\,$)</code> of that setter function. Analogously, an assignment <code>$f.x$ = $e$</code> to a parameterless function \(x\) is interpreted as the invocation <code>$f.x$_=($e\,$)</code>.</p>
<p>An assignment <code>$f$($\mathit{args}\,$) = $e$</code> with a function application to the left of the â<code>=</code>â operator is interpreted as <code>$f.$update($\mathit{args}$, $e\,$)</code>, i.e.<br>the invocation of an <code>update</code> function defined by \(f\).</p>
<ol start="61" type="1">
<li><p>Here are some assignment expressions and their equivalent expansions.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span> = e</code></td>
<td style="text-align: left;">x.f_=(e)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span>() = e</code></td>
<td style="text-align: left;">x.f.update(e)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span>(i) = e</code></td>
<td style="text-align: left;">x.f.update(i, e)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span>(i, j) = e</code></td>
<td style="text-align: left;">x.f.update(i, j, e)</td>
</tr>
</tbody>
</table></li>
<li><p>Here is the usual imperative code for matrix multiplication.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">matmul</span>(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="kw">val</span> zss: Array[Array[Double]] = <span class="kw">new</span> Array(xss.<span class="fu">length</span>, <span class="fu">yss</span>(<span class="dv">0</span>).<span class="fu">length</span>) 
  <span class="kw">var</span> i = <span class="dv">0</span> 
  <span class="kw">while</span> (i &lt; xss.<span class="fu">length</span>) {
    <span class="kw">var</span> j = <span class="dv">0</span> 
    <span class="kw">while</span> (j &lt; <span class="fu">yss</span>(<span class="dv">0</span>).<span class="fu">length</span>) {
      <span class="kw">var</span> acc = <span class="fl">0.0</span> 
      <span class="kw">var</span> k = <span class="dv">0</span> 
      <span class="kw">while</span> (k &lt; yss.<span class="fu">length</span>) {
        acc = acc + <span class="fu">xss</span>(i)(k) * <span class="fu">yss</span>(k)(j) 
        k += <span class="dv">1</span>
      }
      <span class="fu">zss</span>(i)(j) = acc 
      j += <span class="dv">1</span>
    }
    i += <span class="dv">1</span>
  }
  zss
}</code></pre>
<p>Desugaring the array accesses and assignments yields the following expanded version:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">matmul</span>(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="kw">val</span> zss: Array[Array[Double]] = <span class="kw">new</span> Array(xss.<span class="fu">length</span>, yss.<span class="fu">apply</span>(<span class="dv">0</span>).<span class="fu">length</span>) 
  <span class="kw">var</span> i = <span class="dv">0</span> 
  <span class="kw">while</span> (i &lt; xss.<span class="fu">length</span>) {
    <span class="kw">var</span> j = <span class="dv">0</span> 
    <span class="kw">while</span> (j &lt; yss.<span class="fu">apply</span>(<span class="dv">0</span>).<span class="fu">length</span>) {
      <span class="kw">var</span> acc = <span class="fl">0.0</span> 
      <span class="kw">var</span> k = <span class="dv">0</span> 
      <span class="kw">while</span> (k &lt; yss.<span class="fu">length</span>) {
        acc = acc + xss.<span class="fu">apply</span>(i).<span class="fu">apply</span>(k) * yss.<span class="fu">apply</span>(k).<span class="fu">apply</span>(j) 
        k += <span class="dv">1</span>
      }
      zss.<span class="fu">apply</span>(i).<span class="fu">update</span>(j, acc) 
      j += <span class="dv">1</span>
    }
    i += <span class="dv">1</span>
  }
  zss
}</code></pre></li>
</ol>
<h2 id="conditional-expressions"><a href="#TOC"><span class="header-section-number">6.16</span> Conditional Expressions</a></h2>
<pre class="grammar"><code>Expr1          ::=  `if&#39; `(&#39; Expr `)&#39; {nl} Expr [[semi] `else&#39; Expr]</code></pre>
<p>The conditional expression <code>if ($e_1$) $e_2$ else $e_3$</code> chooses one of the values of \(e_2\) and \(e_3\), depending on the value of \(e_1\). The condition \(e_1\) is expected to conform to type <code>Boolean</code>. The then-part \(e_2\) and the else-part \(e_3\) are both expected to conform to the expected type of the conditional expression. The type of the conditional expression is the <a href="#weak-conformance">weak least upper bound</a> of the types of \(e_2\) and \(e_3\). A semicolon preceding the <code>else</code> symbol of a conditional expression is ignored.</p>
<p>The conditional expression is evaluated by evaluating first \(e_1\). If this evaluates to <code>true</code>, the result of evaluating \(e_2\) is returned, otherwise the result of evaluating \(e_3\) is returned.</p>
<p>A short form of the conditional expression eliminates the else-part. The conditional expression <code>if ($e_1$) $e_2$</code> is evaluated as if it was <code>if ($e_1$) $e_2$ else ()</code>.</p>
<h2 id="while-loop-expressions"><a href="#TOC"><span class="header-section-number">6.17</span> While Loop Expressions</a></h2>
<pre class="grammar"><code>Expr1          ::=  `while&#39; `(&#39; Expr &#39;)&#39; {nl} Expr</code></pre>
<p>The while loop expression <code>while ($e_1$) $e_2$</code> is typed and evaluated as if it was an application of <code>whileLoop ($e_1$) ($e_2$)</code> where the hypothetical function <code>whileLoop</code> is defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">whileLoop</span>(cond: =&gt; Boolean)(body: =&gt; Unit): Unit  =
  <span class="kw">if</span> (cond) { body ; <span class="fu">whileLoop</span>(cond)(body) } <span class="kw">else</span> {}</code></pre>
<h2 id="do-loop-expressions"><a href="#TOC"><span class="header-section-number">6.18</span> Do Loop Expressions</a></h2>
<pre class="grammar"><code>Expr1          ::=  `do&#39; Expr [semi] `while&#39; `(&#39; Expr &#39;)&#39;</code></pre>
<p>The do loop expression <code>do $e_1$ while ($e_2$)</code> is typed and evaluated as if it was the expression <code>($e_1$ ; while ($e_2$) $e_1$)</code>. A semicolon preceding the <code>while</code> symbol of a do loop expression is ignored.</p>
<h2 id="for-comprehensions-and-for-loops"><a href="#TOC"><span class="header-section-number">6.19</span> For Comprehensions and For Loops</a></h2>
<pre class="grammar"><code>Expr1          ::=  `for&#39; (`(&#39; Enumerators `)&#39; | `{&#39; Enumerators `}&#39;) 
                       {nl} [`yield&#39;] Expr
Enumerators    ::=  Generator {semi Enumerator}
Enumerator     ::=  Generator 
                 |  Guard
                 |  `val&#39; Pattern1 `=&#39; Expr
Generator      ::=  Pattern1 `&lt;-&#39; Expr [Guard]
Guard          ::=  `if&#39; PostfixExpr</code></pre>
<p>A for loop <code>for ($\mathit{enums}\,$) $e$</code> executes expression \(e\) for each binding generated by the enumerators \(\mathit{enums}\). A for comprehension <code>for ($\mathit{enums}\,$) yield $e$</code> evaluates expression \(e\) for each binding generated by the enumerators \(\mathit{enums}\) and collects the results. An enumerator sequence always starts with a generator; this can be followed by further generators, value definitions, or guards. A <em>generator</em> <code>$p$ &lt;- $e$</code> produces bindings from an expression \(e\) which is matched in some way against pattern \(p\). A <em>value definition</em> <code>$p$ = $e$</code> binds the value name \(p\) (or several names in a pattern \(p\)) to the result of evaluating the expression \(e\). A <em>guard</em> <code>if $e$</code> contains a boolean expression which restricts enumerated bindings. The precise meaning of generators and guards is defined by translation to invocations of four methods: <code>map</code>, <code>withFilter</code>, <code>flatMap</code>, and <code>foreach</code>. These methods can be implemented in different ways for different carrier types.</p>
<p>The translation scheme is as follows. In a first step, every generator <code>$p$ &lt;- $e$</code>, where \(p\) is not <a href="#patterns">irrefutable</a> for the type of \(e\) is replaced by</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$p$ &lt;- $e$.<span class="fu">withFilter</span> { <span class="kw">case</span> $p$ =&gt; <span class="kw">true</span>; <span class="kw">case</span> _ =&gt; <span class="kw">false</span> }</code></pre>
<p>Then, the following rules are applied repeatedly until all comprehensions have been eliminated.</p>
<ul>
<li>A for comprehension <code>for ($p$ &lt;- $e\,$) yield $e'$</code> is translated to <code>$e$.map { case $p$ =&gt; $e'$ }</code>.</li>
<li>A for loop <code>for ($p$ &lt;- $e\,$) $e'$</code> is translated to <code>$e$.foreach { case $p$ =&gt; $e'$ }</code>.</li>
<li><p>A for comprehension</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> ($p$ &lt;- $e$; $p&#39;$ &lt;- $e&#39;; \ldots$) <span class="kw">yield</span> $e&#39;&#39;$</code></pre>
<p>where <code>$\ldots$</code> is a (possibly empty) sequence of generators, definitions, or guards, is translated to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">flatMap</span> { <span class="kw">case</span> $p$ =&gt; <span class="kw">for</span> ($p&#39;$ &lt;- $e&#39;; \ldots$) <span class="kw">yield</span> $e&#39;&#39;$ }</code></pre></li>
<li><p>A for loop</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> ($p$ &lt;- $e$; $p&#39;$ &lt;- $e&#39;; \ldots$) $e&#39;&#39;$</code></pre>
<p>where <code>$\ldots$</code> is a (possibly empty) sequence of generators, definitions, or guards, is translated to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">foreach</span> { <span class="kw">case</span> $p$ =&gt; <span class="kw">for</span> ($p&#39;$ &lt;- $e&#39;; \ldots$) $e&#39;&#39;$ }</code></pre></li>
<li><p>A generator <code>$p$ &lt;- $e$</code> followed by a guard <code>if $g$</code> is translated to a single generator <code>$p$ &lt;- $e$.withFilter(($x_1 , \ldots , x_n$) =&gt; $g\,$)</code> where \(x_1 , \ldots , x_n\) are the free variables of \(p\).</p></li>
<li><p>A generator <code>$p$ &lt;- $e$</code> followed by a value definition <code>$p'$ = $e'$</code> is translated to the following generator of pairs of values, where \(x\) and \(x&#39;\) are fresh names:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">($p$, $p&#39;$) &lt;- <span class="kw">for</span> ($x @ p$ &lt;- $e$) <span class="kw">yield</span> { <span class="kw">val</span> $x&#39; @ p&#39;$ = $e&#39;$; ($x$, $x&#39;$) }</code></pre></li>
</ul>
<ol start="63" type="1">
<li><p>The following code produces all pairs of numbers between \(1\) and \(n-1\) whose sums are prime.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span>  { i &lt;- <span class="dv">1</span> until n 
       j &lt;- <span class="dv">1</span> until i 
       <span class="kw">if</span> <span class="fu">isPrime</span>(i+j)
} <span class="kw">yield</span> (i, j)</code></pre>
<p>The for comprehension is translated to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span> until n)
  .<span class="fu">flatMap</span> {
     <span class="kw">case</span> i =&gt; (<span class="dv">1</span> until i)
       .<span class="fu">withFilter</span> { j =&gt; <span class="fu">isPrime</span>(i+j) }
       .<span class="fu">map</span> { <span class="kw">case</span> j =&gt; (i, j) } }</code></pre></li>
<li><p>For comprehensions can be used to express vector and matrix algorithms concisely. For instance, here is a function to compute the transpose of a given matrix:</p>
<!-- see test/files/run/t0421.scala -->

<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> transpose[A](xss: Array[Array[A]]) = {
  <span class="kw">for</span> (i &lt;- Array.<span class="fu">range</span>(<span class="dv">0</span>, <span class="fu">xss</span>(<span class="dv">0</span>).<span class="fu">length</span>)) <span class="kw">yield</span>
    <span class="kw">for</span> (xs &lt;- xss) <span class="kw">yield</span> <span class="fu">xs</span>(i)
}</code></pre>
<p>Here is a function to compute the scalar product of two vectors:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">scalprod</span>(xs: Array[Double], ys: Array[Double]) = {
  <span class="kw">var</span> acc = <span class="fl">0.0</span> 
  <span class="kw">for</span> ((x, y) &lt;- xs zip ys) acc = acc + x * y  
  acc
}</code></pre>
<p>Finally, here is a function to compute the product of two matrices. Compare with the imperative version of .</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">matmul</span>(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="kw">val</span> ysst = <span class="fu">transpose</span>(yss) 
  <span class="kw">for</span> (xs &lt;- xss) <span class="kw">yield</span>
    <span class="kw">for</span> (yst &lt;- ysst) <span class="kw">yield</span> 
      <span class="fu">scalprod</span>(xs, yst)
}</code></pre>
<p>The code above makes use of the fact that <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, and <code>foreach</code> are defined for instances of class <code>scala.Array</code>.</p></li>
</ol>
<h2 id="return-expressions"><a href="#TOC"><span class="header-section-number">6.20</span> Return Expressions</a></h2>
<pre class="grammar"><code>Expr1      ::=  `return&#39; [Expr]</code></pre>
<p>A return expression <code>return $e$</code> must occur inside the body of some enclosing named method or function. The innermost enclosing named method or function in a source program, \(f\), must have an explicitly declared result type, and the type of \(e\) must conform to it.<br>The return expression evaluates the expression \(e\) and returns its value as the result of \(f\). The evaluation of any statements or expressions following the return expression is omitted. The type of a return expression is <code>scala.Nothing</code>.</p>
<p>The expression \(e\) may be omitted. The return expression <code>return</code> is type-checked and evaluated as if it was <code>return ()</code>.</p>
<p>An <code>apply</code> method which is generated by the compiler as an expansion of an anonymous function does not count as a named function in the source program, and therefore is never the target of a return expression.</p>
<p>Returning from a nested anonymous function is implemented by throwing and catching a <code>scala.runtime.NonLocalReturnException</code>. Any exception catches between the point of return and the enclosing methods might see the exception. A key comparison makes sure that these exceptions are only caught by the method instance which is terminated by the return.</p>
<p>If the return expression is itself part of an anonymous function, it is possible that the enclosing instance of \(f\) has already returned before the return expression is executed. In that case, the thrown <code>scala.runtime.NonLocalReturnException</code> will not be caught, and will propagate up the call stack.</p>
<h2 id="throw-expressions"><a href="#TOC"><span class="header-section-number">6.21</span> Throw Expressions</a></h2>
<pre class="grammar"><code>Expr1      ::=  `throw&#39; Expr</code></pre>
<p>A throw expression <code>throw $e$</code> evaluates the expression \(e\). The type of this expression must conform to <code>Throwable</code>. If \(e\) evaluates to an exception reference, evaluation is aborted with the thrown exception. If \(e\) evaluates to <code>null</code>, evaluation is instead aborted with a <code>NullPointerException</code>. If there is an active <a href="#try-expressions"><code>try</code> expression</a> which handles the thrown exception, evaluation resumes with the handler; otherwise the thread executing the <code>throw</code> is aborted. The type of a throw expression is <code>scala.Nothing</code>.</p>
<h2 id="try-expressions"><a href="#TOC"><span class="header-section-number">6.22</span> Try Expressions</a></h2>
<pre class="grammar"><code>Expr1 ::=  `try&#39; `{&#39; Block `}&#39; [`catch&#39; `{&#39; CaseClauses `}&#39;] 
           [`finally&#39; Expr]</code></pre>
<p>A try expression is of the form <code>try { $b$ } catch $h$</code> where the handler \(h\) is a <a href="#pattern-matching-anonymous-functions">pattern matching anonymous function</a></p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ }</code></pre>
<p>This expression is evaluated by evaluating the block \(b\). If evaluation of \(b\) does not cause an exception to be thrown, the result of \(b\) is returned. Otherwise the handler \(h\) is applied to the thrown exception.<br>If the handler contains a case matching the thrown exception, the first such case is invoked. If the handler contains no case matching the thrown exception, the exception is re-thrown.</p>
<p>Let \(\mathit{pt}\) be the expected type of the try expression. The block \(b\) is expected to conform to \(\mathit{pt}\). The handler \(h\) is expected conform to type <code>scala.PartialFunction[scala.Throwable, $\mathit{pt}\,$]</code>. The type of the try expression is the <a href="#weak-conformance">weak least upper bound</a> of the type of \(b\) and the result type of \(h\).</p>
<p>A try expression <code>try { $b$ } finally $e$</code> evaluates the block \(b\). If evaluation of \(b\) does not cause an exception to be thrown, the expression \(e\) is evaluated. If an exception is thrown during evaluation of \(e\), the evaluation of the try expression is aborted with the thrown exception. If no exception is thrown during evaluation of \(e\), the result of \(b\) is returned as the result of the try expression.</p>
<p>If an exception is thrown during evaluation of \(b\), the finally block \(e\) is also evaluated. If another exception \(e\) is thrown during evaluation of \(e\), evaluation of the try expression is aborted with the thrown exception. If no exception is thrown during evaluation of \(e\), the original exception thrown in \(b\) is re-thrown once evaluation of \(e\) has completed. The block \(b\) is expected to conform to the expected type of the try expression. The finally expression \(e\) is expected to conform to type <code>Unit</code>.</p>
<p>A try expression <code>try { $b$ } catch $e_1$ finally $e_2$</code> is a shorthand for <code>try { try { $b$ } catch $e_1$ } finally $e_2$</code>.</p>
<h2 id="anonymous-functions"><a href="#TOC"><span class="header-section-number">6.23</span> Anonymous Functions</a></h2>
<pre class="grammar"><code>Expr            ::=  (Bindings | [`implicit&#39;] id | `_&#39;) `=&gt;&#39; Expr
ResultExpr      ::=  (Bindings | ([`implicit&#39;] id | `_&#39;) `:&#39; CompoundType) `=&gt;&#39; Block
Bindings        ::=  `(&#39; Binding {`,&#39; Binding} `)&#39;
Binding         ::=  (id | `_&#39;) [`:&#39; Type]</code></pre>
<p>The anonymous function <code>($x_1$: $T_1 , \ldots , x_n$: $T_n$) =&gt; e</code> maps parameters \(x_i\) of types \(T_i\) to a result given by expression \(e\). The scope of each formal parameter \(x_i\) is \(e\). Formal parameters must have pairwise distinct names.</p>
<p>If the expected type of the anonymous function is of the form <code>scala.Function$n$[$S_1 , \ldots , S_n$, $R\,$]</code>, the expected type of \(e\) is \(R\) and the type \(T_i\) of any of the parameters \(x_i\) can be omitted, in which case<code>$T_i$ = $S_i$</code> is assumed. If the expected type of the anonymous function is some other type, all formal parameter types must be explicitly given, and the expected type of \(e\) is undefined. The type of the anonymous function is<code>scala.Function$n$[$S_1 , \ldots , S_n$, $T\,$]</code>, where \(T\) is the <a href="#expression-typing">packed type</a> of \(e\). \(T\) must be equivalent to a type which does not refer to any of the formal parameters \(x_i\).</p>
<p>The anonymous function is evaluated as the instance creation expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> scala.<span class="fu">Function</span>$n$[$T_1 , \ldots , T_n$, $T$] {
  <span class="kw">def</span> <span class="fu">apply</span>($x_1$: $T_1 , \ldots , x_n$: $T_n$): $T$ = $e$
}</code></pre>
<p>In the case of a single untyped formal parameter, <code>($x\,$) =&gt; $e$</code> can be abbreviated to <code>$x$ =&gt; $e$</code>. If an anonymous function <code>($x$: $T\,$) =&gt; $e$</code> with a single typed parameter appears as the result expression of a block, it can be abbreviated to <code>$x$: $T$ =&gt; e</code>.</p>
<p>A formal parameter may also be a wildcard represented by an underscore <code>_</code>. In that case, a fresh name for the parameter is chosen arbitrarily.</p>
<p>A named parameter of an anonymous function may be optionally preceded by an <code>implicit</code> modifier. In that case the parameter is labeled <a href="#implicit-parameters-and-views"><code>implicit</code></a>; however the parameter section itself does not count as an implicit parameter section in the sense defined <a href="#implicit-parameters">here</a>. Hence, arguments to anonymous functions always have to be given explicitly.</p>
<ol start="65" type="1">
<li><p>Examples of anonymous functions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">x =&gt; x                             <span class="co">// The identity function</span>

f =&gt; g =&gt; x =&gt; <span class="fu">f</span>(<span class="fu">g</span>(x))             <span class="co">// Curried function composition</span>

(x: Int,y: Int) =&gt; x + y           <span class="co">// A summation function</span>

() =&gt; { count += <span class="dv">1</span>; count }        <span class="co">// The function which takes an</span>
                                   <span class="co">// empty parameter list $()$, </span>
                                   <span class="co">// increments a non-local variable </span>
                                   <span class="co">// `count&#39; and returns the new value.</span>

_ =&gt; <span class="dv">5</span>                             <span class="co">// The function that ignores its argument</span>
                                   <span class="co">// and always returns 5.</span></code></pre></li>
</ol>
<h3 id="placeholder-syntax-for-anonymous-functions"><a href="#TOC"><span class="header-section-number">6.23.1</span> Placeholder Syntax for Anonymous Functions</a></h3>
<pre class="grammar"><code>SimpleExpr1  ::=  `_&#39;</code></pre>
<p>An expression (of syntactic category <code>Expr</code>) may contain embedded underscore symbols <code>_</code> at places where identifiers are legal. Such an expression represents an anonymous function where subsequent occurrences of underscores denote successive parameters.</p>
<p>Define an <em>underscore section</em> to be an expression of the form <code>_:$T$</code> where \(T\) is a type, or else of the form <code>_</code>, provided the underscore does not appear as the expression part of a type ascription <code>_:$T$</code>.</p>
<p>An expression \(e\) of syntactic category <code>Expr</code> <em>binds</em> an underscore section \(u\), if the following two conditions hold: (1) \(e\) properly contains \(u\), and (2) there is no other expression of syntactic category <code>Expr</code> which is properly contained in \(e\) and which itself properly contains \(u\).</p>
<p>If an expression \(e\) binds underscore sections \(u_1 , \ldots , u_n\), in this order, it is equivalent to the anonymous function <code>($u'_1$, ... $u'_n$) =&gt; $e'$</code> where each \(u_i&#39;\) results from \(u_i\) by replacing the underscore with a fresh identifier and \(e&#39;\) results from \(e\) by replacing each underscore section \(u_i\) by \(u_i&#39;\).</p>
<ol start="66" type="1">
<li><p>The anonymous functions in the left column use placeholder syntax. Each of these is equivalent to the anonymous function on its right.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">_ + <span class="dv">1</span></code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; x + <span class="dv">1</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">_ * _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x1, x2) =&gt; x1 * x2</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">(_: Int) * <span class="dv">2</span></code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x: Int) =&gt; (x: Int) * <span class="dv">2</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala"><span class="kw">if</span> (_) x <span class="kw">else</span> y</code></td>
<td style="text-align: left;"><code class="sourceCode scala">z =&gt; <span class="kw">if</span> (z) x <span class="kw">else</span> y</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">_.<span class="fu">map</span>(f)</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; x.<span class="fu">map</span>(f)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">_.<span class="fu">map</span>(_ + <span class="dv">1</span>)</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; x.<span class="fu">map</span>(y =&gt; y + <span class="dv">1</span>)</code></td>
</tr>
</tbody>
</table></li>
</ol>
<h2 id="constant-expressions"><a href="#TOC"><span class="header-section-number">6.24</span> Constant Expressions</a></h2>
<p>Constant expressions are expressions that the Scala compiler can evaluate to a constant. The definition of ``constant expression'' depends on the platform, but they include at least the expressions of the following forms:</p>
<ul>
<li>A literal of a value class, such as an integer</li>
<li>A string literal</li>
<li>A class constructed with <a href="#the-predef-object"><code>Predef.classOf</code></a></li>
<li>An element of an enumeration from the underlying platform</li>
<li>A literal array, of the form , where all of the \(c_i\)'s are themselves constant expressions</li>
<li>An identifier defined by a <a href="#value-declarations-and-definitions">constant value definition</a>.</li>
</ul>
<h2 id="statements"><a href="#TOC"><span class="header-section-number">6.25</span> Statements</a></h2>
<pre class="grammar"><code>BlockStat    ::=  Import
               |  {Annotation} [`implicit&#39;] Def
               |  {Annotation} {LocalModifier} TmplDef
               |  Expr1
               | 
TemplateStat ::=  Import
               |  {Annotation} {Modifier} Def
               |  {Annotation} {Modifier} Dcl
               |  Expr
               | </code></pre>
<p>Statements occur as parts of blocks and templates. A statement can be an import, a definition or an expression, or it can be empty. Statements used in the template of a class definition can also be declarations. An expression that is used as a statement can have an arbitrary value type. An expression statement \(e\) is evaluated by evaluating \(e\) and discarding the result of the evaluation. </p>
<p>Block statements may be definitions which bind local names in the block. The only modifier allowed in all block-local definitions is <code>implicit</code>. When prefixing a class or object definition, modifiers <code>abstract</code>, <code>final</code>, and <code>sealed</code> are also permitted.</p>
<p>Evaluation of a statement sequence entails evaluation of the statements in the order they are written.</p>
<h2 id="implicit-conversions"><a href="#TOC"><span class="header-section-number">6.26</span> Implicit Conversions</a></h2>
<p></p>
<p>Implicit conversions can be applied to expressions whose type does not match their expected type, to qualifiers in selections, and to unapplied methods. The available implicit conversions are given in the next two sub-sections.</p>
<p>We say, a type \(T\) is <em>compatible</em> to a type \(U\) if \(T\) conforms to \(U\) after applying <a href="#eta-expansion">eta-expansion</a> and <a href="#views">view applications</a>.</p>
<h3 id="value-conversions"><a href="#TOC"><span class="header-section-number">6.26.1</span> Value Conversions</a></h3>
<p>The following five implicit conversions can be applied to an expression \(e\) which has some value type \(T\) and which is type-checked with some expected type \(\mathit{pt}\).</p>
<p><em>Overloading Resolution</em> <br>If an expression denotes several possible members of a class, <a href="#overloading-resolution">overloading resolution</a> is applied to pick a unique member.</p>
<p><em>Type Instantiation</em> <br>An expression \(e\) of polymorphic type</p>
<pre class="sourceCode scala"><code class="sourceCode scala">[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code></pre>
<p>which does not appear as the function part of a type application is converted to a type instance of \(T\) by determining with <a href="#local-type-inference">local type inference</a> instance types <code>$T_1 , \ldots , T_n$</code> for the type variables <code>$a_1 , \ldots , a_n$</code> and implicitly embedding \(e\) in the <a href="#type-applications">type application</a> <code>$e$[$T_1 , \ldots , T_n$]</code>.</p>
<p><em>Numeric Widening</em> <br>If \(e\) has a primitive number type which <a href="#weak-conformance">weakly conforms</a> to the expected type, it is widened to the expected type using one of the numeric conversion methods <code>toShort</code>, <code>toChar</code>, <code>toInt</code>, <code>toLong</code>, <code>toFloat</code>, <code>toDouble</code> defined <a href="#numeric-value-types">here</a>.</p>
<p><em>Numeric Literal Narrowing</em> <br>If the expected type is <code>Byte</code>, <code>Short</code> or <code>Char</code>, and the expression \(e\) is an integer literal fitting in the range of that type, it is converted to the same literal in that type.</p>
<p><em>Value Discarding</em> <br>If \(e\) has some value type and the expected type is <code>Unit</code>, \(e\) is converted to the expected type by embedding it in the term <code>{ $e$; () }</code>.</p>
<p><em>View Application</em> <br>If none of the previous conversions applies, and \(e\)'s type does not conform to the expected type \(\mathit{pt}\), it is attempted to convert \(e\) to the expected type with a <a href="#views">view</a>.</p>
<p><em>Dynamic Member Selection</em> <br>If none of the previous conversions applies, and \(e\) is a prefix of a selection \(e.x\), and \(e\)'s type conforms to class <code>scala.Dynamic</code>, then the selection is rewritten according to the rules for <a href="#dynamic-member-selection">dynamic member selection</a>.</p>
<h3 id="method-conversions"><a href="#TOC"><span class="header-section-number">6.26.2</span> Method Conversions</a></h3>
<p>The following four implicit conversions can be applied to methods which are not applied to some argument list.</p>
<p><em>Evaluation</em> <br>A parameterless method \(m\) of type <code>=&gt; $T$</code> is always converted to type \(T\) by evaluating the expression to which \(m\) is bound.</p>
<p><em>Implicit Application</em> <br> If the method takes only implicit parameters, implicit arguments are passed following the rules <a href="#implicit-parameters">here</a>.</p>
<p><em>Eta Expansion</em> <br> Otherwise, if the method is not a constructor, and the expected type \(\mathit{pt}\) is a function type \((\mathit{Ts}&#39;) \Arrow T&#39;\), <a href="#eta-expansion">eta-expansion</a> is performed on the expression \(e\).</p>
<p><em>Empty Application</em> <br> Otherwise, if \(e\) has method type \(()T\), it is implicitly applied to the empty argument list, yielding \(e()\).</p>
<h3 id="overloading-resolution"><a href="#TOC"><span class="header-section-number">6.26.3</span> Overloading Resolution</a></h3>
<p>If an identifier or selection \(e\) references several members of a class, the context of the reference is used to identify a unique member. The way this is done depends on whether or not \(e\) is used as a function. Let \(\mathscr{A}\) be the set of members referenced by \(e\).</p>
<p>Assume first that \(e\) appears as a function in an application, as in <code>$e$($e_1 , \ldots , e_m$)</code>.</p>
<p>One first determines the set of functions that is potentially applicable based on the <em>shape</em> of the arguments.</p>
<p>The shape of an argument expression \(e\), written \(\mathit{shape}(e)\), is a type that is defined as follows:</p>
<ul>
<li>For a function expression <code>($p_1$: $T_1 , \ldots , p_n$: $T_n$) =&gt; $b$</code>: <code>(Any $, \ldots ,$ Any) =&gt; $\mathit{shape}(b)$</code>, where <code>Any</code> occurs \(n\) times in the argument type.</li>
<li>For a named argument <code>$n$ = $e$</code>: \(\mathit{shape}(e)\).</li>
<li>For all other expressions: <code>Nothing</code>.</li>
</ul>
<p>Let \(\mathscr{B}\) be the set of alternatives in \(\mathscr{A}\) that are <a href="#function-applications"><em>applicable</em></a> to expressions \((e_1 , \ldots , e_n)\) of types \((\mathit{shape}(e_1) , \ldots , \mathit{shape}(e_n))\). If there is precisely one alternative in \(\mathscr{B}\), that alternative is chosen.</p>
<p>Otherwise, let \(S_1 , \ldots , S_m\) be the vector of types obtained by typing each argument with an undefined expected type. For every member \(m\) in \(\mathscr{B}\) one determines whether it is applicable to expressions (\(e_1 , \ldots , e_m\)) of types \(S_1 , \ldots , S_m\). It is an error if none of the members in \(\mathscr{B}\) is applicable. If there is one single applicable alternative, that alternative is chosen. Otherwise, let \(\mathscr{CC}\) be the set of applicable alternatives which don't employ any default argument in the application to \(e_1 , \ldots , e_m\). It is again an error if \(\mathscr{CC}\) is empty. Otherwise, one chooses the <em>most specific</em> alternative among the alternatives in \(\mathscr{CC}\), according to the following definition of being <code>as specific as'', and</code>more specific than'':</p>
<ul>
<li>A parameterized method \(m\) of type <code>($p_1:T_1, \ldots , p_n:T_n$)$U$</code> is <em>as specific as</em> some other member \(m&#39;\) of type \(S\) if \(m&#39;\) is applicable to arguments <code>($p_1 , \ldots , p_n\,$)</code> of types \(T_1 , \ldots , T_n\).</li>
<li>A polymorphic method of type <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code> is as specific as some other member of type \(S\) if \(T\) is as specific as \(S\) under the assumption that for \(i = 1 , \ldots , n\) each \(a_i\) is an abstract type name bounded from below by \(L_i\) and from above by \(U_i\).</li>
<li>A member of any other type is always as specific as a parameterized method or a polymorphic method.</li>
<li>Given two members of types \(T\) and \(U\) which are neither parameterized nor polymorphic method types, the member of type \(T\) is as specific as the member of type \(U\) if the existential dual of \(T\) conforms to the existential dual of \(U\). Here, the existential dual of a polymorphic type <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code> is <code>$T$ forSome { type $a_1$ &gt;: $L_1$ &lt;: $U_1$ $, \ldots ,$ type $a_n$ &gt;: $L_n$ &lt;: $U_n$}</code>. The existential dual of every other type is the type itself.</li>
</ul>
<p>The <em>relative weight</em> of an alternative \(A\) over an alternative \(B\) is a number from 0 to 2, defined as the sum of</p>
<ul>
<li>1 if \(A\) is as specific as \(B\), 0 otherwise, and</li>
<li>1 if \(A\) is defined in a class or object which is derived from the class or object defining \(B\), 0 otherwise.</li>
</ul>
<p>A class or object \(C\) is <em>derived</em> from a class or object \(D\) if one of the following holds:</p>
<ul>
<li>\(C\) is a subclass of \(D\), or</li>
<li>\(C\) is a companion object of a class derived from \(D\), or</li>
<li>\(D\) is a companion object of a class from which \(C\) is derived.</li>
</ul>
<p>An alternative \(A\) is <em>more specific</em> than an alternative \(B\) if the relative weight of \(A\) over \(B\) is greater than the relative weight of \(B\) over \(A\).</p>
<p>It is an error if there is no alternative in \(\mathscr{CC}\) which is more specific than all other alternatives in \(\mathscr{CC}\).</p>
<p>Assume next that \(e\) appears as a function in a type application, as in <code>$e$[$\mathit{targs}\,$]</code>. Then all alternatives in \(\mathscr{A}\) which take the same number of type parameters as there are type arguments in \(\mathit{targs}\) are chosen. It is an error if no such alternative exists. If there are several such alternatives, overloading resolution is applied again to the whole expression <code>$e$[$\mathit{targs}\,$]</code>.</p>
<p>Assume finally that \(e\) does not appear as a function in either an application or a type application. If an expected type is given, let \(\mathscr{B}\) be the set of those alternatives in \(\mathscr{A}\) which are <a href="#implicit-conversions">compatible</a> to it. Otherwise, let \(\mathscr{B}\) be the same as \(\mathscr{A}\). We choose in this case the most specific alternative among all alternatives in \(\mathscr{B}\). It is an error if there is no alternative in \(\mathscr{B}\) which is more specific than all other alternatives in \(\mathscr{B}\).</p>
<ol start="67" type="1">
<li><p>Consider the following definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> A <span class="kw">extends</span> B {}
<span class="kw">def</span> <span class="fu">f</span>(x: B, y: B) = $\ldots$
<span class="kw">def</span> <span class="fu">f</span>(x: A, y: B) = $\ldots$
<span class="kw">val</span> a: A 
<span class="kw">val</span> b: B</code></pre>
<p>Then the application <code>f(b, b)</code> refers to the first definition of \(f\) whereas the application <code>f(a, a)</code> refers to the second. Assume now we add a third overloaded definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: B, y: A) = $\ldots$</code></pre>
<p>Then the application <code>f(a, a)</code> is rejected for being ambiguous, since no most specific applicable signature exists.</p></li>
</ol>
<h3 id="local-type-inference"><a href="#TOC"><span class="header-section-number">6.26.4</span> Local Type Inference</a></h3>
<p>Local type inference infers type arguments to be passed to expressions of polymorphic type. Say \(e\) is of type [\(a_1\) &gt;: \(L_1\) &lt;: \(U_1 , \ldots , a_n\) &gt;: \(L_n\) &lt;: \(U_n\)]\(T\) and no explicit type parameters are given.</p>
<p>Local type inference converts this expression to a type application <code>$e$[$T_1 , \ldots , T_n$]</code>. The choice of the type arguments \(T_1 , \ldots , T_n\) depends on the context in which the expression appears and on the expected type \(\mathit{pt}\). There are three cases.</p>
<p><em>Case 1: Selections</em> <br>If the expression appears as the prefix of a selection with a name \(x\), then type inference is <em>deferred</em> to the whole expression \(e.x\). That is, if \(e.x\) has type \(S\), it is now treated as having type [\(a_1\) &gt;: \(L_1\) &lt;: \(U_1 , \ldots , a_n\) &gt;: \(L_n\) &lt;: \(U_n\)]\(S\), and local type inference is applied in turn to infer type arguments for \(a_1 , \ldots , a_n\), using the context in which \(e.x\) appears.</p>
<p><em>Case 2: Values</em> <br>If the expression \(e\) appears as a value without being applied to value arguments, the type arguments are inferred by solving a constraint system which relates the expression's type \(T\) with the expected type \(\mathit{pt}\). Without loss of generality we can assume that \(T\) is a value type; if it is a method type we apply <a href="#eta-expansion">eta-expansion</a> to convert it to a function type. Solving means finding a substitution \(\sigma\) of types \(T_i\) for the type parameters \(a_i\) such that</p>
<ul>
<li>None of inferred types \(T_i\) is a <a href="#singleton-types">singleton type</a></li>
<li>All type parameter bounds are respected, i.e.Â  \(\sigma L_i &lt;: \sigma a_i\) and \(\sigma a_i &lt;: \sigma U_i\) for \(i = 1 , \ldots , n\).</li>
<li>The expression's type conforms to the expected type, i.e.Â  \(\sigma T &lt;: \sigma \mathit{pt}\).</li>
</ul>
<p>It is a compile time error if no such substitution exists.<br>If several substitutions exist, local-type inference will choose for each type variable \(a_i\) a minimal or maximal type \(T_i\) of the solution space. A <em>maximal</em> type \(T_i\) will be chosen if the type parameter \(a_i\) appears <a href="#variance-annotations">contravariantly</a> in the type \(T\) of the expression. A <em>minimal</em> type \(T_i\) will be chosen in all other situations, i.e.Â if the variable appears covariantly, non-variantly or not at all in the type \(T\). We call such a substitution an <em>optimal solution</em> of the given constraint system for the type \(T\).</p>
<p><em>Case 3: Methods</em> <br>The last case applies if the expression \(e\) appears in an application \(e(d_1 , \ldots , d_m)\). In that case \(T\) is a method type \((p_1:R_1 , \ldots , p_m:R_m)T&#39;\). Without loss of generality we can assume that the result type \(T&#39;\) is a value type; if it is a method type we apply <a href="#eta-expansion">eta-expansion</a> to convert it to a function type. One computes first the types \(S_j\) of the argument expressions \(d_j\), using two alternative schemes. Each argument expression \(d_j\) is typed first with the expected type \(R_j\), in which the type parameters \(a_1 , \ldots , a_n\) are taken as type constants. If this fails, the argument \(d_j\) is typed instead with an expected type \(R_j&#39;\) which results from \(R_j\) by replacing every type parameter in \(a_1 , \ldots , a_n\) with {}.</p>
<p>In a second step, type arguments are inferred by solving a constraint system which relates the method's type with the expected type \(\mathit{pt}\) and the argument types \(S_1 , \ldots , S_m\). Solving the constraint system means finding a substitution \(\sigma\) of types \(T_i\) for the type parameters \(a_i\) such that</p>
<ul>
<li>None of inferred types \(T_i\) is a <a href="#singleton-types">singleton type</a></li>
<li>All type parameter bounds are respected, i.e.Â  \(\sigma L_i &lt;: \sigma a_i\) and \(\sigma a_i &lt;: \sigma U_i\) for \(i = 1 , \ldots , n\).</li>
<li>The method's result type \(T&#39;\) conforms to the expected type, i.e.Â  \(\sigma T&#39; &lt;: \sigma \mathit{pt}\).</li>
<li>Each argument type <a href="#weak-conformance">weakly conforms</a> to the corresponding formal parameter type, i.e.Â  \(\sigma S_j &lt;:_w \sigma R_j\) for \(j = 1 , \ldots , m\).</li>
</ul>
<p>It is a compile time error if no such substitution exists. If several solutions exist, an optimal one for the type \(T&#39;\) is chosen.</p>
<p>All or parts of an expected type \(\mathit{pt}\) may be undefined. The rules for <a href="#conformance">conformance</a> are extended to this case by adding the rule that for any type \(T\) the following two statements are always true: [  &lt;: T T &lt;:  . ]</p>
<p>It is possible that no minimal or maximal solution for a type variable exists, in which case a compile-time error results. Because \(&lt;:\) is a pre-order, it is also possible that a solution set has several optimal solutions for a type. In that case, a Scala compiler is free to pick any one of them.</p>
<ol start="68" type="1">
<li><p>Consider the two methods:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> cons[A](x: A, xs: List[A]): List[A] = x :: xs
<span class="kw">def</span> nil[B]: List[B] = Nil</code></pre>
<p>and the definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = <span class="fu">cons</span>(<span class="dv">1</span>, nil)</code></pre>
<p>The application of <code>cons</code> is typed with an undefined expected type. This application is completed by local type inference to <code>cons[Int](1, nil)</code>. Here, one uses the following reasoning to infer the type argument <code>Int</code> for the type parameter <code>a</code>:</p>
<p>First, the argument expressions are typed. The first argument <code>1</code> has type <code>Int</code> whereas the second argument <code>nil</code> is itself polymorphic. One tries to type-check <code>nil</code> with an expected type <code>List[a]</code>. This leads to the constraint system</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[b?] &lt;: List[a]</code></pre>
<p>where we have labeled <code>b?</code> with a question mark to indicate that it is a variable in the constraint system. Because class <code>List</code> is covariant, the optimal solution of this constraint is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">b = scala.<span class="fu">Nothing</span></code></pre>
<p>In a second step, one solves the following constraint system for the type parameter <code>a</code> of <code>cons</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Int &lt;: a?
List[scala.<span class="fu">Nothing</span>] &lt;: List[a?]
List[a?] &lt;: $\mbox{\sl undefined}$</code></pre>
<p>The optimal solution of this constraint system is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a = Int</code></pre>
<p>so <code>Int</code> is the type inferred for <code>a</code>.</p></li>
<li><p>Consider now the definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> ys = <span class="fu">cons</span>(<span class="st">&quot;abc&quot;</span>, xs)</code></pre>
<p>where <code>xs</code> is defined of type <code>List[Int]</code> as before. In this case local type inference proceeds as follows.</p>
<p>First, the argument expressions are typed. The first argument <code>&quot;abc&quot;</code> has type <code>String</code>. The second argument <code>xs</code> is first tried to be typed with expected type <code>List[a]</code>. This fails, as <code>List[Int]</code> is not a subtype of <code>List[a]</code>. Therefore, the second strategy is tried; <code>xs</code> is now typed with expected type <code>List[$\mbox{\sl undefined}$]</code>. This succeeds and yields the argument type <code>List[Int]</code>.</p>
<p>In a second step, one solves the following constraint system for the type parameter <code>a</code> of <code>cons</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">String &lt;: a?
List[Int] &lt;: List[a?]
List[a?] &lt;: $\mbox{\sl undefined}$</code></pre>
<p>The optimal solution of this constraint system is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a = scala.<span class="fu">Any</span> </code></pre>
<p>so <code>scala.Any</code> is the type inferred for <code>a</code>.</p></li>
</ol>
<h3 id="eta-expansion"><a href="#TOC"><span class="header-section-number">6.26.5</span> Eta Expansion</a></h3>
<p><em>Eta-expansion</em> converts an expression of method type to an equivalent expression of function type. It proceeds in two steps.</p>
<p>First, one identifes the maximal sub-expressions of \(e\); let's say these are \(e_1 , \ldots , e_m\). For each of these, one creates a fresh name \(x_i\). Let \(e&#39;\) be the expression resulting from replacing every maximal subexpression \(e_i\) in \(e\) by the corresponding fresh name \(x_i\). Second, one creates a fresh name \(y_i\) for every argument type \(T_i\) of the method (\(i = 1 , \ldots , n\)). The result of eta-conversion is then:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> $x_1$ = $e_1$; 
  $\ldots$ 
  <span class="kw">val</span> $x_m$ = $e_m$; 
  ($y_1: T_1 , \ldots , y_n: T_n$) =&gt; $e&#39;$($y_1 , \ldots , y_n$) 
}</code></pre>
<h3 id="dynamic-member-selection"><a href="#TOC"><span class="header-section-number">6.26.6</span> Dynamic Member Selection</a></h3>
<p>The standard Scala library defines a trait <code>scala.Dynamic</code> which defines a member @invokeDynamic@ as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">trait</span> Dynamic {
  <span class="kw">def</span> <span class="fu">applyDynamic</span> (name: String, args: Any*): Any
  ...
}</code></pre>
<p>Assume a selection of the form \(e.x\) where the type of \(e\) conforms to <code>scala.Dynamic</code>. Further assuming the selection is not followed by any function arguments, such an expression can be rewitten under the conditions given <a href="#implicit-conversions">here</a> to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">applyDynamic</span>(<span class="st">&quot;$x$&quot;</span>)</code></pre>
<p>If the selection is followed by some arguments, e.g.Â \(e.x(\mathit{args})\), then that expression is rewritten to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">applyDynamic</span>(<span class="st">&quot;$x$&quot;</span>, $\mathit{args}$)</code></pre>
<h1 id="implicit-parameters-and-views"><a href="#TOC"><span class="header-section-number">7</span> Implicit Parameters and Views</a></h1>
<h2 id="the-implicit-modifier"><a href="#TOC"><span class="header-section-number">7.1</span> The Implicit Modifier</a></h2>
<pre class="grammar"><code>LocalModifier  ::= âimplicitâ
ParamClauses   ::= {ParamClause} [nl] â(â âimplicitâ Params â)â</code></pre>
<p>Template members and parameters labeled with an <code>implicit</code> modifier can be passed to <a href="#implicit-parameters">implicit parameters</a> and can be used as implicit conversions called <a href="#views">views</a>. The <code class="sourceCode scala"><span class="kw">implicit</span></code> modifier is illegal for all type members, as well as for <a href="#packagings">top-level objects</a>.</p>
<ol start="70" type="1">
<li><p>The following code defines an abstract class of monoids and two concrete implementations, <code>StringMonoid</code> and <code>IntMonoid</code>. The two implementations are marked implicit.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Monoid[A] <span class="kw">extends</span> SemiGroup[A] {
  <span class="kw">def</span> <span class="dt">unit</span>: A
  <span class="kw">def</span> <span class="fu">add</span>(x: A, y: A): A
}
<span class="kw">object</span> Monoids {
  <span class="kw">implicit</span> <span class="kw">object</span> stringMonoid <span class="kw">extends</span> Monoid[String] {
    <span class="kw">def</span> <span class="fu">add</span>(x: String, y: String): String = x.<span class="fu">concat</span>(y)
    <span class="kw">def</span> <span class="dt">unit</span>: String = <span class="st">&quot;&quot;</span>
  }
  <span class="kw">implicit</span> <span class="kw">object</span> intMonoid <span class="kw">extends</span> Monoid[Int] {
    <span class="kw">def</span> <span class="fu">add</span>(x: Int, y: Int): Int = x + y
    <span class="kw">def</span> <span class="dt">unit</span>: Int = <span class="dv">0</span>
  }
}</code></pre></li>
</ol>
<h2 id="implicit-parameters"><a href="#TOC"><span class="header-section-number">7.2</span> Implicit Parameters</a></h2>
<p>An implicit parameter list <code class="sourceCode scala">(<span class="kw">implicit</span> $p_1$,$\ldots$,$p_n$)</code> of a method marks the parameters \(p_1 , \ldots , p_n\) as implicit. A method or constructor can have only one implicit parameter list, and it must be the last parameter list given.</p>
<p>A method with implicit parameters can be applied to arguments just like a normal method. In this case the <code>implicit</code> label has no effect. However, if such a method misses arguments for its implicit parameters, such arguments will be automatically provided.</p>
<p>The actual arguments that are eligible to be passed to an implicit parameter of type \(T\) fall into two categories. First, eligible are all identifiers \(x\) that can be accessed at the point of the method call without a prefix and that denote an <a href="#the-implicit-modifier">implicit definition</a> or an implicit parameter. An eligible identifier may thus be a local name, or a member of an enclosing template, or it may be have been made accessible without a prefix through an <a href="#import-clauses">import clause</a>. If there are no eligible identifiers under this rule, then, second, eligible are also all <code class="sourceCode scala"><span class="kw">implicit</span></code> members of some object that belongs to the implicit scope of the implicit parameter's type, \(T\).</p>
<p>The <em>implicit scope</em> of a type \(T\) consists of all <a href="#object-definitions">companion modules</a> of classes that are associated with the implicit parameter's type. Here, we say a class \(C\) is <em>associated</em> with a type \(T\), if it is a <a href="#class-linearization">base class</a> of some part of \(T\). The <em>parts</em> of a type \(T\) are:</p>
<ul>
<li>if \(T\) is a compound type <code class="sourceCode scala">$T_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $T_n$</code>, the union of the parts of \(T_1 , \ldots , T_n\), as well as \(T\) itself,</li>
<li>if \(T\) is a parameterized type <code>$S$[$T_1 , \ldots , T_n$]</code>, the union of the parts of \(S\) and \(T_1 , \ldots , T_n\),</li>
<li>if \(T\) is a singleton type <code class="sourceCode scala">$p$.<span class="fu">type</span></code>, the parts of the type of \(p\),</li>
<li>if \(T\) is a type projection <code class="sourceCode scala">$S$#$U$</code>, the parts of \(S\) as well as \(T\) itself,</li>
<li>in all other cases, just \(T\) itself.</li>
</ul>
<p>If there are several eligible arguments which match the implicit parameter's type, a most specific one will be chosen using the rules of static <a href="#overloading-resolution">overloading resolution</a>. If the parameter has a default argument and no implicit argument can be found the default argument is used.</p>
<ol start="71" type="1">
<li><p>Assuming the classes from , here is a method which computes the sum of a list of elements using the monoid's <code>add</code> and <code>unit</code> operations.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum[A](xs: List[A])(<span class="kw">implicit</span> m: Monoid[A]): A = 
  <span class="kw">if</span> (xs.<span class="fu">isEmpty</span>) m.<span class="fu">unit</span>
  <span class="kw">else</span> m.<span class="fu">add</span>(xs.<span class="fu">head</span>, <span class="fu">sum</span>(xs.<span class="fu">tail</span>))</code></pre>
<p>The monoid in question is marked as an implicit parameter, and can therefore be inferred based on the type of the list. Consider for instance the call <code class="sourceCode scala"><span class="fu">sum</span>(List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))</code> in a context where <code>stringMonoid</code> and <code>intMonoid</code> are visible. We know that the formal type parameter <code>a</code> of <code>sum</code> needs to be instantiated to <code>Int</code>. The only eligible object which matches the implicit formal parameter type <code>Monoid[Int]</code> is <code>intMonoid</code> so this object will be passed as implicit parameter.</p></li>
</ol>
<p>This discussion also shows that implicit parameters are inferred after any type arguments are <a href="#local-type-inference">inferred</a>.</p>
<p>Implicit methods can themselves have implicit parameters. An example is the following method from module <code>scala.List</code>, which injects lists into the <code class="sourceCode scala">scala.<span class="fu">Ordered</span></code> class, provided the element type of the list is also convertible to this type.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> list2ordered[A](x: List[A])
  (<span class="kw">implicit</span> elem2ordered: A =&gt; Ordered[A]): Ordered[List[A]] = 
  ...</code></pre>
<p>Assume in addition a method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> <span class="fu">int2ordered</span>(x: Int): Ordered[Int]</code></pre>
<p>that injects integers into the <code>Ordered</code> class. We can now define a <code>sort</code> method over ordered lists:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sort[A](xs: List[A])(<span class="kw">implicit</span> a2ordered: A =&gt; Ordered[A]) = ...</code></pre>
<p>We can apply <code>sort</code> to a list of lists of integers <code class="sourceCode scala">yss: List[List[Int]]</code> as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sort</span>(yss)</code></pre>
<p>The call above will be completed by passing two nested implicit arguments:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sort</span>(yss)(xs: List[Int] =&gt; list2ordered[Int](xs)(int2ordered)) .</code></pre>
<p>The possibility of passing implicit arguments to implicit arguments raises the possibility of an infinite recursion. For instance, one might try to define the following method, which injects <em>every</em> type into the <code>Ordered</code> class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> magic[A](x: A)(<span class="kw">implicit</span> a2ordered: A =&gt; Ordered[A]): Ordered[A] = 
  <span class="fu">a2ordered</span>(x)</code></pre>
<p>Now, if one tried to apply <code>sort</code> to an argument <code>arg</code> of a type that did not have another injection into the <code>Ordered</code> class, one would obtain an infinite expansion:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sort</span>(arg)(x =&gt; <span class="fu">magic</span>(x)(x =&gt; <span class="fu">magic</span>(x)(x =&gt; ... )))</code></pre>
<p>To prevent such infinite expansions, the compiler keeps track of a stack of âopen implicit typesâ for which implicit arguments are currently being searched. Whenever an implicit argument for type \(T\) is searched, the âcore typeâ of \(T\) is added to the stack. Here, the <em>core type</em> of \(T\) is \(T\) with aliases expanded, top-level type <a href="#user-defined-annotations">annotations</a> and <a href="#compound-types">refinements</a> removed, and occurrences of top-level existentially bound variables replaced by their upper bounds. The core type is removed from the stack once the search for the implicit argument either definitely fails or succeeds. Everytime a core type is added to the stack, it is checked that this type does not dominate any of the other types in the set.</p>
<p>Here, a core type \(T\) <em>dominates</em> a type \(U\) if \(T\) is <a href="#type-equivalence">equivalent</a> to \(U\), or if the top-level type constructors of \(T\) and \(U\) have a common element and \(T\) is more complex than \(U\).</p>
<p>The set of <em>top-level type constructors</em> \(\mathit{ttcs}(T)\) of a type \(T\) depends on the form of the type:</p>
<blockquote>
<p>For a type designator, <br>\(\mathit{ttcs}(p.c) ~=~ \{c\}\); <br>For a parameterized type, <br>\(\mathit{ttcs}(p.c[\mathit{targs}]) ~=~ \{c\}\); <br>For a singleton type, <br>\(\mathit{ttcs}(p.type) ~=~ \mathit{ttcs}(T)\), provided \(p\) has type \(T\);<br>For a compound type, <br><code>$\mathit{ttcs}(T_1$ with $\ldots$ with $T_n)$</code> \(~=~ \mathit{ttcs}(T_1) \cup \ldots \cup \mathit{ttcs}(T_n)\).</p>
</blockquote>
<p>The <em>complexity</em> \(\mathit{complexity}(T)\) of a core type is an integer which also depends on the form of the type:</p>
<blockquote>
<p>For a type designator, <br>\(\mathit{complexity}(p.c) ~=~ 1 + \mathit{complexity}(p)\) <br>For a parameterized type, <br>\(\mathit{complexity}(p.c[\mathit{targs}]) ~=~ 1 + \Sigma \mathit{complexity}(\mathit{targs})\) <br>For a singleton type denoting a package \(p\), <br>\(\mathit{complexity}(p.type) ~=~ 0\) <br>For any other singleton type, <br>\(\mathit{complexity}(p.type) ~=~ 1 + \mathit{complexity}(T)\), provided \(p\) has type \(T\); <br>For a compound type, <br><code>$\mathit{complexity}(T_1$ with $\ldots$ with $T_n)$</code> \(= \Sigma\mathit{complexity}(T_i)\)</p>
</blockquote>
<ol start="72" type="1">
<li><p>When typing <code>sort(xs)</code> for some list <code>xs</code> of type <code>List[List[List[Int]]]</code>, the sequence of types for which implicit arguments are searched is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[List[Int]] =&gt; Ordered[List[List[Int]]], 
List[Int] =&gt; Ordered[List[Int]]
Int =&gt; Ordered[Int]</code></pre>
<p>All types share the common type constructor <code>scala.Function1</code>, but the complexity of the each new type is lower than the complexity of the previous types. Hence, the code typechecks.</p></li>
<li><p>Let <code>ys</code> be a list of some type which cannot be converted to <code>Ordered</code>. For instance:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> ys = List(<span class="kw">new</span> IllegalArgumentException, <span class="kw">new</span> ClassCastException, <span class="kw">new</span> Error)</code></pre>
<p>Assume that the definition of <code>magic</code> above is in scope. Then the sequence of types for which implicit arguments are searched is</p>
<pre><code>Throwable =&gt; Ordered[Throwable],
Throwable =&gt; Ordered[Throwable],
...</code></pre>
<p>Since the second type in the sequence is equal to the first, the compiler will issue an error signalling a divergent implicit expansion.</p></li>
</ol>
<h2 id="views"><a href="#TOC"><span class="header-section-number">7.3</span> Views</a></h2>
<p>Implicit parameters and methods can also define implicit conversions called views. A <em>view</em> from type \(S\) to type \(T\) is defined by an implicit value which has function type <code>$S$=&gt;$T$</code> or <code>(=&gt;$S$)=&gt;$T$</code> or by a method convertible to a value of that type.</p>
<p>Views are applied in three situations.</p>
<ol>
<li>If an expression \(e\) is of type \(T\), and \(T\) does not conform to the expression's expected type \(\mathit{pt}\). In this case an implicit \(v\) is searched which is applicable to \(e\) and whose result type conforms to \(\mathit{pt}\). The search proceeds as in the case of implicit parameters, where the implicit scope is the one of <code>$T$ =&gt; $\mathit{pt}$</code>. If such a view is found, the expression \(e\) is converted to <code>$v$($e$)</code>.</li>
<li>In a selection \(e.m\) with \(e\) of type \(T\), if the selector \(m\) does not denote a member of \(T\). In this case, a view \(v\) is searched which is applicable to \(e\) and whose result contains a member named \(m\). The search proceeds as in the case of implicit parameters, where the implicit scope is the one of \(T\). If such a view is found, the selection \(e.m\) is converted to <code>$v$($e$).$m$</code>.</li>
<li>In a selection \(e.m(\mathit{args})\) with \(e\) of type \(T\), if the selector \(m\) denotes some member(s) of \(T\), but none of these members is applicable to the arguments \(\mathit{args}\). In this case a view \(v\) is searched which is applicable to \(e\) and whose result contains a method \(m\) which is applicable to \(\mathit{args}\). The search proceeds as in the case of implicit parameters, where the implicit scope is the one of \(T\). If such a view is found, the selection \(e.m\) is converted to <code>$v$($e$).$m(\mathit{args})$</code>.</li>
</ol>
<p>The implicit view, if it is found, can accept is argument \(e\) as a call-by-value or as a call-by-name parameter. However, call-by-value implicits take precedence over call-by-name implicits.</p>
<p>As for implicit parameters, overloading resolution is applied if there are several possible candidates (of either the call-by-value or the call-by-name category).</p>
<ol start="74" type="1">
<li><p>Class <code>scala.Ordered[A]</code> contains a method</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> &lt;= [B &gt;: A](that: B)(<span class="kw">implicit</span> b2ordered: B =&gt; Ordered[B]): Boolean .</code></pre>
<p>Assume two lists <code>xs</code> and <code>ys</code> of type <code>List[Int]</code> and assume that the <code>list2ordered</code> and <code>int2ordered</code> methods defined <a href="#implicit-parameters">here</a> are in scope. Then the operation</p>
<pre><code>  xs &lt;= ys</code></pre>
<p>is legal, and is expanded to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="fu">list2ordered</span>(xs)(int2ordered).&lt;=
    (ys)
    (xs =&gt; <span class="fu">list2ordered</span>(xs)(int2ordered))</code></pre>
<p>The first application of <code>list2ordered</code> converts the list <code>xs</code> to an instance of class <code>Ordered</code>, whereas the second occurrence is part of an implicit parameter passed to the <code>&lt;=</code> method.</p></li>
</ol>
<h2 id="context-bounds-and-view-bounds"><a href="#TOC"><span class="header-section-number">7.4</span> Context Bounds and View Bounds</a></h2>
<pre class="grammar"><code>  TypeParam ::= (id | â_â) [TypeParamClause] [â&gt;:â Type] [â&lt;:â Type] 
                {â&lt;%â Type} {â:â Type}</code></pre>
<p>A type parameter \(A\) of a method or non-trait class may have one or more view bounds <code>$A$ &lt;% $T$</code>. In this case the type parameter may be instantiated to any type \(S\) which is convertible by application of a view to the bound \(T\).</p>
<p>A type parameter \(A\) of a method or non-trait class may also have one or more context bounds <code>$A$ : $T$</code>. In this case the type parameter may be instantiated to any type \(S\) for which <em>evidence</em> exists at the instantiation point that \(S\) satisfies the bound \(T\). Such evidence consists of an implicit value with type \(T[S]\).</p>
<p>A method or class containing type parameters with view or context bounds is treated as being equivalent to a method with implicit parameters. Consider first the case of a single parameter with view and/or context bounds such as:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> $f$[$A$ &lt;% $T_1$ ... &lt;% $T_m$ : $U_1$ : $U_n$]($\mathit{ps}$): $R$ = ...</code></pre>
<p>Then the method definition above is expanded to</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> $f$[$A$]($\mathit{ps}$)(<span class="kw">implicit</span> $v_1$: $A$ =&gt; $T_1$, ..., $v_m$: $A$ =&gt; $T_m$,
                       $w_1$: $U_1$[$A$], ..., $w_n$: $U_n$[$A$]): $R$ = ...</code></pre>
<p>where the \(v_i\) and \(w_j\) are fresh names for the newly introduced implicit parameters. These parameters are called <em>evidence parameters</em>.</p>
<p>If a class or method has several view- or context-bounded type parameters, each such type parameter is expanded into evidence parameters in the order they appear and all the resulting evidence parameters are concatenated in one implicit parameter section. Since traits do not take constructor parameters, this translation does not work for them. Consequently, type-parameters in traits may not be view- or context-bounded. Also, a method or class with view- or context bounds may not define any additional implicit parameters.</p>
<ol start="75" type="1">
<li><p>The <code>&lt;=</code> method mentioned in  can be declared more concisely as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> &lt;= [B &gt;: A &lt;% Ordered[B]](that: B): Boolean</code></pre></li>
</ol>
<h2 id="manifests"><a href="#TOC"><span class="header-section-number">7.5</span> Manifests</a></h2>
<p>Manifests are type descriptors that can be automatically generated by the Scala compiler as arguments to implicit parameters. The Scala standard library contains a hierarchy of four manifest classes, with <code>OptManifest</code> at the top. Their signatures follow the outline below.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> OptManifest[+T]
<span class="kw">object</span> NoManifest <span class="kw">extends</span> OptManifest[Nothing]
<span class="kw">trait</span> ClassManifest[T] <span class="kw">extends</span> OptManifest[T]
<span class="kw">trait</span> Manifest[T] <span class="kw">extends</span> ClassManifest[T]</code></pre>
<p>If an implicit parameter of a method or constructor is of a subtype \(M[T]\) of class <code>OptManifest[T]</code>, <em>a manifest is determined for \(M[S]\)</em>, according to the following rules.</p>
<p>First if there is already an implicit argument that matches \(M[T]\), this argument is selected.</p>
<p>Otherwise, let \(\mathit{Mobj}\) be the companion object <code>scala.reflect.Manifest</code> if \(M\) is trait <code>Manifest</code>, or be the companion object <code>scala.reflect.ClassManifest</code> otherwise. Let \(M&#39;\) be the trait <code>Manifest</code> if \(M\) is trait <code>Manifest</code>, or be the trait <code>OptManifest</code> otherwise.<br>Then the following rules apply.</p>
<ol>
<li>If \(T\) is a value class or one of the classes <code>Any</code>, <code>AnyVal</code>, <code>Object</code>, <code>Null</code>, or <code>Nothing</code>, a manifest for it is generated by selecting the corresponding manifest value <code>Manifest.$T$</code>, which exists in the <code>Manifest</code> module.</li>
<li>If \(T\) is an instance of <code>Array[$S$]</code>, a manifest is generated with the invocation <code>$\mathit{Mobj}$.arrayType[S](m)</code>, where \(m\) is the manifest determined for \(M[S]\).</li>
<li>If \(T\) is some other class type \(S\#C[U_1 , \ldots , U_n]\) where the prefix type \(S\) cannot be statically determined from the class \(C\), a manifest is generated with the invocation <code>$\mathit{Mobj}$.classType[T]($m_0$, classOf[T], $ms$)</code> where \(m_0\) is the manifest determined for \(M&#39;[S]\) and \(ms\) are the manifests determined for \(M&#39;[U_1] , \ldots , M&#39;[U_n]\).</li>
<li>If \(T\) is some other class type with type arguments \(U_1 , \ldots , U_n\), a manifest is generated with the invocation <code>$\mathit{Mobj}$.classType[T](classOf[T], $ms$)</code> where \(ms\) are the manifests determined for \(M&#39;[U_1] , \ldots , M&#39;[U_n]\).</li>
<li>If \(T\) is a singleton type <code>$p$.type</code>, a manifest is generated with the invocation <code>$\mathit{Mobj}$.singleType[T]($p$)</code></li>
<li>If \(T\) is a refined type \(T&#39; \{ R \}\), a manifest is generated for \(T&#39;\). (That is, refinements are never reflected in manifests).</li>
<li>If \(T\) is an intersection type <code>$T_1$ with $, \ldots ,$ with $T_n$</code> where \(n &gt; 1\), the result depends on whether a full manifest is to be determined or not. If \(M\) is trait <code>Manifest</code>, then a manifest is generated with the invocation <code>Manifest.intersectionType[T]($ms$)</code> where \(ms\) are the manifests determined for \(M[T_1] , \ldots , M[T_n]\). Otherwise, if \(M\) is trait <code>ClassManifest</code>, then a manifest is generated for the <a href="#type-erasure">intersection dominator</a> of the types \(T_1 , \ldots , T_n\).</li>
<li>If \(T\) is some other type, then if \(M\) is trait <code>OptManifest</code>, a manifest is generated from the designator <code>scala.reflect.NoManifest</code>. If \(M\) is a type different from <code>OptManifest</code>, a static error results.</li>
</ol>
<h1 id="pattern-matching"><a href="#TOC"><span class="header-section-number">8</span> Pattern Matching</a></h1>
<h2 id="patterns"><a href="#TOC"><span class="header-section-number">8.1</span> Patterns</a></h2>
<pre class="grammar"><code>  Pattern         ::=  Pattern1 { â|â Pattern1 }
  Pattern1        ::=  varid â:â TypePat
                    |  â_â â:â TypePat
                    |  Pattern2
  Pattern2        ::=  varid [â@â Pattern3]
                    |  Pattern3
  Pattern3        ::=  SimplePattern 
                    |  SimplePattern {id [nl] SimplePattern}
  SimplePattern   ::=  â_â
                    |  varid
                    |  Literal
                    |  StableId
                    |  StableId â(â [Patterns] â)â
                    |  StableId â(â [Patterns â,â] [varid â@â] â_â â*â â)â
                    |  â(â [Patterns] â)â
                    |  XmlPattern
  Patterns        ::=  Pattern {â,â Patterns}</code></pre>
<p>A pattern is built from constants, constructors, variables and type tests. Pattern matching tests whether a given value (or sequence of values) has the shape defined by a pattern, and, if it does, binds the variables in the pattern to the corresponding components of the value (or sequence of values). The same variable name may not be bound more than once in a pattern.</p>
<ol start="76" type="1">
<li><p>Some examples of patterns are:</p>
<ol>
<li>The pattern <code>ex: IOException</code> matches all instances of class <code>IOException</code>, binding variable  to the instance.</li>
<li>The pattern <code>Some(x)</code> matches values of the form <code>Some($v$)</code>, binding <code>x</code> to the argument value \(v\) of the <code>Some</code> constructor.</li>
<li>The pattern <code>(x, _)</code> matches pairs of values, binding <code>x</code> to the first component of the pair. The second component is matched with a wildcard pattern.</li>
<li>The pattern <code class="sourceCode scala">x :: y :: xs</code> matches lists of length \(\geq 2\), binding <code>x</code> to the list's first element, <code>y</code> to the list's second element, and <code>xs</code> to the remainder.</li>
<li>The pattern <code>1 | 2 | 3</code> matches the integers between 1 and 3.</li>
</ol>
<p>Pattern matching is always done in a context which supplies an expected type of the pattern. We distinguish the following kinds of patterns.</p></li>
</ol>
<h3 id="variable-patterns"><a href="#TOC"><span class="header-section-number">8.1.1</span> Variable Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  `_&#39;
                    |  varid</code></pre>
<p>A variable pattern \(x\) is a simple identifier which starts with a lower case letter. It matches any value, and binds the variable name to that value. The type of \(x\) is the expected type of the pattern as given from outside. A special case is the wild-card pattern \(\_\) which is treated as if it was a fresh variable on each occurrence.</p>
<h3 id="typed-patterns"><a href="#TOC"><span class="header-section-number">8.1.2</span> Typed Patterns</a></h3>
<pre class="grammar"><code>  Pattern1        ::=  varid `:&#39; TypePat
                    |  `_&#39; `:&#39; TypePat</code></pre>
<p>A typed pattern \(x: T\) consists of a pattern variable \(x\) and a type pattern \(T\). The type of \(x\) is the type pattern \(T\), where each type variable and wildcard is replaced by a fresh, unknown type. This pattern matches any value matched by the <a href="#type-patterns">type pattern</a> \(T\); it binds the variable name to that value.</p>
<h3 id="pattern-binders"><a href="#TOC"><span class="header-section-number">8.1.3</span> Pattern Binders</a></h3>
<pre class="grammar"><code>  Pattern2        ::=  varid `@&#39; Pattern3</code></pre>
<p>A pattern binder  consists of a pattern variable \(x\) and a pattern \(p\). The type of the variable \(x\) is the static type \(T\) of the pattern \(p\). This pattern matches any value \(v\) matched by the pattern \(p\), provided the run-time type of \(v\) is also an instance of \(T\), and it binds the variable name to that value.</p>
<h3 id="literal-patterns"><a href="#TOC"><span class="header-section-number">8.1.4</span> Literal Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  Literal</code></pre>
<p>A literal pattern \(L\) matches any value that is equal (in terms of \(==\)) to the literal \(L\). The type of \(L\) must conform to the expected type of the pattern.</p>
<h3 id="stable-identifier-patterns"><a href="#TOC"><span class="header-section-number">8.1.5</span> Stable Identifier Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  StableId</code></pre>
<p>A stable identifier pattern is a <a href="#paths">stable identifier</a> \(r\). The type of \(r\) must conform to the expected type of the pattern. The pattern matches any value \(v\) such that <code>$r$ == $v$</code> (see <a href="#root-classes">here</a>).</p>
<p>To resolve the syntactic overlap with a variable pattern, a stable identifier pattern may not be a simple name starting with a lower-case letter. However, it is possible to enclose a such a variable name in backquotes; then it is treated as a stable identifier pattern.</p>
<ol start="77" type="1">
<li><p>Consider the following function definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: Int, y: Int) = x <span class="kw">match</span> {
  <span class="kw">case</span> y =&gt; ...
}</code></pre>
<p>Here, <code>y</code> is a variable pattern, which matches any value. If we wanted to turn the pattern into a stable identifier pattern, this can be achieved as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: Int, y: Int) = x <span class="kw">match</span> {
  <span class="kw">case</span> `y` =&gt; ...
}</code></pre>
<p>Now, the pattern matches the <code>y</code> parameter of the enclosing function <code>f</code>. That is, the match succeeds only if the <code>x</code> argument and the <code>y</code> argument of <code>f</code> are equal.</p></li>
</ol>
<h3 id="constructor-patterns"><a href="#TOC"><span class="header-section-number">8.1.6</span> Constructor Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  StableId `(&#39; [Patterns] `)</code></pre>
<p>A constructor pattern is of the form \(c(p_1 , \ldots , p_n)\) where \(n \geq 0\). It consists of a stable identifier \(c\), followed by element patterns \(p_1 , \ldots , p_n\). The constructor \(c\) is a simple or qualified name which denotes a <a href="#case-classes">case class</a>. If the case class is monomorphic, then it must conform to the expected type of the pattern, and the formal parameter types of \(x\)'s <a href="#class-definitions">primary constructor</a> are taken as the expected types of the element patterns \(p_1, \ldots , p_n\). If the case class is polymorphic, then its type parameters are instantiated so that the instantiation of \(c\) conforms to the expected type of the pattern. The instantiated formal parameter types of \(c\)'s primary constructor are then taken as the expected types of the component patterns \(p_1, \ldots , p_n\). The pattern matches all objects created from constructor invocations \(c(v_1 , \ldots , v_n)\) where each element pattern \(p_i\) matches the corresponding value \(v_i\).</p>
<p>A special case arises when \(c\)'s formal parameter types end in a repeated parameter. This is further discussed <a href="#pattern-sequences">here</a>.</p>
<h3 id="tuple-patterns"><a href="#TOC"><span class="header-section-number">8.1.7</span> Tuple Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  `(&#39; [Patterns] `)&#39;</code></pre>
<p>A tuple pattern <code>($p_1 , \ldots , p_n$)</code> is an alias for the constructor pattern ~\lstinline@scala.Tuple\(n\)(\(p_1 , \ldots , p_n\))@, where \(n \geq 2\). The empty tuple <code class="sourceCode scala">()</code> is the unique value of type <code class="sourceCode scala">scala.<span class="fu">Unit</span></code>.</p>
<h3 id="extractor-patterns"><a href="#TOC"><span class="header-section-number">8.1.8</span> Extractor Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  StableId `(&#39; [Patterns] `)&#39;</code></pre>
<p>An extractor pattern \(x(p_1 , \ldots , p_n)\) where \(n \geq 0\) is of the same syntactic form as a constructor pattern. However, instead of a case class, the stable identifier \(x\) denotes an object which has a member method named <code>unapply</code> or <code>unapplySeq</code> that matches the pattern.</p>
<p>An <code>unapply</code> method in an object \(x\) <em>matches</em> the pattern \(x(p_1 , \ldots , p_n)\) if it takes exactly one argument and one of the following applies:</p>
<ul>
<li>\(n=0\) and <code>unapply</code>'s result type is <code>Boolean</code>. In this case the extractor pattern matches all values \(v\) for which <code>$x$.unapply($v$)</code> yields <code>true</code>.</li>
<li>\(n=1\) and <code>unapply</code>'s result type is <code>Option[$T$]</code>, for some type \(T\). In this case, the (only) argument pattern \(p_1\) is typed in turn with expected type \(T\). The extractor pattern matches then all values \(v\) for which <code>$x$.unapply($v$)</code> yields a value of form <code>Some($v_1$)</code>, and \(p_1\) matches \(v_1\).</li>
<li>\(n&gt;1\) and <code>unapply</code>'s result type is <code>Option[($T_1 , \ldots , T_n$)]</code>, for some types \(T_1 , \ldots , T_n\). In this case, the argument patterns \(p_1 , \ldots , p_n\) are typed in turn with expected types \(T_1 , \ldots , T_n\). The extractor pattern matches then all values \(v\) for which <code>$x$.unapply($v$)</code> yields a value of form <code>Some(($v_1 , \ldots , v_n$))</code>, and each pattern \(p_i\) matches the corresponding value \(v_i\).</li>
</ul>
<p>An <code>unapplySeq</code> method in an object \(x\) matches the pattern \(x(p_1 , \ldots , p_n)\) if it takes exactly one argument and its result type is of the form <code>Option[$S$]</code>, where \(S\) is a subtype of <code>Seq[$T$]</code> for some element type \(T\). This case is further discussed <a href="#pattern-seqs">here</a>.</p>
<ol start="78" type="1">
<li><p>The <code>Predef</code> object contains a definition of an extractor object <code>Pair</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Pair {
  <span class="kw">def</span> apply[A, B](x: A, y: B) = <span class="fu">Tuple2</span>(x, y)
  <span class="kw">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}</code></pre>
<p>This means that the name <code>Pair</code> can be used in place of <code>Tuple2</code> for tuple formation as well as for deconstruction of tuples in patterns. Hence, the following is possible:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x = (<span class="dv">1</span>, <span class="dv">2</span>)
<span class="kw">val</span> y = x <span class="kw">match</span> {
  <span class="kw">case</span> Pair(i, s) =&gt; Pair(s + i, i * i)
}</code></pre></li>
</ol>
<h3 id="pattern-sequences"><a href="#TOC"><span class="header-section-number">8.1.9</span> Pattern Sequences</a></h3>
<pre class="grammar"><code>  SimplePattern ::= StableId `(&#39; [Patterns `,&#39;] [varid `@&#39;] `_&#39; `*&#39; `)&#39;</code></pre>
<p>A pattern sequence \(p_1 , \ldots , p_n\) appears in two contexts. First, in a constructor pattern \(c(q_1 , \ldots , q_m, p_1 , \ldots , p_n\)), where \(c\) is a case class which has \(m+1\) primary constructor parameters, ending in a <a href="#repeated-parameters">repeated parameter</a> of type \(S*\). Second, in an extractor pattern \(x(p_1 , \ldots , p_n)\) if the extractor object \(x\) has an <code>unapplySeq</code> method with a result type conforming to <code>Seq[$S$]</code>, but does not have an <code>unapply</code> method that matches \(p_1 , \ldots , p_n\). The expected type for the pattern sequence is in each case the type \(S\).</p>
<p>The last pattern in a pattern sequence may be a <em>sequence wildcard</em> <code>_*</code>. Each element pattern \(p_i\) is type-checked with \(S\) as expected type, unless it is a sequence wildcard. If a final sequence wildcard is present, the pattern matches all values \(v\) that are sequences which start with elements matching patterns \(p_1 , \ldots , p_{n-1}\). If no final sequence wildcard is given, the pattern matches all values \(v\) that are sequences of length \(n\) which consist of elements matching patterns \(p_1 , \ldots , p_n\).</p>
<h3 id="infix-operation-patterns"><a href="#TOC"><span class="header-section-number">8.1.10</span> Infix Operation Patterns</a></h3>
<pre class="grammar"><code>  Pattern3  ::=  SimplePattern {id [nl] SimplePattern}</code></pre>
<p>An infix operation pattern \(p;\mathit{op};q\) is a shorthand for the constructor or extractor pattern \(\mathit{op}(p, q)\). The precedence and associativity of operators in patterns is the same as in <a href="#prefix-infix-and-postfix-operations">expressions</a>.</p>
<p>An infix operation pattern \(p;\mathit{op};(q_1 , \ldots , q_n)\) is a shorthand for the constructor or extractor pattern \(\mathit{op}(p, q_1 , \ldots , q_n)\).</p>
<h3 id="pattern-alternatives"><a href="#TOC"><span class="header-section-number">8.1.11</span> Pattern Alternatives</a></h3>
<pre class="grammar"><code>  Pattern   ::=  Pattern1 { `|&#39; Pattern1 }</code></pre>
<p>A pattern alternative <code>$p_1$ | $\ldots$ | $p_n$</code> consists of a number of alternative patterns \(p_i\). All alternative patterns are type checked with the expected type of the pattern. They may no bind variables other than wildcards. The alternative pattern matches a value \(v\) if at least one its alternatives matches \(v\).</p>
<h3 id="xml-patterns"><a href="#TOC"><span class="header-section-number">8.1.12</span> XML Patterns</a></h3>
<p>XML patterns are treated <a href="#xml-patterns">here</a>.</p>
<h3 id="regular-expression-patterns"><a href="#TOC"><span class="header-section-number">8.1.13</span> Regular Expression Patterns</a></h3>
<p>Regular expression patterns have been discontinued in Scala from version 2.0.</p>
<p>Later version of Scala provide a much simplified version of regular expression patterns that cover most scenarios of non-text sequence processing. A <em>sequence pattern</em> is a pattern that stands in a position where either (1) a pattern of a type  which is conforming to  for some  is expected, or (2) a case class constructor that has an iterated formal parameter . A wildcard star pattern  in the rightmost position stands for arbitrary long sequences. It can be bound to variables using , as usual, in which case the variable will have the type .</p>
<h3 id="irrefutable-patterns"><a href="#TOC"><span class="header-section-number">8.1.14</span> Irrefutable Patterns</a></h3>
<p>A pattern \(p\) is <em>irrefutable</em> for a type \(T\), if one of the following applies:</p>
<ol>
<li>\(p\) is a variable pattern,</li>
<li>\(p\) is a typed pattern \(x: T&#39;\), and \(T &lt;: T&#39;\),</li>
<li>\(p\) is a constructor pattern \(c(p_1 , \ldots , p_n)\), the type \(T\) is an instance of class \(c\), the <a href="#class-definitions">primary constructor</a> of type \(T\) has argument types \(T_1 , \ldots , T_n\), and each \(p_i\) is irrefutable for \(T_i\).</li>
</ol>
<h2 id="type-patterns"><a href="#TOC"><span class="header-section-number">8.2</span> Type Patterns</a></h2>
<pre class="grammar"><code>  TypePat           ::=  Type</code></pre>
<p>Type patterns consist of types, type variables, and wildcards. A type pattern \(T\) is of one of the following forms:</p>
<ul>
<li>A reference to a class \(C\), \(p.C\), or <code>$T$#$C$</code>. This type pattern matches any non-null instance of the given class. Note that the prefix of the class, if it is given, is relevant for determining class instances. For instance, the pattern \(p.C\) matches only instances of classes \(C\) which were created with the path \(p\) as prefix.</li>
</ul>
<p>The bottom types <code>scala.Nothing</code> and <code>scala.Null</code> cannot be used as type patterns, because they would match nothing in any case.</p>
<ul>
<li>A singleton type <code>$p$.type</code>. This type pattern matches only the value denoted by the path \(p\) (that is, a pattern match involved a comparison of the matched value with \(p\) using method <code>eq</code> in class <code>AnyRef</code>).</li>
<li><p>A compound type pattern <code>$T_1$ with $\ldots$ with $T_n$</code> where each \(T_i\) is a type pattern. This type pattern matches all values that are matched by each of the type patterns \(T_i\).</p></li>
<li><p>A parameterized type pattern \(T[a_1 , \ldots , a_n]\), where the \(a_i\) are type variable patterns or wildcards \(\_\). This type pattern matches all values which match \(T\) for some arbitrary instantiation of the type variables and wildcards. The bounds or alias type of these type variable are determined as described <a href="#type-parameter-inference-in-patterns">here</a>.</p></li>
<li><p>A parameterized type pattern <code>scala.Array$[T_1]$</code>, where \(T_1\) is a type pattern. This type pattern matches any non-null instance of type <code>scala.Array$[U_1]$</code>, where \(U_1\) is a type matched by \(T_1\).</p></li>
</ul>
<p>Types which are not of one of the forms described above are also accepted as type patterns. However, such type patterns will be translated to their <a href="#type-erasure">erasure</a>. The Scala compiler will issue an ``unchecked'' warning for these patterns to flag the possible loss of type-safety.</p>
<p>A <em>type variable pattern</em> is a simple identifier which starts with a lower case letter. However, the predefined primitive type aliases <code>unit</code>, <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code> are not classified as type variable patterns.</p>
<h2 id="type-parameter-inference-in-patterns"><a href="#TOC"><span class="header-section-number">8.3</span> Type Parameter Inference in Patterns</a></h2>
<p>Type parameter inference is the process of finding bounds for the bound type variables in a typed pattern or constructor pattern. Inference takes into account the expected type of the pattern.</p>
<p>Type parameter inference for typed patterns. <br> Assume a typed pattern \(p: T&#39;\). Let \(T\) result from \(T&#39;\) where all wildcards in \(T&#39;\) are renamed to fresh variable names. Let \(a_1 , \ldots , a_n\) be the type variables in \(T\). These type variables are considered bound in the pattern. Let the expected type of the pattern be \(\mathit{pt}\).</p>
<p>Type parameter inference constructs first a set of subtype constraints over the type variables \(a_i\). The initial constraints set \(\mathcal{C}_0\) reflects just the bounds of these type variables. That is, assuming \(T\) has bound type variables \(a_1 , \ldots , a_n\) which correspond to class type parameters \(a&#39;_1 , \ldots , a&#39;_n\) with lower bounds \(L_1 , \ldots , L_n\) and upper bounds \(U_1 , \ldots , U_n\), \(\mathcal{C}_0\) contains the constraints</p>
<p>\[\begin{array}
a_i        &amp;&lt;:&amp; \sigma U_i &amp; (i = 1, \ldots , n)  \\ 
\sigma L_i &amp;&lt;:&amp; a_i        &amp; (i = 1 , \ldots , n)
\end{array}\]</p>
<p>where \(\sigma\) is the substitution \([a&#39;_1 := a_1 , \ldots , a&#39;_n := a_n]\).</p>
<p>The set \(\mathcal{C}_0\) is then augmented by further subtype constraints. There are two cases.</p>
<p>Case 1: <br>If there exists a substitution \(\sigma\) over the type variables \(a_i , \ldots , a_n\) such that \(\sigma T\) conforms to \(\mathit{pt}\), one determines the weakest subtype constraints \(\mathcal{C}_1\) over the type variables \(a_1 , \ldots , a_n\) such that \(\mathcal{C}_0 \wedge \mathcal{C}_1\) implies that \(T\) conforms to \(\mathit{pt}\).</p>
<p>Case 2: <br>Otherwise, if \(T\) can not be made to conform to \(\mathit{pt}\) by instantiating its type variables, one determines all type variables in \(\mathit{pt}\) which are defined as type parameters of a method enclosing the pattern. Let the set of such type parameters be \(b_1 , \ldots , b_m\). Let \(\mathcal{C}&#39;_0\) be the subtype constraints reflecting the bounds of the type variables \(b_i\). If \(T\) denotes an instance type of a final class, let \(\mathcal{C}_2\) be the weakest set of subtype constraints over the type variables \(a_1 , \ldots , a_n\) and \(b_1 , \ldots , b_m\) such that \(\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2\) implies that \(T\) conforms to \(\mathit{pt}\). If \(T\) does not denote an instance type of a final class, let \(\mathcal{C}_2\) be the weakest set of subtype constraints over the type variables \(a_1 , \ldots , a_n\) and \(b_1 , \ldots , b_m\) such that \(\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2\) implies that it is possible to construct a type \(T&#39;\) which conforms to both \(T\) and \(\mathit{pt}\). It is a static error if there is no satisfiable set of constraints \(\mathcal{C}_2\) with this property.</p>
<p>The final step consists in choosing type bounds for the type variables which imply the established constraint system. The process is different for the two cases above.</p>
<p>Case 1: <br>We take \(a_i &gt;: L_i &lt;: U_i\) where each \(L_i\) is minimal and each \(U_i\) is maximal wrt \(&lt;:\) such that \(a_i &gt;: L_i &lt;: U_i\) for \(i = 1 , \ldots , n\) implies \(\mathcal{C}_0 \wedge \mathcal{C}_1\).</p>
<p>Case 2: <br>We take \(a_i &gt;: L_i &lt;: U_i\) and \(b_i &gt;: L&#39;_i &lt;: U&#39;_i\) where each \(L_i\) and \(L&#39;_j\) is minimal and each \(U_i\) and \(U&#39;_j\) is maximal such that \(a_i &gt;: L_i &lt;: U_i\) for \(i = 1 , \ldots , n\) and \(b_j &gt;: L&#39;_j &lt;: U&#39;_j\) for \(j = 1 , \ldots , m\) implies \(\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2\).</p>
<p>In both cases, local type inference is permitted to limit the complexity of inferred bounds. Minimality and maximality of types have to be understood relative to the set of types of acceptable complexity.</p>
<p>Type parameter inference for constructor patterns. <br>Assume a constructor pattern \(C(p_1 , \ldots , p_n)\) where class \(C\) has type type parameters \(a_1 , \ldots , a_n\). These type parameters are inferred in the same way as for the typed pattern <code>(_: $C[a_1 , \ldots , a_n]$)</code>.</p>
<ol start="79" type="1">
<li><p>Consider the program fragment:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: Any
x <span class="kw">match</span> {
  <span class="kw">case</span> y: List[a] =&gt; ...
}</code></pre>
<p>Here, the type pattern <code>List[a]</code> is matched against the expected type <code>Any</code>. The pattern binds the type variable <code>a</code>. Since <code>List[a]</code> conforms to <code>Any</code> for every type argument, there are no constraints on <code>a</code>. Hence, <code>a</code> is introduced as an abstract type with no bounds. The scope of <code>a</code> is right-hand side of its case clause.</p>
<p>On the other hand, if <code>x</code> is declared as</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: List[List[String]],</code></pre>
<p>this generates the constraint <code>List[a] &lt;: List[List[String]]</code>, which simplifies to <code>a &lt;: List[String]</code>, because <code>List</code> is covariant. Hence, <code>a</code> is introduced with upper bound <code>List[String]</code>.</p></li>
<li><p>Consider the program fragment:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: Any
x <span class="kw">match</span> {
  <span class="kw">case</span> y: List[String] =&gt; ...
}</code></pre>
<p>Scala does not maintain information about type arguments at run-time, so there is no way to check that <code>x</code> is a list of strings. Instead, the Scala compiler will <a href="#type-erasure">erase</a> the pattern to <code>List[_]</code>; that is, it will only test whether the top-level runtime-class of the value <code>x</code> conforms to <code>List</code>, and the pattern match will succeed if it does. This might lead to a class cast exception later on, in the case where the list <code>x</code> contains elements other than strings. The Scala compiler will flag this potential loss of type-safety with an ``unchecked'' warning message.</p></li>
<li><p>Consider the program fragment</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Term[A]
<span class="kw">class</span> Number(<span class="kw">val</span> n: Int) <span class="kw">extends</span> Term[Int]
<span class="kw">def</span> f[B](t: Term[B]): B = t <span class="kw">match</span> {
  <span class="kw">case</span> y: Number =&gt; y.<span class="fu">n</span>
}</code></pre>
<p>The expected type of the pattern <code>y: Number</code> is <code>Term[B]</code>. The type <code>Number</code> does not conform to <code>Term[B]</code>; hence Case 2 of the rules above applies. This means that <code>b</code> is treated as another type variable for which subtype constraints are inferred. In our case the applicable constraint is <code>Number &lt;: Term[B]</code>, which entails <code>B = Int</code>. Hence, <code>B</code> is treated in the case clause as an abstract type with lower and upper bound <code>Int</code>. Therefore, the right hand side of the case clause, <code>y.n</code>, of type <code>Int</code>, is found to conform to the function's declared result type, <code>Number</code>.</p></li>
</ol>
<h2 id="pattern-matching-expressions"><a href="#TOC"><span class="header-section-number">8.4</span> Pattern Matching Expressions</a></h2>
<pre class="grammar"><code>  Expr            ::=  PostfixExpr `match&#39; `{&#39; CaseClauses `}&#39;
  CaseClauses     ::=  CaseClause {CaseClause}
  CaseClause      ::=  `case&#39; Pattern [Guard] `=&gt;&#39; Block</code></pre>
<p>A pattern matching expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala">e <span class="kw">match</span> { <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ }</code></pre>
<p>consists of a selector expression \(e\) and a number \(n &gt; 0\) of cases. Each case consists of a (possibly guarded) pattern \(p_i\) and a block \(b_i\). Each \(p_i\) might be complemented by a guard <code>if $e$</code> where \(e\) is a boolean expression. The scope of the pattern variables in \(p_i\) comprises the pattern's guard and the corresponding block \(b_i\).</p>
<p>Let \(T\) be the type of the selector expression \(e\) and let \(a_1 , \ldots , a_m\) be the type parameters of all methods enclosing the pattern matching expression. For every \(a_i\), let \(L_i\) be its lower bound and \(U_i\) be its higher bound. Every pattern \(p \in \{p_1, , \ldots , p_n\}\) can be typed in two ways. First, it is attempted to type \(p\) with \(T\) as its expected type. If this fails, \(p\) is instead typed with a modified expected type \(T&#39;\) which results from \(T\) by replacing every occurrence of a type parameter \(a_i\) by . If this second step fails also, a compile-time error results. If the second step succeeds, let \(T_p\) be the type of pattern \(p\) seen as an expression. One then determines minimal bounds \(L&#39;_1 , \ldots , L&#39;_m\) and maximal bounds \(U&#39;_1 , \ldots , U&#39;_m\) such that for all \(i\), \(L_i &lt;: L&#39;_i\) and \(U&#39;_i &lt;: U_i\) and the following constraint system is satisfied:</p>
<p>\[L_1 &lt;: a_1 &lt;: U_1\;\wedge\;\ldots\;\wedge\;L_m &lt;: a_m &lt;: U_m \ \Rightarrow\ T_p &lt;: T\]</p>
<p>If no such bounds can be found, a compile time error results. If such bounds are found, the pattern matching clause starting with \(p\) is then typed under the assumption that each \(a_i\) has lower bound \(L&#39;_i\) instead of \(L_i\) and has upper bound \(U&#39;_i\) instead of \(U_i\).</p>
<p>The expected type of every block \(b_i\) is the expected type of the whole pattern matching expression. The type of the pattern matching expression is then the <a href="#weak-conformance">weak least upper bound</a> of the types of all blocks \(b_i\).</p>
<p>When applying a pattern matching expression to a selector value, patterns are tried in sequence until one is found which matches the <a href="#patterns">selector value</a>. Say this case is \(\mathbf{case} p_i \Rightarrow b_i\). The result of the whole expression is then the result of evaluating \(b_i\), where all pattern variables of \(p_i\) are bound to the corresponding parts of the selector value. If no matching pattern is found, a <code>scala.MatchError</code> exception is thrown.</p>
<p>The pattern in a case may also be followed by a guard suffix <br><code>if e</code>Â with a boolean expression \(e\). The guard expression is evaluated if the preceding pattern in the case matches. If the guard expression evaluates to <code>true</code>, the pattern match succeeds as normal. If the guard expression evaluates to <code>false</code>, the pattern in the case is considered not to match and the search for a matching pattern continues.</p>
<p>In the interest of efficiency the evaluation of a pattern matching expression may try patterns in some other order than textual sequence. This might affect evaluation through side effects in guards. However, it is guaranteed that a guard expression is evaluated only if the pattern it guards matches.</p>
<p>If the selector of a pattern match is an instance of a <a href="#modifiers"><code>sealed</code> class</a>, the compilation of pattern matching can emit warnings which diagnose that a given set of patterns is not exhaustive, i.e.Â that there is a possibility of a <code>MatchError</code> being raised at run-time.</p>
<ol start="82" type="1">
<li><p>Consider the following definitions of arithmetic terms:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Term[T]
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Lit</span>(x: Int) <span class="kw">extends</span> Term[Int]
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Succ</span>(t: Term[Int]) <span class="kw">extends</span> Term[Int]
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">IsZero</span>(t: Term[Int]) <span class="kw">extends</span> Term[Boolean]
<span class="kw">case</span> <span class="kw">class</span> If[T](c: Term[Boolean],
                 t1: Term[T],
                 t2: Term[T]) <span class="kw">extends</span> Term[T]</code></pre>
<p>There are terms to represent numeric literals, incrementation, a zero test, and a conditional. Every term carries as a type parameter the type of the expression it representes (either <code>Int</code> or <code>Boolean</code>).</p>
<p>A type-safe evaluator for such terms can be written as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> eval[T](t: Term[T]): T = t <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Lit</span>(n)        =&gt; n
  <span class="kw">case</span> <span class="fu">Succ</span>(u)       =&gt; <span class="fu">eval</span>(u) + <span class="dv">1</span>
  <span class="kw">case</span> <span class="fu">IsZero</span>(u)     =&gt; <span class="fu">eval</span>(u) == <span class="dv">0</span>
  <span class="kw">case</span> <span class="fu">If</span>(c, u1, u2) =&gt; <span class="fu">eval</span>(<span class="kw">if</span> (<span class="fu">eval</span>(c)) u1 <span class="kw">else</span> u2)
}</code></pre>
<p>Note that the evaluator makes crucial use of the fact that type parameters of enclosing methods can acquire new bounds through pattern matching.</p>
<p>For instance, the type of the pattern in the second case, <code>Succ(u)</code>, is <code>Int</code>. It conforms to the selector type <code>T</code> only if we assume an upper and lower bound of <code>Int</code> for <code>T</code>. Under the assumption <code>Int &lt;: T &lt;: Int</code> we can also verify that the type right hand side of the second case, <code>Int</code> conforms to its expected type, <code>T</code>.</p></li>
</ol>
<h2 id="pattern-matching-anonymous-functions"><a href="#TOC"><span class="header-section-number">8.5</span> Pattern Matching Anonymous Functions</a></h2>
<pre class="grammar"><code>  BlockExpr ::= `{&#39; CaseClauses `}&#39;</code></pre>
<p>An anonymous function can be defined by a sequence of cases</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ }</code></pre>
<p>which appear as an expression without a prior <code>match</code>. The expected type of such an expression must in part be defined. It must be either <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code> for some \(k &gt; 0\), or <code>scala.PartialFunction[$S_1$, $R$]</code>, where the argument type(s) \(S_1 , \ldots , S_k\) must be fully determined, but the result type \(R\) may be undetermined.</p>
<p>If the expected type is <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code>, the expression is taken to be equivalent to the anonymous function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">($x_1: S_1 , \ldots , x_k: S_k$) =&gt; ($x_1 , \ldots , x_k$) <span class="kw">match</span> { 
  <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ 
}</code></pre>
<p>Here, each \(x_i\) is a fresh name. As was shown <a href="#anonymous-functions">here</a>, this anonymous function is in turn equivalent to the following instance creation expression, where \(T\) is the weak least upper bound of the types of all \(b_i\).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> scala.<span class="fu">Function</span>$k$[$S_1 , \ldots , S_k$, $T$] {
  <span class="kw">def</span> <span class="fu">apply</span>($x_1: S_1 , \ldots , x_k: S_k$): $T$ = ($x_1 , \ldots , x_k$) <span class="kw">match</span> {
    <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$
  }
}</code></pre>
<p>If the expected type is <code>scala.PartialFunction[$S$, $R$]</code>, the expression is taken to be equivalent to the following instance creation expression:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> scala.<span class="fu">PartialFunction</span>[$S$, $T$] {
  <span class="kw">def</span> <span class="fu">apply</span>($x$: $S$): $T$ = x <span class="kw">match</span> {
    <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$
  }
  <span class="kw">def</span> <span class="fu">isDefinedAt</span>($x$: $S$): Boolean = {
    <span class="kw">case</span> $p_1$ =&gt; <span class="kw">true</span> $\ldots$ <span class="kw">case</span> $p_n$ =&gt; <span class="kw">true</span>
    <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
  }
}</code></pre>
<p>Here, \(x\) is a fresh name and \(T\) is the weak least upper bound of the types of all \(b_i\). The final default case in the <code>isDefinedAt</code> method is omitted if one of the patterns \(p_1 , \ldots , p_n\) is already a variable or wildcard pattern.</p>
<ol start="83" type="1">
<li><p>Here is a method which uses a fold-left operation <code>/:</code> to compute the scalar product of two vectors:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">scalarProduct</span>(xs: Array[Double], ys: Array[Double]) = 
  (<span class="fl">0.0</span> /: (xs zip ys)) {
    <span class="kw">case</span> (a, (b, c)) =&gt; a + b * c
  }</code></pre>
<p>The case clauses in this code are equivalent to the following anonymous function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  (x, y) =&gt; (x, y) <span class="kw">match</span> {
    <span class="kw">case</span> (a, (b, c)) =&gt; a + b * c
  }</code></pre></li>
</ol>
<h1 id="top-level-definitions"><a href="#TOC"><span class="header-section-number">9</span> Top-Level Definitions</a></h1>
<h2 id="compilation-units"><a href="#TOC"><span class="header-section-number">9.1</span> Compilation Units</a></h2>
<pre class="grammar"><code>CompilationUnit  ::=  {âpackageâ QualId semi} TopStatSeq
TopStatSeq       ::=  TopStat {semi TopStat}
TopStat          ::=  {Annotation} {Modifier} TmplDef
                   |  Import
                   |  Packaging
                   |  PackageObject
                   |
QualId           ::=  id {â.â id}</code></pre>
<p>A compilation unit consists of a sequence of packagings, import clauses, and class and object definitions, which may be preceded by a package clause.</p>
<p>A compilation unit</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> $p_1$;
$\ldots$
<span class="kw">package</span> $p_n$;
$\mathit{stats}$</code></pre>
<p>starting with one or more package clauses is equivalent to a compilation unit consisting of the packaging</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> $p_1$ { $\ldots$
  <span class="kw">package</span> $p_n$ {
    $\mathit{stats}$
  } $\ldots$
}</code></pre>
<p>Implicitly imported into every compilation unit are, in that order : the package <code>java.lang</code>, the package <code>scala</code>, and the object <a href="#the-predef-object"><code>scala.Predef</code></a>. Members of a later import in that order hide members of an earlier import.</p>
<h2 id="packagings"><a href="#TOC"><span class="header-section-number">9.2</span> Packagings</a></h2>
<pre class="grammar"><code>Packaging       ::=  âpackageâ QualId [nl] â{â TopStatSeq â}â</code></pre>
<p>A package is a special object which defines a set of member classes, objects and packages. Unlike other objects, packages are not introduced by a definition. Instead, the set of members of a package is determined by packagings.</p>
<p>A packaging <code class="sourceCode scala"><span class="kw">package</span> $p$ { $\mathit{ds}$ }</code> injects all definitions in \(\mathit{ds}\) as members into the package whose qualified name is \(p\). Members of a package are called <em>top-level</em> definitions. If a definition in \(\mathit{ds}\) is labeled <code class="sourceCode scala"><span class="kw">private</span></code>, it is visible only for other members in the package.</p>
<p>Inside the packaging, all members of package \(p\) are visible under their simple names. However this rule does not extend to members of enclosing packages of \(p\) that are designated by a prefix of the path \(p\).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> org.<span class="fu">net</span>.<span class="fu">prj</span> {
  ...
}</code></pre>
<p>all members of package <code>org.net.prj</code> are visible under their simple names, but members of packages <code>org</code> or <code>org.net</code> require explicit qualification or imports.</p>
<p>Selections \(p\).\(m\) from \(p\) as well as imports from \(p\) work as for objects. However, unlike other objects, packages may not be used as values. It is illegal to have a package with the same fully qualified name as a module or a class.</p>
<p>Top-level definitions outside a packaging are assumed to be injected into a special empty package. That package cannot be named and therefore cannot be imported. However, members of the empty package are visible to each other without qualification.</p>
<h2 id="package-objects"><a href="#TOC"><span class="header-section-number">9.3</span> Package Objects</a></h2>
<pre class="grammar"><code>PackageObject   ::=  âpackageâ âobjectâ ObjectDef</code></pre>
<p>A package object <code>package object $p$ extends $t$</code> adds the members of template \(t\) to the package \(p\). There can be only one package object per package. The standard naming convention is to place the definition above in a file named <code>package.scala</code> that's located in the directory corresponding to package \(p\).</p>
<p>The package object should not define a member with the same name as one of the top-level objects or classes defined in package \(p\). If there is a name conflict, the behavior of the program is currently undefined. It is expected that this restriction will be lifted in a future version of Scala.</p>
<h2 id="package-references"><a href="#TOC"><span class="header-section-number">9.4</span> Package References</a></h2>
<pre class="grammar"><code>QualId           ::=  id {â.â id}</code></pre>
<p>A reference to a package takes the form of a qualified identifier. Like all other references, package references are relative. That is, a package reference starting in a name \(p\) will be looked up in the closest enclosing scope that defines a member named \(p\).</p>
<p>The special predefined name <code>_root_</code> refers to the outermost root package which contains all top-level packages.</p>
<ol start="84" type="1">
<li><p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> b {
  <span class="kw">class</span> B 
}

<span class="kw">package</span> a.<span class="fu">b</span> {
  <span class="kw">class</span> A {
    <span class="kw">val</span> x = <span class="kw">new</span> _root_.<span class="fu">b</span>.<span class="fu">B</span>
  }
}</code></pre>
<p>Here, the reference <code>_root_.b.B</code> refers to class <code>B</code> in the toplevel package <code>b</code>. If the <code>_root_</code> prefix had been omitted, the name <code>b</code> would instead resolve to the package <code>a.b</code>, and, provided that package does not also contain a class <code>B</code>, a compiler-time error would result.</p></li>
</ol>
<h2 id="programs"><a href="#TOC"><span class="header-section-number">9.5</span> Programs</a></h2>
<p>A <em>program</em> is a top-level object that has a member method <em>main</em> of type <code>(Array[String])Unit</code>. Programs can be executed from a command shell. The program's command arguments are are passed to the <code>main</code> method as a parameter of type <code>Array[String]</code>.</p>
<p>The <code>main</code> method of a program can be directly defined in the object, or it can be inherited. The scala library defines a class <code>scala.Application</code> that defines an empty inherited <code>main</code> method. An objects \(m\) inheriting from this class is thus a program, which executes the initializaton code of the object \(m\).</p>
<ol start="85" type="1">
<li><p>The following example will create a hello world program by defining a method <code>main</code> in module <code>test.HelloWorld</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> test
<span class="kw">object</span> HelloWord {
  <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) { <span class="fu">println</span>(<span class="st">&quot;hello world&quot;</span>) }
}</code></pre>
<p>This program can be started by the command ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scala test.HelloWorld ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>In a Java environment, the command</p>
<pre><code>java test.HelloWorld</code></pre>
<p>would work as well.</p>
<p><code>HelloWorld</code> can also be defined without a <code>main</code> method by inheriting from <code>Application</code> instead:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> test 
<span class="kw">object</span> HelloWord <span class="kw">extends</span> Application {
  <span class="fu">println</span>(<span class="st">&quot;hello world&quot;</span>)
}</code></pre></li>
</ol>
<h1 id="xml-expressions-and-patterns"><a href="#TOC"><span class="header-section-number">10</span> XML Expressions and Patterns</a></h1>
<p><strong>By Burak Emir</strong> <br> This chapter describes the syntactic structure of XML expressions and patterns. It follows as closely as possible the XML 1.0 specification , changes being mandated by the possibility of embedding Scala code fragments.</p>
<h2 id="xml-expressions"><a href="#TOC"><span class="header-section-number">10.1</span> XML expressions</a></h2>
<p>XML expressions are expressions generated by the following production, where the opening bracket `&lt;' of the first element must be in a position to start the lexical <a href="#xml-mode">XML mode</a>.</p>
<pre class="grammar"><code>XmlExpr ::= XmlContent {Element}</code></pre>
<p>Well-formedness constraints of the XML specification apply, which means for instance that start tags and end tags must match, and attributes may only be defined once, with the exception of constraints related to entity resolution.</p>
<p>The following productions describe Scala's extensible markup language, designed as close as possible to the W3C extensible markup language standard. Only the productions for attribute values and character data are changed. Scala does not support declarations, CDATA sections or processing instructions. Entity references are not resolved at runtime.</p>
<pre class="grammar"><code>Element       ::=    EmptyElemTag
                |    STag Content ETag                                       

EmptyElemTag  ::=    â&lt;â Name {S Attribute} [S] â/&gt;â                         

STag          ::=    â&lt;â Name {S Attribute} [S] â&gt;â                          
ETag          ::=    â&lt;/â Name [S] â&gt;â                                        
Content       ::=    [CharData] {Content1 [CharData]}
Content1      ::=    XmlContent
                |    Reference
                |    ScalaExpr
XmlContent    ::=    Element
                |    CDSect
                |    PI
                |    Comment</code></pre>
<p>If an XML expression is a single element, its value is a runtime representation of an XML node (an instance of a subclass of <code>scala.xml.Node</code>). If the XML expression consists of more than one element, then its value is a runtime representation of a sequence of XML nodes (an instance of a subclass of <code>scala.Seq[scala.xml.Node]</code>).</p>
<p>If an XML expression is an entity reference, CDATA section, processing instructions or a comments, it is represented by an instance of the corresponding Scala runtime class.</p>
<p>By default, beginning and trailing whitespace in element content is removed, and consecutive occurrences of whitespace are replaced by a single space character \u0020. This behavior can be changed to preserve all whitespace with a compiler option.</p>
<pre class="grammar"><code>Attribute  ::=    Name Eq AttValue                                    

AttValue      ::=    â&quot;â {CharQ | CharRef} â&quot;â
                |    â&#39;â {CharA | CharRef} â&#39;â
                |    ScalaExpr

ScalaExpr     ::=    Block

CharData      ::=   { CharNoRef } $\mbox{\rm\em without}$ {CharNoRef}`{&#39;CharB {CharNoRef} 
                                  $\mbox{\rm\em and without}$ {CharNoRef}`]]&gt;&#39;{CharNoRef}</code></pre>
<p>XML expressions may contain Scala expressions as attribute values or within nodes. In the latter case, these are embedded using a single opening brace â{â and ended by a closing brace â}â. To express a single opening braces within XML text as generated by CharData, it must be doubled. Thus, â{{â represents the XML text â{â and does not introduce an embedded Scala expression.</p>
<pre class="grammar"><code>BaseChar, Char, Comment, CombiningChar, Ideographic, NameChar, S, Reference
              ::=  $\mbox{\rm\em âas in W3C XMLâ}$

Char1         ::=  Char $\mbox{\rm\em without}$ â&lt;â | â&amp;â
CharQ         ::=  Char1 $\mbox{\rm\em without}$ â&quot;â
CharA         ::=  Char1 $\mbox{\rm\em without}$ â&#39;â
CharB         ::=  Char1 $\mbox{\rm\em without}$ â{â

Name          ::=  XNameStart {NameChar}

XNameStart    ::= â_â | BaseChar | Ideographic 
                 $\mbox{\rm\em (as in W3C XML, but without }$ â:â
</code></pre>
<h2 id="xml-patterns-1"><a href="#TOC"><span class="header-section-number">10.2</span> XML patterns</a></h2>
<p>XML patterns are patterns generated by the following production, where the opening bracket â&lt;â of the element patterns must be in a position to start the lexical <a href="#xml-mode">XML mode</a>.</p>
<pre class="grammar"><code>XmlPattern  ::= ElementPattern </code></pre>
<p>Well-formedness constraints of the XML specification apply.</p>
<p>An XML pattern has to be a single element pattern. It matches exactly those runtime representations of an XML tree that have the same structure as described by the pattern. XML patterns may contain <a href="#pattern-matching-expressions">Scala patterns</a>.</p>
<p>Whitespace is treated the same way as in XML expressions. Patterns that are entity references, CDATA sections, processing instructions and comments match runtime representations which are the the same.</p>
<p>By default, beginning and trailing whitespace in element content is removed, and consecutive occurrences of whitespace are replaced by a single space character \u0020. This behavior can be changed to preserve all whitespace with a compiler option.</p>
<pre class="grammar"><code>ElemPattern   ::=    EmptyElemTagP
                |    STagP ContentP ETagP                                    

EmptyElemTagP ::=    â&lt;â  Name [S] â/&gt;â
STagP         ::=    â&lt;â  Name [S] â&gt;â                          
ETagP         ::=    â&lt;/â Name [S] â&gt;â                                        
ContentP      ::=    [CharData] {(ElemPattern|ScalaPatterns) [CharData]}
ContentP1     ::=    ElemPattern
                |    Reference
                |    CDSect
                |    PI
                |    Comment
                |    ScalaPatterns
ScalaPatterns ::=    â{â Patterns â}â</code></pre>
<h1 id="user-defined-annotations"><a href="#TOC"><span class="header-section-number">11</span> User-Defined Annotations</a></h1>
<pre class="grammar"><code>  Annotation       ::=  â@â SimpleType {ArgumentExprs}
  ConstrAnnotation ::=  â@â SimpleType ArgumentExprs</code></pre>
<p>User-defined annotations associate meta-information with definitions. A simple annotation has the form <code>@$c$</code> or <code>@$c(a_1 , \ldots , a_n)$</code>. Here, \(c\) is a constructor of a class \(C\), which must conform to the class <code>scala.Annotation</code>.</p>
<p>Annotations may apply to definitions or declarations, types, or expressions. An annotation of a definition or declaration appears in front of that definition. An annotation of a type appears after that type. An annotation of an expression \(e\) appears after the expression \(e\), separated by a colon. More than one annotation clause may apply to an entity. The order in which these annotations are given does not matter.</p>
<p>Examples:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">@serializable <span class="kw">class</span> C { ... }         <span class="co">// A class annotation.</span>
@transient @volatile <span class="kw">var</span> m: Int       <span class="co">// A variable annotation</span>
String @local                         <span class="co">// A type annotation</span>
(e: @unchecked) <span class="kw">match</span> { ... }         <span class="co">// An expression annotation</span></code></pre>
<p>The meaning of annotation clauses is implementation-dependent. On the Java platform, the following annotations have a standard meaning.</p>
<ul>
<li><p><code>@transient</code> <br> Marks a field to be non-persistent; this is equivalent to the <code>transient</code> modifier in Java.</p></li>
<li><p><code>@volatile</code> <br> Marks a field which can change its value outside the control of the program; this is equivalent to the <code>volatile</code> modifier in Java.</p></li>
<li><p><code>@serializable</code> <br> Marks a class to be serializable; this is equivalent to inheriting from the <code>java.io.Serializable</code> interface in Java.</p></li>
<li><p><code>@SerialVersionUID(&lt;longlit&gt;)</code> <br> Attaches a serial version identifier (a <code>long</code> constant) to a class. This is equivalent to a the following field definition in Java:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">private</span> <span class="kw">final</span> static SerialVersionUID = &lt;longlit&gt; </code></pre></li>
<li><p><code>@throws(&lt;classlit&gt;)</code> <br> A Java compiler checks that a program contains handlers for checked exceptions by analyzing which checked exceptions can result from execution of a method or constructor. For each checked exception which is a possible result, the <code>throws</code> clause for the method or constructor must mention the class of that exception or one of the superclasses of the class of that exception.</p></li>
<li><p><code>@deprecated(&lt;stringlit&gt;)</code> <br> Marks a definition as deprecated. Accesses to the defined entity will then cause a deprecated warning mentioning the message <code>&lt;stringlit&gt;</code> to be issued from the compiler. Deprecated warnings are suppressed in code that belongs itself to a definition that is labeled deprecated.</p></li>
<li><p><code>@scala.reflect.BeanProperty</code> <br> When prefixed to a definition of some variable <code>X</code>, this annotation causes getter and setter methods <code>getX</code>, <code>setX</code> in the Java bean style to be added in the class containing the variable. The first letter of the variable appears capitalized after the <code>get</code> or <code>set</code>. When the annotation is added to the definition of an immutable value definition <code>X</code>, only a getter is generated. The construction of these methods is part of code-generation; therefore, these methods become visible only once a classfile for the containing class is generated.</p></li>
<li><p><code>@scala.reflect.BooleanBeanProperty</code> <br> This annotation is equivalent to <code>scala.reflect.BeanProperty</code>, but the generated getter method is named <code>isX</code> instead of <code>getX</code>.</p></li>
<li><p><code>@unchecked</code> <br> When applied to the selector of a  expression, this attribute suppresses any warnings about non-exhaustive pattern matches which would otherwise be emitted. For instance, no warnings would be produced for the method definition below.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: Option[Int]) = (x: @unchecked) <span class="kw">match</span> {
  <span class="kw">case</span> Some(y) =&gt; y
}</code></pre>
<p>Without the <code>@unchecked</code> annotation, a Scala compiler could infer that the pattern match is non-exhaustive, and could produce a warning because <code>Option</code> is a <code>sealed</code> class.</p></li>
<li><p><code>@uncheckedStable</code> <br> When applied a value declaration or definition, it allows the defined value to appear in a path, even if its type is <a href="#volatile-types">volatile</a>. For instance, the following member definitions are legal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> A { <span class="kw">type</span> T }
<span class="kw">type</span> B 
@uncheckedStable <span class="kw">val</span> x: A <span class="kw">with</span> B <span class="co">// volatile type </span>
<span class="kw">val</span> y: x.<span class="fu">T</span>                       <span class="co">// OK since `x&#39; is still a path</span></code></pre>
<p>Without the <code>@uncheckedStable</code> annotation, the designator <code>x</code> would not be a path since its type <code>A with B</code> is volatile. Hence, the reference <code>x.T</code> would be malformed.</p>
<p>When applied to value declarations or definitions that have non-volatile types, the annotation has no effect.</p></li>
<li><p><code>@specialized</code> <br> When applied to the definition of a type parameter, this annotation causes the compiler to generate specialized definitions for primitive types. An optional list of primitive types may be given, in which case specialization takes into account only those types. For instance, the following code would generate specialized traits for <code>Unit</code>, <code>Int</code> and <code>Double</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Function0[@<span class="fu">specialized</span>(Unit, Int, Double) T] {
  <span class="kw">def</span> apply: T
}</code></pre>
<p>Whenever the static type of an expression matches a specialized variant of a definition, the compiler will instead use the specialized version. See  for more details of the implementation.</p></li>
</ul>
<p>Other annotations may be interpreted by platform- or application-dependent tools. Class <code>scala.Annotation</code> has two sub-traits which are used to indicate how these annotations are retained. Instances of an annotation class inheriting from trait <code>scala.ClassfileAnnotation</code> will be stored in the generated class files. Instances of an annotation class inheriting from trait <code>scala.StaticAnnotation</code> will be visible to the Scala type-checker in every compilation unit where the annotated symbol is accessed. An annotation class can inherit from both <code>scala.ClassfileAnnotation</code> and <code>scala.StaticAnnotation</code>. If an annotation class inherits from neither <code>scala.ClassfileAnnotation</code> nor <code>scala.StaticAnnotation</code>, its instances are visible only locally during the compilation run that analyzes them.</p>
<p>Classes inheriting from <code>scala.ClassfileAnnotation</code> may be subject to further restrictions in order to assure that they can be mapped to the host environment. In particular, on both the Java and the .NET platforms, such classes must be toplevel; i.e.Â they may not be contained in another class or object. Additionally, on both Java and .NET, all constructor arguments must be constant expressions.</p>
<h1 id="the-scala-standard-library"><a href="#TOC"><span class="header-section-number">12</span> The Scala Standard Library</a></h1>
<p>The Scala standard library consists of the package <code>scala</code> with a number of classes and modules. Some of these classes are described in the following.</p>
<figure>
<embed src="classhierarchy.pdf"><figcaption>Class hierarchy of Scala</figcaption>
</figure>
<h2 id="root-classes"><a href="#TOC"><span class="header-section-number">12.1</span> Root Classes</a></h2>
<p>Figure~ illustrates Scala's class hierarchy. The root of this hierarchy is formed by class <code>Any</code>. Every class in a Scala execution environment inherits directly or indirectly from this class. Class <code>Any</code> has two direct subclasses: <code>AnyRef</code> and AnyVal`.</p>
<p>The subclass <code>AnyRef</code> represents all values which are represented as objects in the underlying host system. Every user-defined Scala class inherits directly or indirectly from this class. Furthermore, every user-defined Scala class also inherits the trait <code>scala.ScalaObject</code>. Classes written in other languages still inherit from <code>scala.AnyRef</code>, but not from <code>scala.ScalaObject</code>.</p>
<p>The class <code>AnyVal</code> has a fixed number of subclasses, which describe values which are not implemented as objects in the underlying host system.</p>
<p>Classes <code>AnyRef</code> and <code>AnyVal</code> are required to provide only the members declared in class <code>Any</code>, but implementations may add host-specific methods to these classes (for instance, an implementation may identify class <code>AnyRef</code> with its own root class for objects).</p>
<p>The signatures of these root classes are described by the following definitions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="co">/** The universal root class */</span>
<span class="kw">abstract</span> <span class="kw">class</span> Any {

  <span class="co">/** Defined equality</span>;<span class="co"> abstract here */</span>
  <span class="kw">def</span> <span class="fu">equals</span>(that: Any): Boolean 

  <span class="co">/** Semantic equality between values */</span>
  <span class="kw">final</span> <span class="kw">def</span> == (that: Any): Boolean  =  
    <span class="kw">if</span> (<span class="kw">null</span> eq <span class="kw">this</span>) <span class="kw">null</span> eq that <span class="kw">else</span> <span class="kw">this</span> equals that

  <span class="co">/** Semantic inequality between values */</span>
  <span class="kw">final</span> <span class="kw">def</span> != (that: Any): Boolean  =  !(<span class="kw">this</span> == that)

  <span class="co">/** Hash code</span>;<span class="co"> abstract here */</span>
  <span class="kw">def</span> hashCode: Int = $\ldots$

  <span class="co">/** Textual representation</span>;<span class="co"> abstract here */</span>
  <span class="kw">def</span> toString: String = $\ldots$

  <span class="co">/** Type test</span>;<span class="co"> needs to be inlined to work as given */</span>
  <span class="kw">def</span> isInstanceOf[a]: Boolean

  <span class="co">/** Type cast</span>;<span class="co"> needs to be inlined to work as given */</span> */
  <span class="kw">def</span> asInstanceOf[A]: A = <span class="kw">this</span> <span class="kw">match</span> {
    <span class="kw">case</span> x: A =&gt; x
    <span class="kw">case</span> _ =&gt; <span class="kw">if</span> (<span class="kw">this</span> eq <span class="kw">null</span>) <span class="kw">this</span>
              <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> ClassCastException()
  }
}

<span class="co">/** The root class of all value types */</span>
<span class="kw">final</span> <span class="kw">class</span> AnyVal <span class="kw">extends</span> Any 

<span class="co">/** The root class of all reference types */</span>
<span class="kw">class</span> AnyRef <span class="kw">extends</span> Any {
  <span class="kw">def</span> <span class="fu">equals</span>(that: Any): Boolean      = <span class="kw">this</span> eq that 
  <span class="kw">final</span> <span class="kw">def</span> <span class="fu">eq</span>(that: AnyRef): Boolean = $\ldots$ <span class="co">// reference equality</span>
  <span class="kw">final</span> <span class="kw">def</span> <span class="fu">ne</span>(that: AnyRef): Boolean = !(<span class="kw">this</span> eq that)

  <span class="kw">def</span> hashCode: Int = $\ldots$     <span class="co">// hashCode computed from allocation address</span>
  <span class="kw">def</span> toString: String  = $\ldots$ <span class="co">// toString computed from hashCode and class name</span>

  <span class="kw">def</span> synchronized[T](body: =&gt; T): T <span class="co">// execute `body` in while locking `this`.</span>
}                           

<span class="co">/** A mixin class for every user</span>-<span class="co">defined Scala class */</span>
<span class="kw">trait</span> ScalaObject <span class="kw">extends</span> AnyRef </code></pre>
<p>The type test <code>$x$.isInstanceOf[$T$]</code> is equivalent to a typed pattern match</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$x$ <span class="kw">match</span> {
  <span class="kw">case</span> _: $T&#39;$ =&gt; <span class="kw">true</span>
  <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
}</code></pre>
<p>where the type \(T&#39;\) is the same as \(T\) except if \(T\) is of the form \(D\) or \(D[\tps]\) where \(D\) is a type member of some outer class \(C\). In this case \(T&#39;\) is <code>$C$#$D$</code> (or <code>$C$#$D[tps]$</code>, respectively), whereas \(T\) itself would expand to <code>$C$.this.$D[tps]$</code>. In other words, an <code>isInstanceOf</code> test does not check for the</p>
<p>The test <code>$x$.asInstanceOf[$T$]</code> is treated specially if \(T\) is a <a href="#value-classes">numeric value type</a>. In this case the cast will be translated to an application of a <a href="#numeric-value-types">conversion method</a> <code>x.to$T$</code>. For non-numeric values \(x\) the operation will raise a <code>ClassCastException</code>.</p>
<h2 id="value-classes"><a href="#TOC"><span class="header-section-number">12.2</span> Value Classes</a></h2>
<p>Value classes are classes whose instances are not represented as objects by the underlying host system. All value classes inherit from class <code>AnyVal</code>. Scala implementations need to provide the value classes <code>Unit</code>, <code>Boolean</code>, <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Int</code>, <code>Char</code>, <code>Short</code>, and <code>Byte</code> (but are free to provide others as well). The signatures of these classes are defined in the following.</p>
<h3 id="numeric-value-types"><a href="#TOC"><span class="header-section-number">12.2.1</span> Numeric Value Types</a></h3>
<p>Classes <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Int</code>, <code>Char</code>, <code>Short</code>, and <code>Byte</code> are together called <em>numeric value types</em>. Classes <code>Byte</code>, <code>Short</code>, or <code>Char</code> are called <em>subrange types</em>. Subrange types, as well as <code>Int</code> and <code>Long</code> are called <em>integer types</em>, whereas <code>Float</code> and <code>Double</code> are called <em>floating point types</em>.</p>
<p>Numeric value types are ranked in the following partial order:</p>
<pre><code>Byte - Short 
             \
               Int - Long - Float - Double
             / 
        Char </code></pre>
<p><code>Byte</code> and <code>Short</code> are the lowest-ranked types in this order, whereas <code>Double</code> is the highest-ranked. Ranking does <em>not</em> imply a <a href="#conformance">conformance relationship</a>; for instance <code>Int</code> is not a subtype of <code>Long</code>. However, object <a href="#the-predef-object"><code>Predef</code></a> defines <a href="#views">views</a> from every numeric value type to all higher-ranked numeric value types. Therefore, lower-ranked types are implicitly converted to higher-ranked types when required by the <a href="#implicit-conversions">context</a>.</p>
<p>Given two numeric value types \(S\) and \(T\), the <em>operation type</em> of \(S\) and \(T\) is defined as follows: If both \(S\) and \(T\) are subrange types then the operation type of \(S\) and \(T\) is <code>Int</code>. Otherwise the operation type of \(S\) and \(T\) is the larger of the two types wrt ranking. Given two numeric values \(v\) and \(w\) the operation type of \(v\) and \(w\) is the operation type of their run-time types.</p>
<p>Any numeric value type \(T\) supports the following methods.</p>
<ul>
<li>Comparison methods for equals (<code>==</code>), not-equals (<code>!=</code>), less-than (<code>&lt;</code>), greater-than (<code>&gt;</code>), less-than-or-equals (<code>&lt;=</code>), greater-than-or-equals (<code>&gt;=</code>), which each exist in 7 overloaded alternatives. Each alternative takes a parameter of some numeric value type. Its result type is type <code>Boolean</code>. The operation is evaluated by converting the receiver and its argument to their operation type and performing the given comparison operation of that type.</li>
<li>Arithmetic methods addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and remainder (<code>%</code>), which each exist in 7 overloaded alternatives. Each alternative takes a parameter of some numeric value type \(U\). Its result type is the operation type of \(T\) and \(U\). The operation is evaluated by converting the receiver and its argument to their operation type and performing the given arithmetic operation of that type.</li>
<li>Parameterless arithmethic methods identity (<code>+</code>) and negation (<code>-</code>), with result type \(T\). The first of these returns the receiver unchanged, whereas the second returns its negation.</li>
<li>Conversion methods <code>toByte</code>, <code>toShort</code>, <code>toChar</code>, <code>toInt</code>, <code>toLong</code>, <code>toFloat</code>, <code>toDouble</code> which convert the receiver object to the target type, using the rules of Java's numeric type cast operation. The conversion might truncate the numeric value (as when going from <code>Long</code> to <code>Int</code> or from <code>Int</code> to <code>Byte</code>) or it might lose precision (as when going from <code>Double</code> to <code>Float</code> or when converting between <code>Long</code> and <code>Float</code>).</li>
</ul>
<p>Integer numeric value types support in addition the following operations:</p>
<ul>
<li><p>Bit manipulation methods bitwise-and (<code>&amp;</code>), bitwise-or {<code>|</code>}, and bitwise-exclusive-or (<code>^</code>), which each exist in 5 overloaded alternatives. Each alternative takes a parameter of some integer numeric value type. Its result type is the operation type of \(T\) and \(U\). The operation is evaluated by converting the receiver and its argument to their operation type and performing the given bitwise operation of that type.</p></li>
<li>A parameterless bit-negation method (<code>~</code>). Its result type is the reciver type \(T\) or <code>Int</code>, whichever is larger. The operation is evaluated by converting the receiver to the result type and negating every bit in its value.</li>
<li><p>Bit-shift methods left-shift (<code>&lt;&lt;</code>), arithmetic right-shift (<code>&gt;&gt;</code>), and unsigned right-shift (<code>&gt;&gt;&gt;</code>). Each of these methods has two overloaded alternatives, which take a parameter \(n\) of type <code>Int</code>, respectively <code>Long</code>. The result type of the operation is the receiver type \(T\), or <code>Int</code>, whichever is larger. The operation is evaluated by converting the receiver to the result type and performing the specified shift by \(n\) bits.</p></li>
</ul>
<p>Numeric value types also implement operations <code>equals</code>, <code>hashCode</code>, and <code>toString</code> from class <code>Any</code>.</p>
<p>The <code>equals</code> method tests whether the argument is a numeric value type. If this is true, it will perform the <code>==</code> operation which is appropriate for that type. That is, the <code>equals</code> method of a numeric value type can be thought of being defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">equals</span>(other: Any): Boolean = other <span class="kw">match</span> {
  <span class="kw">case</span> that: Byte   =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Short  =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Char   =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Int    =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Long   =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Float  =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Double =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
}</code></pre>
<p>The <code>hashCode</code> method returns an integer hashcode that maps equal numeric values to equal results. It is guaranteed to be the identity for for type <code>Int</code> and for all subrange types.</p>
<p>The <code>toString</code> method displays its receiver as an integer or floating point number.</p>
<ol start="86" type="1">
<li><p>As an example, here is the signature of the numeric value type <code>Int</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">abstract</span> <span class="kw">sealed</span> <span class="kw">class</span> Int <span class="kw">extends</span> AnyVal {
  <span class="kw">def</span> == (that: Double): Boolean  <span class="co">// double equality</span>
  <span class="kw">def</span> == (that: Float): Boolean   <span class="co">// float equality</span>
  <span class="kw">def</span> == (that: Long): Boolean    <span class="co">// long equality</span>
  <span class="kw">def</span> == (that: Int): Boolean     <span class="co">// int equality</span>
  <span class="kw">def</span> == (that: Short): Boolean   <span class="co">// int equality</span>
  <span class="kw">def</span> == (that: Byte): Boolean    <span class="co">// int equality</span>
  <span class="kw">def</span> == (that: Char): Boolean    <span class="co">// int equality</span>
  <span class="co">/* analogous for !=, &lt;, &gt;, &lt;=, &gt;= */</span>

  <span class="kw">def</span> + (that: Double): Double    <span class="co">// double addition</span>
  <span class="kw">def</span> + (that: Float): Double     <span class="co">// float addition</span>
  <span class="kw">def</span> + (that: Long): Long        <span class="co">// long addition</span>
  <span class="kw">def</span> + (that: Int): Int          <span class="co">// int addition</span>
  <span class="kw">def</span> + (that: Short): Int        <span class="co">// int addition</span>
  <span class="kw">def</span> + (that: Byte): Int         <span class="co">// int addition</span>
  <span class="kw">def</span> + (that: Char): Int         <span class="co">// int addition</span>
  <span class="co">/* analogous for -, *, /, % */</span>

  <span class="kw">def</span> &amp; (that: Long): Long        <span class="co">// long bitwise and</span>
  <span class="kw">def</span> &amp; (that: Int): Int          <span class="co">// int bitwise and</span>
  <span class="kw">def</span> &amp; (that: Short): Int        <span class="co">// int bitwise and</span>
  <span class="kw">def</span> &amp; (that: Byte): Int         <span class="co">// int bitwise and</span>
  <span class="kw">def</span> &amp; (that: Char): Int         <span class="co">// int bitwise and</span>
  <span class="co">/* analogous for |, ^ */</span>

  <span class="kw">def</span> &lt;&lt; (cnt: Int): Int          <span class="co">// int left shift</span>
  <span class="kw">def</span> &lt;&lt; (cnt: Long): Int         <span class="co">// long left shift</span>
  <span class="co">/* analogous for &gt;&gt;, &gt;&gt;&gt; */</span>

  <span class="kw">def</span> unary_+ : Int               <span class="co">// int identity</span>
  <span class="kw">def</span> unary_- : Int               <span class="co">// int negation</span>
  <span class="kw">def</span> unary_~ : Int               <span class="co">// int bitwise negation</span>

  <span class="kw">def</span> toByte: Byte                <span class="co">// convert to Byte</span>
  <span class="kw">def</span> toShort: Short              <span class="co">// convert to Short</span>
  <span class="kw">def</span> toChar: Char                <span class="co">// convert to Char</span>
  <span class="kw">def</span> toInt: Int                  <span class="co">// convert to Int</span>
  <span class="kw">def</span> toLong: Long                <span class="co">// convert to Long</span>
  <span class="kw">def</span> toFloat: Float              <span class="co">// convert to Float</span>
  <span class="kw">def</span> toDouble: Double            <span class="co">// convert to Double</span>
}</code></pre></li>
</ol>
<h3 id="class-boolean"><a href="#TOC"><span class="header-section-number">12.2.2</span> Class <code>Boolean</code></a></h3>
<p>Class <code>Boolean</code> has only two values: <code>true</code> and <code>false</code>. It implements operations as given in the following class definition.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">abstract</span> <span class="kw">sealed</span> <span class="kw">class</span> Boolean <span class="kw">extends</span> AnyVal {
  <span class="kw">def</span> &amp;&amp; (p: =&gt; Boolean): Boolean = <span class="co">// boolean and</span>
    <span class="kw">if</span> (<span class="kw">this</span>) p <span class="kw">else</span> <span class="kw">false</span>
  <span class="kw">def</span> || (p: =&gt; Boolean): Boolean = <span class="co">// boolean or</span>
    <span class="kw">if</span> (<span class="kw">this</span>) <span class="kw">true</span> <span class="kw">else</span> p
  <span class="kw">def</span> &amp;  (x: Boolean): Boolean =    <span class="co">// boolean strict and</span>
    <span class="kw">if</span> (<span class="kw">this</span>) x <span class="kw">else</span> <span class="kw">false</span>
  <span class="kw">def</span> |  (x: Boolean): Boolean =    <span class="co">// boolean strict or</span>
    <span class="kw">if</span> (<span class="kw">this</span>) <span class="kw">true</span> <span class="kw">else</span> x
  <span class="kw">def</span> == (x: Boolean): Boolean =    <span class="co">// boolean equality</span>
    <span class="kw">if</span> (<span class="kw">this</span>) x <span class="kw">else</span> x.<span class="fu">unary_</span>!
  <span class="kw">def</span> != (x: Boolean): Boolean =    <span class="co">// boolean inequality</span>
    <span class="kw">if</span> (<span class="kw">this</span>) x.<span class="fu">unary_</span>! <span class="kw">else</span> x
  <span class="kw">def</span> unary_!: Boolean =            <span class="co">// boolean negation</span>
    <span class="kw">if</span> (<span class="kw">this</span>) <span class="kw">false</span> <span class="kw">else</span> <span class="kw">true</span>
}</code></pre>
<p>The class also implements operations <code>equals</code>, <code>hashCode</code>, and <code>toString</code> from class <code>Any</code>.</p>
<p>The <code>equals</code> method returns <code>true</code> if the argument is the same boolean value as the receiver, <code>false</code> otherwise. The <code>hashCode</code> method returns a fixed, implementation-specific hash-code when invoked on <code>true</code>, and a different, fixed, implementation-specific hash-code when invoked on <code>false</code>. The <code>toString</code> method returns the receiver converted to a string, i.e.Â either <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>.</p>
<h3 id="class-unit"><a href="#TOC"><span class="header-section-number">12.2.3</span> Class <code>Unit</code></a></h3>
<p>Class <code>Unit</code> has only one value: <code>()</code>. It implements only the three methods <code>equals</code>, <code>hashCode</code>, and <code>toString</code> from class <code>Any</code>.</p>
<p>The <code>equals</code> method returns <code>true</code> if the argument is the unit value <code>()</code>, <code>false</code> otherwise. The <code>hashCode</code> method returns a fixed, implementation-specific hash-code, The <code>toString</code> method returns <code>&quot;()&quot;</code>.</p>
<h2 id="standard-reference-classes"><a href="#TOC"><span class="header-section-number">12.3</span> Standard Reference Classes</a></h2>
<p>This section presents some standard Scala reference classes which are treated in a special way in Scala compiler -- either Scala provides syntactic sugar for them, or the Scala compiler generates special code for their operations. Other classes in the standard Scala library are documented in the Scala library documentation by HTML pages.</p>
<h3 id="class-string"><a href="#TOC"><span class="header-section-number">12.3.1</span> Class <code>String</code></a></h3>
<p>Scala's <code>String</code> class is usually derived from the standard String class of the underlying host system (and may be identified with it). For Scala clients the class is taken to support in each case a method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> + (that: Any): String </code></pre>
<p>which concatenates its left operand with the textual representation of its right operand.</p>
<h3 id="the-tuple-classes"><a href="#TOC"><span class="header-section-number">12.3.2</span> The <code>Tuple</code> classes</a></h3>
<p>Scala defines tuple classes <code>Tuple$n$</code> for \(n = 2 , \ldots , 9\). These are defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">case</span> <span class="kw">class</span> Tuple$n$[+a_1, ..., +a_n](_1: a_1, ..., _$n$: a_$n$) {
  <span class="kw">def</span> toString = <span class="st">&quot;(&quot;</span> ++ _1 ++ <span class="st">&quot;,&quot;</span> ++ $\ldots$ ++ <span class="st">&quot;,&quot;</span> ++ _$n$ ++ <span class="st">&quot;)&quot;</span>
}</code></pre>
<p>The implicitly imported <a href="#the-predef-object"><code>Predef</code></a> object defines the names <code>Pair</code> as an alias of <code>Tuple2</code> and <code>Triple</code> as an alias for <code>Tuple3</code>.</p>
<h3 id="the-function-classes"><a href="#TOC"><span class="header-section-number">12.3.3</span> The <code>Function</code> Classes</a></h3>
<p>Scala defines function classes <code>Function$n$</code> for \(n = 1 , \ldots , 9\). These are defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">trait</span> Function$n$[-a_1, ..., -a_$n$, +b] {
  <span class="kw">def</span> <span class="fu">apply</span>(x_1: a_1, ..., x_$n$: a_$n$): b 
  <span class="kw">def</span> toString = <span class="st">&quot;&lt;function&gt;&quot;</span> 
}</code></pre>
<p>A subclass of <code>Function1</code> represents partial functions, which are undefined on some points in their domain. In addition to the <code>apply</code> method of functions, partial functions also have a <code>isDefined</code> method, which tells whether the function is defined at the given argument:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> PartialFunction[-A, +B] <span class="kw">extends</span> Function1[A, B] {
  <span class="kw">def</span> <span class="fu">isDefinedAt</span>(x: A): Boolean
}</code></pre>
<p>The implicitly imported <a href="#the-predef-object"><code>Predef</code></a> object defines the name <code>Function</code> as an alias of <code>Function1</code>.</p>
<h3 id="class-array"><a href="#TOC"><span class="header-section-number">12.3.4</span> Class <code>Array</code></a></h3>
<p>The class of generic arrays is given as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">class</span> Array[A](len: Int) <span class="kw">extends</span> Seq[A] {
  <span class="kw">def</span> length: Int = len
  <span class="kw">def</span> <span class="fu">apply</span>(i: Int): A = $\ldots$
  <span class="kw">def</span> <span class="fu">update</span>(i: Int, x: A): Unit = $\ldots$
  <span class="kw">def</span> elements: Iterator[A] = $\ldots$
  <span class="kw">def</span> <span class="fu">subArray</span>(from: Int, end: Int): Array[A] = $\ldots$
  <span class="kw">def</span> <span class="fu">filter</span>(p: A =&gt; Boolean): Array[A] = $\ldots$
  <span class="kw">def</span> map[B](f: A =&gt; B): Array[B] = $\ldots$
  <span class="kw">def</span> flatMap[B](f: A =&gt; Array[B]): Array[B] = $\ldots$
}</code></pre>
<p>If \(T\) is not a type parameter or abstract type, the type Array[\(T\)] is represented as the native array type <code>[]$T$</code> in the underlying host system. In that case <code>length</code> returns the length of the array, <code>apply</code> means subscripting, and <code>update</code> means element update. Because of the syntactic sugar for <code>apply</code> and <code>update</code> <a href="#implicit-conversions">operations</a>, we have the following correspondences between Scala and Java/C# code for operations on an array <code>xs</code>:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>Scala</em></td>
<td style="text-align: left;"><em>Java/C#</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>xs.length</code></td>
<td style="text-align: left;"><code>xs.length</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>xs(i)</code></td>
<td style="text-align: left;"><code>xs[i]</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>xs(i) = e</code></td>
<td style="text-align: left;"><code>xs[i] = e</code></td>
</tr>
</tbody>
</table>
<p>Arrays also implement the sequence trait <code>scala.Seq</code> by defining an <code>elements</code> method which returns all elements of the array in an <code>Iterator</code>.</p>
<p>Because of the tension between parametrized types in Scala and the ad-hoc implementation of arrays in the host-languages, some subtle points need to be taken into account when dealing with arrays. These are explained in the following.</p>
<p>First, unlike arrays in Java or C#, arrays in Scala are <em>not</em> co-variant; That is, \(S &lt;: T\) does not imply <code>Array[$S$] $&lt;:$ Array[$T$]</code> in Scala.<br>However, it is possible to cast an array of \(S\) to an array of \(T\) if such a cast is permitted in the host environment.</p>
<p>For instance <code>Array[String]</code> does not conform to <code>Array[Object]</code>, even though <code>String</code> conforms to <code>Object</code>. However, it is possible to cast an expression of type <code>Array[String]</code> to <code>Array[Object]</code>, and this cast will succeed without raising a <code>ClassCastException</code>. Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = <span class="kw">new</span> Array[String](<span class="dv">2</span>)
<span class="co">// val ys: Array[Object] = xs   // **** error: incompatible types</span>
<span class="kw">val</span> ys: Array[Object] = xs.<span class="fu">asInstanceOf</span>[Array[Object]] <span class="co">// OK</span></code></pre>
<p>Second, for <em>polymorphic arrays</em>, that have a type parameter or abstract type \(T\) as their element type, a representation different from <code>[]T</code> might be used. However, it is guaranteed that <code>isInstanceOf</code> and <code>asInstanceOf</code> still work as if the array used the standard representation of monomorphic arrays:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> ss = <span class="kw">new</span> Array[String](<span class="dv">2</span>)

<span class="kw">def</span> f[T](xs: Array[T]): Array[String] = 
  <span class="kw">if</span> (xs.<span class="fu">isInstanceOf</span>[Array[String]]) xs.<span class="fu">asInstanceOf</span>[Array[String])
  <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="st">&quot;not an instance&quot;</span>)

<span class="fu">f</span>(ss)                                     <span class="co">// returns ss</span></code></pre>
<p>The representation chosen for polymorphic arrays also guarantees that polymorphic array creations work as expected. An example is the following implementation of method <code>mkArray</code>, which creates an array of an arbitrary type \(T\), given a sequence of \(T\)'s which defines its elements.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> mkArray[T](elems: Seq[T]): Array[T] = {
  <span class="kw">val</span> result = <span class="kw">new</span> Array[T](elems.<span class="fu">length</span>)
  <span class="kw">var</span> i = <span class="dv">0</span>
  <span class="kw">for</span> (elem &lt;- elems) {
    <span class="fu">result</span>(i) = elem
    i += <span class="dv">1</span>
  }
}</code></pre>
<p>Note that under Java's erasure model of arrays the method above would not work as expected -- in fact it would always return an array of <code>Object</code>.</p>
<p>Third, in a Java environment there is a method <code>System.arraycopy</code> which takes two objects as parameters together with start indices and a length argument, and copies elements from one object to the other, provided the objects are arrays of compatible element types. <code>System.arraycopy</code> will not work for Scala's polymorphic arrays because of their different representation. One should instead use method <code>Array.copy</code> which is defined in the companion object of class <code>Array</code>. This companion object also defines various constructor methods for arrays, as well as the <a href="#extractor-patterns">extractor method</a> <code>unapplySeq</code> which enables pattern matching over arrays.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">object</span> Array { 
  <span class="co">/** copies array elements from </span>`<span class="co">src</span>&#39;<span class="co"> to </span>`<span class="co">dest</span>&#39;<span class="co">. */</span>
  <span class="kw">def</span> <span class="fu">copy</span>(src: AnyRef, srcPos: Int, 
           dest: AnyRef, destPos: Int, length: Int): Unit = $\ldots$

  <span class="co">/** Concatenate all argument arrays into a single array. */</span>
  <span class="kw">def</span> concat[T](xs: Array[T]*): Array[T] = $\ldots$

  <span class="co">/** Create a an array of successive integers. */</span>
  <span class="kw">def</span> <span class="fu">range</span>(start: Int, end: Int): Array[Int] = $\ldots$

  <span class="co">/** Create an array with given elements. */</span>
  <span class="kw">def</span> apply[A &lt;: AnyRef](xs: A*): Array[A] = $\ldots$

  <span class="co">/** Analogous to above. */</span>
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Boolean*): Array[Boolean] = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Byte*)   : Array[Byte]    = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Short*)  : Array[Short]   = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Char*)   : Array[Char]    = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Int*)    : Array[Int]     = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Long*)   : Array[Long]    = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Float*)  : Array[Float]   = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Double*) : Array[Double]  = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Unit*)   : Array[Unit]    = $\ldots$

  <span class="co">/** Create an array containing several copies of an element. */</span>
  <span class="kw">def</span> make[A](n: Int, elem: A): Array[A] = {

  <span class="co">/** Enables pattern matching over arrays */</span>
  <span class="kw">def</span> unapplySeq[A](x: Array[A]): Option[Seq[A]] = Some(x)
}</code></pre>
<ol start="87" type="1">
<li><p>The following method duplicates a given argument array and returns a pair consisting of the original and the duplicate:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> duplicate[T](xs: Array[T]) = {
  <span class="kw">val</span> ys = <span class="kw">new</span> Array[T](xs.<span class="fu">length</span>)
  Array.<span class="fu">copy</span>(xs, <span class="dv">0</span>, ys, <span class="dv">0</span>, xs.<span class="fu">length</span>)
  (xs, ys)
}</code></pre></li>
</ol>
<h2 id="class-node"><a href="#TOC"><span class="header-section-number">12.4</span> Class Node</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala.<span class="fu">xml</span> 

<span class="kw">trait</span> Node {

  <span class="co">/** the label of this node */</span>
  <span class="kw">def</span> label: String               

  <span class="co">/** attribute axis */</span>
  <span class="kw">def</span> attribute: Map[String, String] 

  <span class="co">/** child axis </span>(<span class="co">all children of this node</span>)<span class="co"> */</span>
  <span class="kw">def</span> child: Seq[Node]          

  <span class="co">/** descendant axis </span>(<span class="co">all descendants of this node</span>)<span class="co"> */</span>
  <span class="kw">def</span> descendant: Seq[Node] = child.<span class="fu">toList</span>.<span class="fu">flatMap</span> { 
    x =&gt; x::x.<span class="fu">descendant</span>.<span class="fu">asInstanceOf</span>[List[Node]] 
  } 

  <span class="co">/** descendant axis </span>(<span class="co">all descendants of this node</span>)<span class="co"> */</span>
  <span class="kw">def</span> descendant_or_self: Seq[Node] = <span class="kw">this</span>::child.<span class="fu">toList</span>.<span class="fu">flatMap</span> { 
    x =&gt; x::x.<span class="fu">descendant</span>.<span class="fu">asInstanceOf</span>[List[Node]] 
  } 

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(x: Any): Boolean = x <span class="kw">match</span> {
    <span class="kw">case</span> that:Node =&gt; 
      that.<span class="fu">label</span> == <span class="kw">this</span>.<span class="fu">label</span> &amp;&amp; 
        that.<span class="fu">attribute</span>.<span class="fu">sameElements</span>(<span class="kw">this</span>.<span class="fu">attribute</span>) &amp;&amp; 
          that.<span class="fu">child</span>.<span class="fu">sameElements</span>(<span class="kw">this</span>.<span class="fu">child</span>)
    <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
  } 

 <span class="co">/** XPath style projection function. Returns all children of this node</span>
<span class="co">  *  that are labeled with </span>&#39;<span class="co">that</span>&#39;.<span class="co"> The document order is preserved</span>.
<span class="co">  */</span>
    <span class="kw">def</span> \(that: Symbol): NodeSeq = {
      <span class="kw">new</span> <span class="fu">NodeSeq</span>({
        that.<span class="fu">name</span> <span class="kw">match</span> {
          <span class="kw">case</span> <span class="st">&quot;_&quot;</span> =&gt; child.<span class="fu">toList</span>  
          <span class="kw">case</span> _ =&gt;
            <span class="kw">var</span> res:List[Node] = Nil 
            <span class="kw">for</span> (x &lt;- child.<span class="fu">elements</span> <span class="kw">if</span> x.<span class="fu">label</span> == that.<span class="fu">name</span>) {
              res = x::res 
            }
            res.<span class="fu">reverse</span>
        }
      }) 
    }

 <span class="co">/** XPath style projection function. Returns all nodes labeled with the </span>
<span class="co">  *  name </span>&#39;<span class="co">that</span>&#39;<span class="co"> from the </span>&#39;<span class="co">descendant</span>_<span class="co">or</span>_<span class="co">self</span>&#39;<span class="co"> axis</span>.<span class="co"> Document order is preserved</span>.
<span class="co">  */</span>
  <span class="kw">def</span> \\(that: Symbol): NodeSeq = {
    <span class="kw">new</span> <span class="fu">NodeSeq</span>(
      that.<span class="fu">name</span> <span class="kw">match</span> {
        <span class="kw">case</span> <span class="st">&quot;_&quot;</span> =&gt; <span class="kw">this</span>.<span class="fu">descendant_or_self</span> 
        <span class="kw">case</span> _ =&gt; <span class="kw">this</span>.<span class="fu">descendant_or_self</span>.<span class="fu">asInstanceOf</span>[List[Node]].
        <span class="fu">filter</span>(x =&gt; x.<span class="fu">label</span> == that.<span class="fu">name</span>) 
      })
  }

  <span class="co">/** hashcode for this XML node */</span>
  <span class="kw">override</span> <span class="kw">def</span> hashCode = 
    Utility.<span class="fu">hashCode</span>(label, attribute.<span class="fu">toList</span>.<span class="fu">hashCode</span>, child) 

  <span class="co">/** string representation of this node */</span>
  <span class="kw">override</span> <span class="kw">def</span> toString = Utility.<span class="fu">toXML</span>(<span class="kw">this</span>) 

}</code></pre>
<h2 id="the-predef-object"><a href="#TOC"><span class="header-section-number">12.5</span> The <code>Predef</code> Object</a></h2>
<p>The <code>Predef</code> object defines standard functions and type aliases for Scala programs. It is always implicitly imported, so that all its defined members are available without qualification. Its definition for the JVM environment conforms to the following signature:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">object</span> Predef {

  <span class="co">// classOf ---------------------------------------------------------</span>

  <span class="co">/** Returns the runtime representation of a class type. */</span>
  <span class="kw">def</span> classOf[T]: Class[T] = <span class="kw">null</span>  
   <span class="co">// this is a dummy, classOf is handled by compiler.</span>

  <span class="co">// Standard type aliases ---------------------------------------------</span>

  <span class="kw">type</span> String    = java.<span class="fu">lang</span>.<span class="fu">String</span>
  <span class="kw">type</span> Class[T]  = java.<span class="fu">lang</span>.<span class="fu">Class</span>[T]

  <span class="co">// Miscellaneous -----------------------------------------------------</span>
  
  <span class="kw">type</span> Function[-A, +B] = Function1[A, B]

  <span class="kw">type</span> Map[A, +B] = collection.<span class="fu">immutable</span>.<span class="fu">Map</span>[A, B]
  <span class="kw">type</span> Set[A] = collection.<span class="fu">immutable</span>.<span class="fu">Set</span>[A]

  <span class="kw">val</span> Map = collection.<span class="fu">immutable</span>.<span class="fu">Map</span>
  <span class="kw">val</span> Set = collection.<span class="fu">immutable</span>.<span class="fu">Set</span>

  <span class="co">// Manifest types, companions, and incantations for summoning ---------</span>

  <span class="kw">type</span> ClassManifest[T] = scala.<span class="fu">reflect</span>.<span class="fu">ClassManifest</span>[T]
  <span class="kw">type</span> Manifest[T]      = scala.<span class="fu">reflect</span>.<span class="fu">Manifest</span>[T]
  <span class="kw">type</span> OptManifest[T]   = scala.<span class="fu">reflect</span>.<span class="fu">OptManifest</span>[T]
  <span class="kw">val</span> ClassManifest     = scala.<span class="fu">reflect</span>.<span class="fu">ClassManifest</span>
  <span class="kw">val</span> Manifest          = scala.<span class="fu">reflect</span>.<span class="fu">Manifest</span>
  <span class="kw">val</span> NoManifest        = scala.<span class="fu">reflect</span>.<span class="fu">NoManifest</span>
  
  <span class="kw">def</span> manifest[T](<span class="kw">implicit</span> m: Manifest[T])           = m
  <span class="kw">def</span> classManifest[T](<span class="kw">implicit</span> m: ClassManifest[T]) = m
  <span class="kw">def</span> optManifest[T](<span class="kw">implicit</span> m: OptManifest[T])     = m

  <span class="co">// Minor variations on identity functions -----------------------------</span>
  <span class="kw">def</span> identity[A](x: A): A         = x    <span class="co">// @see `conforms` for the implicit version</span>
  <span class="kw">def</span> implicitly[T](<span class="kw">implicit</span> e: T) = e    <span class="co">// for summoning implicit values from the nether world</span>
  @inline <span class="kw">def</span> locally[T](x: T): T  = x    <span class="co">// to communicate intent and avoid unmoored statements</span>

  <span class="co">// Asserts, Preconditions, Postconditions -----------------------------</span>

  <span class="kw">def</span> <span class="fu">assert</span>(assertion: Boolean) {
    <span class="kw">if</span> (!assertion)
      <span class="kw">throw</span> <span class="kw">new</span> java.<span class="fu">lang</span>.<span class="fu">AssertionError</span>(<span class="st">&quot;assertion failed&quot;</span>)
  }

  <span class="kw">def</span> <span class="fu">assert</span>(assertion: Boolean, message: =&gt; Any) {
    <span class="kw">if</span> (!assertion)
      <span class="kw">throw</span> <span class="kw">new</span> java.<span class="fu">lang</span>.<span class="fu">AssertionError</span>(<span class="st">&quot;assertion failed: &quot;</span> + message)
  }

  <span class="kw">def</span> <span class="fu">assume</span>(assumption: Boolean) {
    <span class="kw">if</span> (!assumption)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;assumption failed&quot;</span>)
  }

  <span class="kw">def</span> <span class="fu">assume</span>(assumption: Boolean, message: =&gt; Any) {
    <span class="kw">if</span> (!assumption)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(message.<span class="fu">toString</span>)
  }

  <span class="kw">def</span> <span class="fu">require</span>(requirement: Boolean) {
    <span class="kw">if</span> (!requirement)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;requirement failed&quot;</span>)
  }

  <span class="kw">def</span> <span class="fu">require</span>(requirement: Boolean, message: =&gt; Any) {
    <span class="kw">if</span> (!requirement)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;requirement failed: &quot;</span>+ message)
  }</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala">
  <span class="co">// tupling ---------------------------------------------------------</span>

  <span class="kw">type</span> Pair[+A, +B] = Tuple2[A, B]
  <span class="kw">object</span> Pair {
    <span class="kw">def</span> apply[A, B](x: A, y: B) = <span class="fu">Tuple2</span>(x, y)
    <span class="kw">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
  }

  <span class="kw">type</span> Triple[+A, +B, +C] = Tuple3[A, B, C]
  <span class="kw">object</span> Triple {
    <span class="kw">def</span> apply[A, B, C](x: A, y: B, z: C) = <span class="fu">Tuple3</span>(x, y, z)
    <span class="kw">def</span> unapply[A, B, C](x: Tuple3[A, B, C]): Option[Tuple3[A, B, C]] = Some(x)
  }

  <span class="co">// Printing and reading -----------------------------------------------</span>

  <span class="kw">def</span> <span class="fu">print</span>(x: Any) = Console.<span class="fu">print</span>(x)
  <span class="kw">def</span> <span class="fu">println</span>() = Console.<span class="fu">println</span>()
  <span class="kw">def</span> <span class="fu">println</span>(x: Any) = Console.<span class="fu">println</span>(x)
  <span class="kw">def</span> <span class="fu">printf</span>(text: String, xs: Any*) = Console<span class="fu">.printf</span>(text.format(xs: _*))

  <span class="kw">def</span> <span class="fu">readLine</span>(): String = Console.<span class="fu">readLine</span>()
  <span class="kw">def</span> <span class="fu">readLine</span>(text: String, args: Any*) = Console.<span class="fu">readLine</span>(text, args)
  <span class="kw">def</span> <span class="fu">readBoolean</span>() = Console.<span class="fu">readBoolean</span>()
  <span class="kw">def</span> <span class="fu">readByte</span>() = Console.<span class="fu">readByte</span>()
  <span class="kw">def</span> <span class="fu">readShort</span>() = Console.<span class="fu">readShort</span>()
  <span class="kw">def</span> <span class="fu">readChar</span>() = Console.<span class="fu">readChar</span>()
  <span class="kw">def</span> <span class="fu">readInt</span>() = Console.<span class="fu">readInt</span>()
  <span class="kw">def</span> <span class="fu">readLong</span>() = Console.<span class="fu">readLong</span>()
  <span class="kw">def</span> <span class="fu">readFloat</span>() = Console.<span class="fu">readFloat</span>()
  <span class="kw">def</span> <span class="fu">readDouble</span>() = Console.<span class="fu">readDouble</span>()
  <span class="kw">def</span> <span class="fu">readf</span>(format: String) = Console.<span class="fu">readf</span>(format)
  <span class="kw">def</span> <span class="fu">readf1</span>(format: String) = Console.<span class="fu">readf1</span>(format)
  <span class="kw">def</span> <span class="fu">readf2</span>(format: String) = Console.<span class="fu">readf2</span>(format)
  <span class="kw">def</span> <span class="fu">readf3</span>(format: String) = Console.<span class="fu">readf3</span>(format)

  <span class="co">// Implict conversions ------------------------------------------------</span>

  ...
}</code></pre>
<h3 id="predefined-implicit-definitions"><a href="#TOC"><span class="header-section-number">12.5.1</span> Predefined Implicit Definitions</a></h3>
<p>The <code>Predef</code> object also contains a number of implicit definitions, which are available by default (because <code>Predef</code> is implicitly imported). Implicit definitions come in two priorities. High-priority implicits are defined in the <code>Predef</code> class itself whereas low priority implicits are defined in a class inherited by <code>Predef</code>. The rules of static <a href="#overloading-resolution">overloading resolution</a> stipulate that, all other things being equal, implicit resolution prefers high-priority implicits over low-priority ones.</p>
<p>The available low-priority implicits include definitions falling into the following categories.</p>
<ol>
<li><p>For every primitive type, a wrapper that takes values of that type to instances of a <code>runtime.Rich*</code> class. For instance, values of type <code>Int</code> can be implicitly converted to instances of class <code>runtime.RichInt</code>.</p></li>
<li><p>For every array type with elements of primitive type, a wrapper that takes the arrays of that type to instances of a <code>runtime.WrappedArray</code> class. For instance, values of type <code>Array[Float]</code> can be implicitly converted to instances of class <code>runtime.WrappedArray[Float]</code>. There are also generic array wrappers that take elements of type <code>Array[T]</code> for arbitrary <code>T</code> to <code>WrappedArray</code>s.</p></li>
<li><p>An implicit conversion from <code>String</code> to <code>WrappedString</code>.</p></li>
</ol>
<p>The available high-priority implicits include definitions falling into the following categories.</p>
<ul>
<li><p>An implicit wrapper that adds <code>ensuring</code> methods with the following overloaded variants to type <code>Any</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">ensuring</span>(cond: Boolean): A = { <span class="fu">assert</span>(cond); x }
<span class="kw">def</span> <span class="fu">ensuring</span>(cond: Boolean, msg: Any): A = { <span class="fu">assert</span>(cond, msg); x }
<span class="kw">def</span> <span class="fu">ensuring</span>(cond: A =&gt; Boolean): A = { <span class="fu">assert</span>(<span class="fu">cond</span>(x)); x }
<span class="kw">def</span> <span class="fu">ensuring</span>(cond: A =&gt; Boolean, msg: Any): A = { <span class="fu">assert</span>(<span class="fu">cond</span>(x), msg); x }</code></pre></li>
<li><p>An implicit wrapper that adds a <code>-&gt;</code> method with the following implementation to type <code>Any</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> -&gt; [B](y: B): (A, B) = (x, y)</code></pre></li>
<li><p>For every array type with elements of primitive type, a wrapper that takes the arrays of that type to instances of a <code>runtime.ArrayOps</code> class. For instance, values of type <code>Array[Float]</code> can be implicitly converted to instances of class <code>runtime.ArrayOps[Float]</code>. There are also generic array wrappers that take elements of type <code>Array[T]</code> for arbitrary <code>T</code> to <code>ArrayOps</code>s.</p></li>
<li><p>An implicit wrapper that adds <code>+</code> and <code>formatted</code> method with the following implementations to type <code>Any</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> +(other: String) = String.<span class="fu">valueOf</span>(self) + other
<span class="kw">def</span> <span class="fu">formatted</span>(fmtstr: String): String = fmtstr format self</code></pre></li>
<li><p>Numeric primitive conversions that implement the transitive closure of the following mappings:</p>
<pre><code>Byte  -&gt; Short
Short -&gt; Int
Char  -&gt; Int
Int   -&gt; Long
Long  -&gt; Float
Float -&gt; Double</code></pre></li>
<li><p>Boxing and unboxing conversions between primitive types and their boxed versions:</p>
<pre><code>Byte    &lt;-&gt; java.lang.Byte
Short   &lt;-&gt; java.lang.Short
Char    &lt;-&gt; java.lang.Character
Int     &lt;-&gt; java.lang.Integer
Long    &lt;-&gt; java.lang.Long
Float   &lt;-&gt; java.lang.Float
Double  &lt;-&gt; java.lang.Double
Boolean &lt;-&gt; java.lang.Boolean</code></pre></li>
<li><p>An implicit definition that generates instances of type <code>T &lt;:&lt; T</code>, for any type <code>T</code>. Here, <code>&lt;:&lt;</code> is a class defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> &lt;:&lt;[-From, +To] <span class="kw">extends</span> (From =&gt; To)</code></pre>
<p>Implicit parameters of <code>&lt;:&lt;</code> types are typically used to implement type constraints.</p></li>
</ul>
<h1 id="scala-syntax-summary"><a href="#TOC"><span class="header-section-number">13</span> Scala Syntax Summary</a></h1>
<!-- TODO: introduce SeqPattern syntax -->

<p>The lexical syntax of Scala is given by the following grammar in EBNF form.</p>
<pre class="grammar"><code>upper            ::=  âAâ | â¦ | âZâ | â\$â | â_â  // and Unicode category Lu
lower            ::=  âaâ | â¦ | âzâ // and Unicode category Ll
letter           ::=  upper | lower // and Unicode categories Lo, Lt, Nl
digit            ::=  â0â | â¦ | â9â
opchar           ::= // âall other characters in \u0020-\u007F and Unicode
                     // categories Sm, So except parentheses ([{}]) and periodsâ

op               ::=  opchar {opchar} 
varid            ::=  lower idrest
plainid          ::=  upper idrest
                 |  varid
                 |  op
id               ::=  plainid
                 |  â\`â stringLit â\`â
idrest           ::=  {letter | digit} [â_â op]

integerLiteral   ::=  (decimalNumeral | hexNumeral | octalNumeral) [âLâ | âlâ]
decimalNumeral   ::=  â0â | nonZeroDigit {digit}
hexNumeral       ::=  â0â âxâ hexDigit {hexDigit}
octalNumeral     ::=  â0â octalDigit {octalDigit}
digit            ::=  â0â | nonZeroDigit
nonZeroDigit     ::=  â1â | â¦ | â9â
octalDigit       ::=  â0â | â¦ | â7â

floatingPointLiteral 
               ::=  digit {digit} â.â {digit} [exponentPart] [floatType]
                 |  â.â digit {digit} [exponentPart] [floatType]
                 |  digit {digit} exponentPart [floatType]
                 |  digit {digit} [exponentPart] floatType
exponentPart     ::=  (âEâ | âeâ) [â+â | â-â] digit {digit}
floatType        ::=  âFâ | âfâ | âDâ | âdâ

booleanLiteral   ::=  âtrueâ | âfalseâ

characterLiteral ::=  â\&#39;â printableChar â\&#39;â
                 |  â\â charEscapeSeq â\&#39;â

stringLiteral    ::=  â&quot;â {stringElement} â&quot;â
                 |  â&quot;&quot;&quot;â multiLineChars â&quot;&quot;&quot;â
stringElement    ::=  printableCharNoDoubleQuote 
                 |  charEscapeSeq
multiLineChars   ::=  {[â&quot;â] [â&quot;â] charNoDoubleQuote} {â&quot;â}

symbolLiteral    ::=  â&#39;â plainid

comment          ::=  â/*â âany sequence of charactersâ â*/â
                 |  â//â âany sequence of characters up to end of lineâ

nl               ::=  $\mathit{ânew line characterâ}$
semi             ::=  â;â |  nl {nl}</code></pre>
<p>The context-free syntax of Scala is given by the following EBNF grammar.</p>
<pre class="grammar"><code>  Literal           ::=  [â-â] integerLiteral
                      |  [â-â] floatingPointLiteral
                      |  booleanLiteral
                      |  characterLiteral
                      |  stringLiteral
                      |  symbolLiteral
                      |  ânullâ

  QualId            ::=  id {â.â id}
  ids               ::=  id {â,â id}

  Path              ::=  StableId
                      |  [id â.â] âthisâ
  StableId          ::=  id
                      |  Path â.â id
                      |  [id â.â] âsuperâ [ClassQualifier] â.â id
  ClassQualifier    ::=  â[â id â]â

  Type              ::=  FunctionArgTypes â=&gt;â Type
                      |  InfixType [ExistentialClause]
  FunctionArgTypes  ::= InfixType
                      | â(â [ ParamType {â,â ParamType } ] â)â
  ExistentialClause ::=  âforSomeâ â{â ExistentialDcl {semi ExistentialDcl} â}â
  ExistentialDcl    ::=  âtypeâ TypeDcl 
                      |  âvalâ ValDcl
  InfixType         ::=  CompoundType {id [nl] CompoundType}
  CompoundType      ::=  AnnotType {âwithâ AnnotType} [Refinement]
                      |  Refinement
  AnnotType         ::=  SimpleType {Annotation}
  SimpleType        ::=  SimpleType TypeArgs
                      |  SimpleType â#â id
                      |  StableId
                      |  Path â.â âtypeâ
                      |  â(â Types â)â
  TypeArgs          ::=  â[â Types â]â
  Types             ::=  Type {â,â Type}
  Refinement        ::=  [nl] â{â RefineStat {semi RefineStat} â}â
  RefineStat        ::=  Dcl
                      |  âtypeâ TypeDef
                      |
  TypePat           ::=  Type

  Ascription        ::=  â:â InfixType
                      |  â:â Annotation {Annotation} 
                      |  â:â â_â â*â

  Expr              ::=  (Bindings | [âimplicitâ] id | â_â) â=&gt;â Expr
                      |  Expr1
  Expr1             ::=  âifâ â(â Expr â)â {nl} Expr [[semi] else Expr]
                      |  âwhileâ â(â Expr â)â {nl} Expr
                      |  âtryâ â{â Block â}â [âcatchâ  â{â CaseClauses â}â] 
                         [âfinallyâ Expr]
                      |  âdoâ Expr [semi] âwhileâ â(â Expr â)â
                      |  âforâ (â(â Enumerators â)â | â{â Enumerators â}â) 
                         {nl} [âyieldâ] Expr
                      |  âthrowâ Expr
                      |  âreturnâ [Expr]
                      |  [SimpleExpr â.â] id â=â Expr
                      |  SimpleExpr1 ArgumentExprs â=â Expr
                      |  PostfixExpr
                      |  PostfixExpr Ascription
                      |  PostfixExpr âmatchâ â{â CaseClauses â}â
  PostfixExpr       ::=  InfixExpr [id [nl]]
  InfixExpr         ::=  PrefixExpr
                      |  InfixExpr id [nl] InfixExpr
  PrefixExpr        ::=  [â-â | â+â | â~â | â!â] SimpleExpr 
  SimpleExpr        ::=  ânewâ (ClassTemplate | TemplateBody)
                      |  BlockExpr
                      |  SimpleExpr1 [â_â]
  SimpleExpr1       ::=  Literal
                      |  Path
                      |  â_â
                      |  â(â [Exprs] â)â
                      |  SimpleExpr â.â id 
                      |  SimpleExpr TypeArgs
                      |  SimpleExpr1 ArgumentExprs
                      |  XmlExpr
  Exprs             ::=  Expr {â,â Expr}
  ArgumentExprs     ::=  â(â [Exprs] â)â
                      |  â(â [Exprs â,â] PostfixExpr â:â â_â â*â â)â
                      |  [nl] BlockExpr
  BlockExpr         ::=  â{â CaseClauses â}â
                      |  â{â Block â}â
  Block             ::=  {BlockStat semi} [ResultExpr]
  BlockStat         ::=  Import
                      |  {Annotation} [âimplicitâ | âlazyâ] Def
                      |  {Annotation} {LocalModifier} TmplDef
                      |  Expr1
                      |
  ResultExpr        ::=  Expr1
                      |  (Bindings | ([âimplicitâ] id | â_â) â:â CompoundType) â=&gt;â Block

  Enumerators       ::=  Generator {semi Enumerator}
  Enumerator        ::=  Generator
                      |  Guard
                      |  âvalâ Pattern1 â=â Expr
  Generator         ::=  Pattern1 â&lt;-â Expr [Guard]

  CaseClauses       ::=  CaseClause { CaseClause }
  CaseClause        ::=  âcaseâ Pattern [Guard] â=&gt;â Block 
  Guard             ::=  âifâ PostfixExpr

  Pattern           ::=  Pattern1 { â|â Pattern1 }
  Pattern1          ::=  varid â:â TypePat
                      |  â_â â:â TypePat
                      |  Pattern2
  Pattern2          ::=  varid [â@â Pattern3]
                      |  Pattern3
  Pattern3          ::=  SimplePattern
                      |  SimplePattern { id [nl] SimplePattern }
  SimplePattern     ::=  â_â
                      |  varid
                      |  Literal
                      |  StableId
                      |  StableId â(â [Patterns â)â
                      |  StableId â(â [Patterns â,â] [varid â@â] â_â â*â â)â
                      |  â(â [Patterns] â)â
                      |  XmlPattern
  Patterns          ::=  Pattern [â,â Patterns]
                      |  â_â *

  TypeParamClause   ::=  â[â VariantTypeParam {â,â VariantTypeParam} â]â
  FunTypeParamClause::=  â[â TypeParam {â,â TypeParam} â]â
  VariantTypeParam  ::=  {Annotation} [â+â | â-â] TypeParam
  TypeParam         ::=  (id | â_â) [TypeParamClause] [â&gt;:â Type] [â&lt;:â Type] 
                         {â&lt;%â Type} {â:â Type}
  ParamClauses      ::=  {ParamClause} [[nl] â(â âimplicitâ Params â)â]
  ParamClause       ::=  [nl] â(â [Params] â)â
  Params            ::=  Param {â,â Param}
  Param             ::=  {Annotation} id [â:â ParamType] [â=â Expr]
  ParamType         ::=  Type 
                      |  â=&gt;â Type 
                      |  Type â*â
  ClassParamClauses ::=  {ClassParamClause} 
                         [[nl] â(â âimplicitâ ClassParams â)â]
  ClassParamClause  ::=  [nl] â(â [ClassParams] â)â
  ClassParams       ::=  ClassParam {ââ ClassParam}
  ClassParam        ::=  {Annotation} [{Modifier} (âvalâ | âvarâ)] 
                         id â:â ParamType [â=â Expr]
  Bindings          ::=  â(â Binding {â,â Binding â)â
  Binding           ::=  (id | â_â) [â:â Type]

  Modifier          ::=  LocalModifier 
                      |  AccessModifier
                      |  âoverrideâ
  LocalModifier     ::=  âabstractâ
                      |  âfinalâ
                      |  âsealedâ
                      |  âimplicitâ
                      |  âlazyâ
  AccessModifier    ::=  (âprivateâ | âprotectedâ) [AccessQualifier]
  AccessQualifier   ::=  â[â (id | âthisâ) â]â

  Annotation        ::=  â@â SimpleType {ArgumentExprs}
  ConstrAnnotation  ::=  â@â SimpleType ArgumentExprs
  NameValuePair     ::=  âvalâ id â=â PrefixExpr

  TemplateBody      ::=  [nl] â{â [SelfType] TemplateStat {semi TemplateStat} â}â
  TemplateStat      ::=  Import
                      |  {Annotation [nl]} {Modifier} Def
                      |  {Annotation [nl]} {Modifier} Dcl
                      |  Expr
                      |
  SelfType          ::=  id [â:â Type] â=&gt;â
                      |  âthisâ â:â Type â=&gt;â 

  Import            ::=  âimportâ ImportExpr {â,â ImportExpr}
  ImportExpr        ::=  StableId â.â (id | â_â | ImportSelectors)
  ImportSelectors   ::=  â{â {ImportSelector â,â} (ImportSelector | â_â) â}â
  ImportSelector    ::=  id [â=&gt;â id | â=&gt;â â_â]

  Dcl               ::=  âvalâ ValDcl
                      |  âvarâ VarDcl
                      |  âdefâ FunDcl
                      |  âtypeâ {nl} TypeDcl

  ValDcl            ::=  ids â:â Type
  VarDcl            ::=  ids â:â Type
  FunDcl            ::=  FunSig [â:â Type]
  FunSig            ::=  id [FunTypeParamClause] ParamClauses
  TypeDcl           ::=  id [TypeParamClause] [â&gt;:â Type] [â&lt;:â Type]

  PatVarDef         ::=  âvalâ PatDef
                      |  âvarâ VarDef
  Def               ::=  PatVarDef
                      |  âdefâ FunDef
                      |  âtypeâ {nl} TypeDef
                      |  TmplDef
  PatDef            ::=  Pattern2 {â,â Pattern2} [â:â Type] â=â Expr
  VarDef            ::=  PatDef
                      |  ids â:â Type â=â â_â
  FunDef            ::=  FunSig [â:â Type] â=â Expr
                      |  FunSig [nl] â{â Block â}â
                      |  âthisâ ParamClause ParamClauses 
                         (â=â ConstrExpr | [nl] ConstrBlock)
  TypeDef           ::=  id [TypeParamClause] â=â Type

  TmplDef           ::=  [âcaseâ] âclassâ ClassDef
                      |  [âcaseâ] âobjectâ ObjectDef
                      |  âtraitâ TraitDef
  ClassDef          ::=  id [TypeParamClause] {ConstrAnnotation} [AccessModifier] 
                         ClassParamClauses ClassTemplateOpt 
  TraitDef          ::=  id [TypeParamClause] TraitTemplateOpt
  ObjectDef         ::=  id ClassTemplateOpt
  ClassTemplateOpt  ::=  âextendsâ ClassTemplate | [[âextendsâ] TemplateBody]
  TraitTemplateOpt  ::=  âextendsâ TraitTemplate | [[âextendsâ] TemplateBody]
  ClassTemplate     ::=  [EarlyDefs] ClassParents [TemplateBody]
  TraitTemplate     ::=  [EarlyDefs] TraitParents [TemplateBody]
  ClassParents      ::=  Constr {âwithâ AnnotType}
  TraitParents      ::=  AnnotType {âwithâ AnnotType}
  Constr            ::=  AnnotType {ArgumentExprs}
  EarlyDefs         ::= â{â [EarlyDef {semi EarlyDef}] â}â âwithâ
  EarlyDef          ::=  {Annotation [nl]} {Modifier} PatVarDef

  ConstrExpr        ::=  SelfInvocation 
                      |  ConstrBlock
  ConstrBlock       ::=  â{â SelfInvocation {semi BlockStat} â}â
  SelfInvocation    ::=  âthisâ ArgumentExprs {ArgumentExprs}

  TopStatSeq        ::=  TopStat {semi TopStat}
  TopStat           ::=  {Annotation [nl]} {Modifier} TmplDef
                      |  Import
                      |  Packaging
                      |  PackageObject
                      |  
  Packaging         ::=  âpackageâ QualId [nl] â{â TopStatSeq â}â
  PackageObject     ::=  âpackageâ âobjectâ ObjectDef

  CompilationUnit   ::=  {âpackageâ QualId semi} TopStatSeq</code></pre>
<!-- TODO add:

SimplePattern    ::= StableId  [TypePatArgs] [â(â [SeqPatterns] â)â]
TypePatArgs ::= â[â TypePatArg {â,â TypePatArg} â]â
TypePatArg    ::=  â_â |   varid}

-->


<h1 id="references"><a href="#TOC"><span class="header-section-number">14</span> References</a></h1>
<!-- this is deliberately empty, and must be at the very end of the
     document as pandoc will inject all citation information here.
-->

<p>Kennedy, Andrew J., and Benjamin C. Pierce. 2007. âOn Decidability of Nominal Subtyping with Variance.â</p>
<p>Odersky, Martin. 2006. âThe Scala Experiment â Can We Provide Better Language Support for Component Systems?.â In <em>Proc. ACM Symposium on Principles of Programming Languages</em>.</p>
<p>Odersky, Martin, Vincent Cremet, Christine RÃ¶ckl, and Matthias Zenger. 2003. âA Nominal Theory of Objects with Dependent Types.â In <em>Proc. ECOOPâ03</em>.</p>
<p>Odersky, Martin, and Matthias Zenger. 2005a. âScalable Component Abstractions.â In <em>Proc. OOPSLA</em>.</p>
<p>âââ. 2005b. âIndependently Extensible Solutions to the Expression Problem.â In <em>Proc. FOOL 12</em>.</p>
<p>Odersky, Martin, and al. 2004. âAn Overview of the Scala Programming Language.â</p>
<section class="footnotes">
<hr>
<ol>
<li id="fn1"><p>We assume that objects and packages also implicitly define a class (of the same name as the object or package, but inaccessible to user programs).<a href="#fnref1">â©</a></p></li>
<li id="fn2"><p>A reference to a structurally defined member (method call or access to a value or variable) may generate binary code that is significantly slower than an equivalent code to a non-structural member.<a href="#fnref2">â©</a></p></li>
<li id="fn3"><p>A congruence is an equivalence relation which is closed under formation of contexts.<a href="#fnref3">â©</a></p></li>
<li id="fn4"><p>The current Scala compiler limits the nesting level of parameterization in such bounds to be at most two deeper than the maximum nesting level of the operand types.<a href="#fnref4">â©</a></p></li>
<li id="fn5"><p>However, at present singleton types of method parameters may only appear in the method body; so <em>dependent method types</em> are not supported.<a href="#fnref5">â©</a></p></li>
</ol>
</section>
</div>
</body>
</html>
