<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Martin Odersky">
  <meta name="author" content="Philippe Altherr">
  <meta name="author" content="Vincent Cremet">
  <meta name="author" content="Gilles Dubochet">
  <meta name="author" content="Burak Emir">
  <meta name="author" content="Philipp Haller">
  <meta name="author" content="Stéphane Micheloud">
  <meta name="author" content="Nikolay Mihaylov">
  <meta name="author" content="Michel Schinz">
  <meta name="author" content="Erik Stenman">
  <meta name="author" content="Matthias Zenger">
  <title>The Scala Language Specification, Version 2.9</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
  <script type="text/javascript" src="resources/ScalaReference.js"></script>
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
            skipTags: ["script", "noscript", "style", "textarea"],
            inlineMath: [ ["$", "$"], ["\\(", "\\)"] ],
            processEscapes: true
        }
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <link rel="stylesheet" href="resources/blueprint-screen.css" type="text/css" media="screen, projection">
  <link rel="stylesheet" href="resources/blueprint-print.css" type="text/css" media="print">
  <!--[if lt IE 8]>
    <link rel="stylesheet" href="resources/blueprint-ie.css" type="text/css" media="screen, projection">
  <![endif]-->
  <link rel="stylesheet" href="resources/style.css" type="text/css" media="screen, projection"/>

</head>
<body>
<div class="container">
<header>
<h1 class="title">The Scala Language Specification, Version 2.9</h1>
<h3 class="date">24th May 2011</h3>
</header>
<hr>
<nav id="TOC">
<ul>
<li><a href="#preface"><span class="toc-section-number">0.1</span> Preface</a></li>
<li><a href="#lexical-syntax"><span class="toc-section-number">1</span> Lexical Syntax</a><ul>
<li><a href="#identifiers"><span class="toc-section-number">1.1</span> Identifiers</a></li>
<li><a href="#newline-characters"><span class="toc-section-number">1.2</span> Newline Characters</a></li>
<li><a href="#literals"><span class="toc-section-number">1.3</span> Literals</a><ul>
<li><a href="#integer-literals"><span class="toc-section-number">1.3.1</span> Integer Literals</a></li>
<li><a href="#floating-point-literals"><span class="toc-section-number">1.3.2</span> Floating Point Literals</a></li>
<li><a href="#boolean-literals"><span class="toc-section-number">1.3.3</span> Boolean Literals</a></li>
<li><a href="#character-literals"><span class="toc-section-number">1.3.4</span> Character Literals</a></li>
<li><a href="#string-literals"><span class="toc-section-number">1.3.5</span> String Literals</a></li>
<li><a href="#escape-sequences"><span class="toc-section-number">1.3.6</span> Escape Sequences</a></li>
<li><a href="#symbol-literals"><span class="toc-section-number">1.3.7</span> Symbol literals</a></li>
</ul></li>
<li><a href="#whitespace-and-comments"><span class="toc-section-number">1.4</span> Whitespace and Comments</a></li>
<li><a href="#xml-mode"><span class="toc-section-number">1.5</span> XML mode</a></li>
</ul></li>
<li><a href="#identifiers-names-and-scopes"><span class="toc-section-number">2</span> Identifiers, Names and Scopes</a></li>
<li><a href="#types"><span class="toc-section-number">3</span> Types</a><ul>
<li><a href="#paths"><span class="toc-section-number">3.1</span> Paths</a></li>
<li><a href="#value-types"><span class="toc-section-number">3.2</span> Value Types</a><ul>
<li><a href="#singleton-types"><span class="toc-section-number">3.2.1</span> Singleton Types</a></li>
<li><a href="#type-projection"><span class="toc-section-number">3.2.2</span> Type Projection</a></li>
<li><a href="#type-designators"><span class="toc-section-number">3.2.3</span> Type Designators</a></li>
<li><a href="#parameterized-types"><span class="toc-section-number">3.2.4</span> Parameterized Types</a></li>
<li><a href="#tuple-types"><span class="toc-section-number">3.2.5</span> Tuple Types</a></li>
<li><a href="#annotated-types"><span class="toc-section-number">3.2.6</span> Annotated Types</a></li>
<li><a href="#compound-types"><span class="toc-section-number">3.2.7</span> Compound Types</a></li>
<li><a href="#infix-types"><span class="toc-section-number">3.2.8</span> Infix Types</a></li>
<li><a href="#function-types"><span class="toc-section-number">3.2.9</span> Function Types</a></li>
<li><a href="#existential-types"><span class="toc-section-number">3.2.10</span> Existential Types</a></li>
</ul></li>
<li><a href="#non-value-types"><span class="toc-section-number">3.3</span> Non-Value Types</a><ul>
<li><a href="#method-types"><span class="toc-section-number">3.3.1</span> Method Types</a></li>
<li><a href="#polymorphic-method-types"><span class="toc-section-number">3.3.2</span> Polymorphic Method Types</a></li>
<li><a href="#type-constructors"><span class="toc-section-number">3.3.3</span> Type Constructors</a></li>
</ul></li>
<li><a href="#base-types-and-member-definitions"><span class="toc-section-number">3.4</span> Base Types and Member Definitions</a></li>
<li><a href="#relations-between-types"><span class="toc-section-number">3.5</span> Relations between types</a><ul>
<li><a href="#type-equivalence"><span class="toc-section-number">3.5.1</span> Type Equivalence</a></li>
<li><a href="#conformance"><span class="toc-section-number">3.5.2</span> Conformance</a></li>
<li><a href="#weak-conformance"><span class="toc-section-number">3.5.3</span> Weak Conformance</a></li>
</ul></li>
<li><a href="#volatile-types"><span class="toc-section-number">3.6</span> Volatile Types</a></li>
<li><a href="#type-erasure"><span class="toc-section-number">3.7</span> Type Erasure</a></li>
</ul></li>
<li><a href="#basic-declarations-and-definitions"><span class="toc-section-number">4</span> Basic Declarations and Definitions</a><ul>
<li><a href="#value-declarations-and-definitions"><span class="toc-section-number">4.1</span> Value Declarations and Definitions</a></li>
<li><a href="#variable-declarations-and-definitions"><span class="toc-section-number">4.2</span> Variable Declarations and Definitions</a></li>
<li><a href="#type-declarations-and-type-aliases"><span class="toc-section-number">4.3</span> Type Declarations and Type Aliases</a></li>
<li><a href="#type-parameters"><span class="toc-section-number">4.4</span> Type Parameters</a></li>
<li><a href="#variance-annotations"><span class="toc-section-number">4.5</span> Variance Annotations</a></li>
<li><a href="#function-declarations-and-definitions"><span class="toc-section-number">4.6</span> Function Declarations and Definitions</a><ul>
<li><a href="#by-name-parameters"><span class="toc-section-number">4.6.1</span> By-Name Parameters</a></li>
<li><a href="#repeated-parameters"><span class="toc-section-number">4.6.2</span> Repeated Parameters</a></li>
<li><a href="#procedures"><span class="toc-section-number">4.6.3</span> Procedures</a></li>
<li><a href="#method-return-type-inference"><span class="toc-section-number">4.6.4</span> Method Return Type Inference</a></li>
</ul></li>
<li><a href="#import-clauses"><span class="toc-section-number">4.7</span> Import Clauses</a></li>
</ul></li>
<li><a href="#classes-and-objects"><span class="toc-section-number">5</span> Classes and Objects</a><ul>
<li><a href="#templates"><span class="toc-section-number">5.1</span> Templates</a><ul>
<li><a href="#constructor-invocations"><span class="toc-section-number">5.1.1</span> Constructor Invocations</a></li>
<li><a href="#class-linearization"><span class="toc-section-number">5.1.2</span> Class Linearization</a></li>
<li><a href="#class-members"><span class="toc-section-number">5.1.3</span> Class Members</a></li>
<li><a href="#overriding"><span class="toc-section-number">5.1.4</span> Overriding</a></li>
<li><a href="#inheritance-closure"><span class="toc-section-number">5.1.5</span> Inheritance Closure</a></li>
<li><a href="#early-definitions"><span class="toc-section-number">5.1.6</span> Early Definitions</a></li>
</ul></li>
<li><a href="#modifiers"><span class="toc-section-number">5.2</span> Modifiers</a></li>
<li><a href="#class-definitions"><span class="toc-section-number">5.3</span> Class Definitions</a><ul>
<li><a href="#constructor-definitions"><span class="toc-section-number">5.3.1</span> Constructor Definitions</a></li>
</ul></li>
<li><a href="#case-classes"><span class="toc-section-number">5.4</span> Case Classes</a><ul>
<li><a href="#traits"><span class="toc-section-number">5.4.1</span> Traits</a></li>
</ul></li>
<li><a href="#object-definitions"><span class="toc-section-number">5.5</span> Object Definitions</a></li>
</ul></li>
<li><a href="#expressions"><span class="toc-section-number">6</span> Expressions</a><ul>
<li><a href="#expression-typing"><span class="toc-section-number">6.1</span> Expression Typing</a></li>
<li><a href="#literals-1"><span class="toc-section-number">6.2</span> Literals</a></li>
<li><a href="#the-null-value"><span class="toc-section-number">6.3</span> The <em>Null</em> Value</a></li>
<li><a href="#designators"><span class="toc-section-number">6.4</span> Designators</a></li>
<li><a href="#this-and-super"><span class="toc-section-number">6.5</span> This and Super</a></li>
<li><a href="#function-applications"><span class="toc-section-number">6.6</span> Function Applications</a><ul>
<li><a href="#named-and-default-arguments"><span class="toc-section-number">6.6.1</span> Named and Default Arguments</a></li>
</ul></li>
<li><a href="#method-values"><span class="toc-section-number">6.7</span> Method Values</a></li>
<li><a href="#type-applications"><span class="toc-section-number">6.8</span> Type Applications</a></li>
<li><a href="#tuples"><span class="toc-section-number">6.9</span> Tuples</a></li>
<li><a href="#instance-creation-expressions"><span class="toc-section-number">6.10</span> Instance Creation Expressions</a></li>
<li><a href="#blocks"><span class="toc-section-number">6.11</span> Blocks</a></li>
<li><a href="#prefix-infix-and-postfix-operations"><span class="toc-section-number">6.12</span> Prefix, Infix, and Postfix Operations</a><ul>
<li><a href="#prefix-operations"><span class="toc-section-number">6.12.1</span> Prefix Operations</a></li>
<li><a href="#postfix-operations"><span class="toc-section-number">6.12.2</span> Postfix Operations</a></li>
<li><a href="#infix-operations"><span class="toc-section-number">6.12.3</span> Infix Operations</a></li>
<li><a href="#assignment-operators"><span class="toc-section-number">6.12.4</span> Assignment Operators</a></li>
</ul></li>
<li><a href="#typed-expressions"><span class="toc-section-number">6.13</span> Typed Expressions</a></li>
<li><a href="#annotated-expressions"><span class="toc-section-number">6.14</span> Annotated Expressions</a></li>
<li><a href="#assignments"><span class="toc-section-number">6.15</span> Assignments</a></li>
<li><a href="#conditional-expressions"><span class="toc-section-number">6.16</span> Conditional Expressions</a></li>
<li><a href="#while-loop-expressions"><span class="toc-section-number">6.17</span> While Loop Expressions</a></li>
<li><a href="#do-loop-expressions"><span class="toc-section-number">6.18</span> Do Loop Expressions</a></li>
<li><a href="#for-comprehensions-and-for-loops"><span class="toc-section-number">6.19</span> For Comprehensions and For Loops</a></li>
<li><a href="#return-expressions"><span class="toc-section-number">6.20</span> Return Expressions</a></li>
<li><a href="#throw-expressions"><span class="toc-section-number">6.21</span> Throw Expressions</a></li>
<li><a href="#try-expressions"><span class="toc-section-number">6.22</span> Try Expressions</a></li>
<li><a href="#anonymous-functions"><span class="toc-section-number">6.23</span> Anonymous Functions</a><ul>
<li><a href="#placeholder-syntax-for-anonymous-functions"><span class="toc-section-number">6.23.1</span> Placeholder Syntax for Anonymous Functions</a></li>
</ul></li>
<li><a href="#constant-expressions"><span class="toc-section-number">6.24</span> Constant Expressions</a></li>
<li><a href="#statements"><span class="toc-section-number">6.25</span> Statements</a></li>
<li><a href="#implicit-conversions"><span class="toc-section-number">6.26</span> Implicit Conversions</a><ul>
<li><a href="#value-conversions"><span class="toc-section-number">6.26.1</span> Value Conversions</a></li>
<li><a href="#method-conversions"><span class="toc-section-number">6.26.2</span> Method Conversions</a></li>
<li><a href="#overloading-resolution"><span class="toc-section-number">6.26.3</span> Overloading Resolution</a></li>
<li><a href="#local-type-inference"><span class="toc-section-number">6.26.4</span> Local Type Inference</a></li>
<li><a href="#eta-expansion"><span class="toc-section-number">6.26.5</span> Eta Expansion</a></li>
<li><a href="#dynamic-member-selection"><span class="toc-section-number">6.26.6</span> Dynamic Member Selection</a></li>
</ul></li>
</ul></li>
<li><a href="#implicit-parameters-and-views"><span class="toc-section-number">7</span> Implicit Parameters and Views</a><ul>
<li><a href="#the-implicit-modifier"><span class="toc-section-number">7.1</span> The Implicit Modifier</a></li>
<li><a href="#implicit-parameters"><span class="toc-section-number">7.2</span> Implicit Parameters</a></li>
<li><a href="#views"><span class="toc-section-number">7.3</span> Views</a></li>
<li><a href="#context-bounds-and-view-bounds"><span class="toc-section-number">7.4</span> Context Bounds and View Bounds</a></li>
<li><a href="#manifests"><span class="toc-section-number">7.5</span> Manifests</a></li>
</ul></li>
<li><a href="#pattern-matching"><span class="toc-section-number">8</span> Pattern Matching</a><ul>
<li><a href="#patterns"><span class="toc-section-number">8.1</span> Patterns</a><ul>
<li><a href="#variable-patterns"><span class="toc-section-number">8.1.1</span> Variable Patterns</a></li>
<li><a href="#typed-patterns"><span class="toc-section-number">8.1.2</span> Typed Patterns</a></li>
<li><a href="#pattern-binders"><span class="toc-section-number">8.1.3</span> Pattern Binders</a></li>
<li><a href="#literal-patterns"><span class="toc-section-number">8.1.4</span> Literal Patterns</a></li>
<li><a href="#stable-identifier-patterns"><span class="toc-section-number">8.1.5</span> Stable Identifier Patterns</a></li>
<li><a href="#constructor-patterns"><span class="toc-section-number">8.1.6</span> Constructor Patterns</a></li>
<li><a href="#tuple-patterns"><span class="toc-section-number">8.1.7</span> Tuple Patterns</a></li>
<li><a href="#extractor-patterns"><span class="toc-section-number">8.1.8</span> Extractor Patterns</a></li>
<li><a href="#pattern-sequences"><span class="toc-section-number">8.1.9</span> Pattern Sequences</a></li>
<li><a href="#infix-operation-patterns"><span class="toc-section-number">8.1.10</span> Infix Operation Patterns</a></li>
<li><a href="#pattern-alternatives"><span class="toc-section-number">8.1.11</span> Pattern Alternatives</a></li>
<li><a href="#xml-patterns"><span class="toc-section-number">8.1.12</span> XML Patterns</a></li>
<li><a href="#regular-expression-patterns"><span class="toc-section-number">8.1.13</span> Regular Expression Patterns</a></li>
<li><a href="#irrefutable-patterns"><span class="toc-section-number">8.1.14</span> Irrefutable Patterns</a></li>
</ul></li>
<li><a href="#type-patterns"><span class="toc-section-number">8.2</span> Type Patterns</a></li>
<li><a href="#type-parameter-inference-in-patterns"><span class="toc-section-number">8.3</span> Type Parameter Inference in Patterns</a></li>
<li><a href="#pattern-matching-expressions"><span class="toc-section-number">8.4</span> Pattern Matching Expressions</a></li>
<li><a href="#pattern-matching-anonymous-functions"><span class="toc-section-number">8.5</span> Pattern Matching Anonymous Functions</a></li>
</ul></li>
<li><a href="#top-level-definitions"><span class="toc-section-number">9</span> Top-Level Definitions</a><ul>
<li><a href="#compilation-units"><span class="toc-section-number">9.1</span> Compilation Units</a></li>
<li><a href="#packagings"><span class="toc-section-number">9.2</span> Packagings</a></li>
<li><a href="#package-objects"><span class="toc-section-number">9.3</span> Package Objects</a></li>
<li><a href="#package-references"><span class="toc-section-number">9.4</span> Package References</a></li>
<li><a href="#programs"><span class="toc-section-number">9.5</span> Programs</a></li>
</ul></li>
<li><a href="#xml-expressions-and-patterns"><span class="toc-section-number">10</span> XML Expressions and Patterns</a><ul>
<li><a href="#xml-expressions"><span class="toc-section-number">10.1</span> XML expressions</a></li>
<li><a href="#xml-patterns-1"><span class="toc-section-number">10.2</span> XML patterns</a></li>
</ul></li>
<li><a href="#user-defined-annotations"><span class="toc-section-number">11</span> User-Defined Annotations</a></li>
<li><a href="#the-scala-standard-library"><span class="toc-section-number">12</span> The Scala Standard Library</a><ul>
<li><a href="#root-classes"><span class="toc-section-number">12.1</span> Root Classes</a></li>
<li><a href="#value-classes"><span class="toc-section-number">12.2</span> Value Classes</a><ul>
<li><a href="#numeric-value-types"><span class="toc-section-number">12.2.1</span> Numeric Value Types</a></li>
<li><a href="#class-boolean"><span class="toc-section-number">12.2.2</span> Class <code>Boolean</code></a></li>
<li><a href="#class-unit"><span class="toc-section-number">12.2.3</span> Class <code>Unit</code></a></li>
</ul></li>
<li><a href="#standard-reference-classes"><span class="toc-section-number">12.3</span> Standard Reference Classes</a><ul>
<li><a href="#class-string"><span class="toc-section-number">12.3.1</span> Class <code>String</code></a></li>
<li><a href="#the-tuple-classes"><span class="toc-section-number">12.3.2</span> The <code>Tuple</code> classes</a></li>
<li><a href="#the-function-classes"><span class="toc-section-number">12.3.3</span> The <code>Function</code> Classes</a></li>
<li><a href="#class-array"><span class="toc-section-number">12.3.4</span> Class <code>Array</code></a></li>
</ul></li>
<li><a href="#class-node"><span class="toc-section-number">12.4</span> Class Node</a></li>
<li><a href="#the-predef-object"><span class="toc-section-number">12.5</span> The <code>Predef</code> Object</a><ul>
<li><a href="#predefined-implicit-definitions"><span class="toc-section-number">12.5.1</span> Predefined Implicit Definitions</a></li>
</ul></li>
</ul></li>
<li><a href="#scala-syntax-summary"><span class="toc-section-number">13</span> Scala Syntax Summary</a></li>
<li><a href="#references"><span class="toc-section-number">14</span> References</a></li>
</ul>
</nav>
<h2 id="preface"><a href="#preface"><span class="header-section-number">0.1</span> Preface</a></h2>
<p>Scala is a Java-like programming language which unifies object-oriented and functional programming. It is a pure object-oriented language in the sense that every value is an object. Types and behavior of objects are described by classes. Classes can be composed using mixin composition. Scala is designed to work seamlessly with two less pure but mainstream object-oriented languages -- Java and C#.</p>
<p>Scala is a functional language in the sense that every function is a value. Nesting of function definitions and higher-order functions are naturally supported. Scala also supports a general notion of pattern matching which can model the algebraic types used in many functional languages.</p>
<p>Scala has been designed to interoperate seamlessly with Java (an alternative implementation of Scala also works for .NET). Scala classes can call Java methods, create Java objects, inherit from Java classes and implement Java interfaces. None of this requires interface definitions or glue code.</p>
<p>Scala has been developed from 2001 in the programming methods laboratory at EPFL. Version 1.0 was released in November 2003. This document describes the second version of the language, which was released in March 2006. It acts a reference for the language definition and some core library modules. It is not intended to teach Scala or its concepts; for this there are other documents <span class="citation" data-cites="scala-overview-tech-report odersky:scala-experiment odersky:sca odersky-et-al:ecoop03 odersky-zenger:fool12">(Odersky and al. 2004; Odersky 2006; Odersky and Zenger 2005a; Odersky et al. 2003; Odersky and Zenger 2005b)</span></p>
<p>Scala has been a collective effort of many people. The design and the implementation of version 1.0 was completed by Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman, Matthias Zenger, and the author. Iulian Dragos, Gilles Dubochet, Philipp Haller, Sean McDirmid, Lex Spoon, and Geoffrey Washburn joined in the effort to develop the second version of the language and tools. Gilad Bracha, Craig Chambers, Erik Ernst, Matthias Felleisen, Shriram Krishnamurti, Gary Leavens, Sebastian Maneth, Erik Meijer, Klaus Ostermann, Didier Rémy, Mads Torgersen, and Philip Wadler have shaped the design of the language through lively and inspiring discussions and comments on previous versions of this document. The contributors to the Scala mailing list have also given very useful feedback that helped us improve the language and its tools.</p>
<h1 id="lexical-syntax"><a href="#lexical-syntax"><span class="header-section-number">1</span> Lexical Syntax</a></h1>
<p>Scala programs are written using the Unicode Basic Multilingual Plane (<em>BMP</em>) character set; Unicode supplementary characters are not presently supported. This chapter defines the two modes of Scala's lexical syntax, the Scala mode and the <em>XML</em> mode. If not otherwise mentioned, the following descriptions of Scala tokens refer to Scala mode, and literal characters ‘c’ refer to the ASCII fragment \u0000-\u007F</p>
<p>In Scala mode, <em>Unicode escapes</em> are replaced by the corresponding Unicode character with the given hexadecimal code.</p>
<pre class="grammar"><code>UnicodeEscape ::= \{\\}u{u} hexDigit hexDigit hexDigit hexDigit
hexDigit      ::= ‘0’ | … | ‘9’ | ‘A’ | … | ‘F’ | ‘a’ | … | ‘f’</code></pre>
<p>To construct tokens, characters are distinguished according to the following classes (Unicode general category given in parentheses):</p>
<ol>
<li>Whitespace characters. <code class="grammar">\u0020 | \u0009 | \u000D | \u000A</code></li>
<li>Letters, which include lower case letters(Ll), upper case letters(Lu), titlecase letters(Lt), other letters(Lo), letter numerals(Nl) and the two characters \u0024 ‘\$’ and \u005F ‘_’, which both count as upper case letters</li>
<li>Digits <code class="grammar">‘0’ | … | ‘9’</code></li>
<li>Parentheses <code class="grammar">‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’</code></li>
<li>Delimiter characters <code class="grammar">‘`’ | ‘'’ | ‘&quot;’ | ‘.’ | ‘;’ | ‘,’</code></li>
<li>Operator characters. These consist of all printable ASCII characters \u0020-\u007F which are in none of the sets above, mathematical symbols(Sm) and other symbols(So).</li>
</ol>
<h2 id="identifiers"><a href="#identifiers"><span class="header-section-number">1.1</span> Identifiers</a></h2>
<pre class="grammar"><code>op       ::=  opchar {opchar} 
varid    ::=  lower idrest
plainid  ::=  upper idrest
           |  varid
           |  op
id       ::=  plainid
           |  ‘`’ stringLit ‘`’
idrest   ::=  {letter | digit} [‘_’ op]</code></pre>
<p>There are three ways to form an identifier. First, an identifier can start with a letter which can be followed by an arbitrary sequence of letters and digits. This may be followed by underscore ‘_’ characters and another string composed of either letters and digits or of operator characters. Second, an identifier can start with an operator character followed by an arbitrary sequence of operator characters. The preceding two forms are called <em>plain</em> identifiers. Finally, an identifier may also be formed by an arbitrary string between back-quotes (host systems may impose some restrictions on which strings are legal for identifiers). The identifier then is composed of all characters excluding the backquotes themselves.</p>
<p>As usual, a longest match rule applies. For instance, the string</p>
<pre class="sourceCode scala"><code class="sourceCode scala">big_bob++=`def`</code></pre>
<p>decomposes into the three identifiers <code>big_bob</code>, <code>++=</code>, and <code>def</code>. The rules for pattern matching further distinguish between <em>variable identifiers</em>, which start with a lower case letter, and <em>constant identifiers</em>, which do not.</p>
<p>The ‘$’ character is reserved for compiler-synthesized identifiers. User programs should not define identifiers which contain ‘$’ characters.</p>
<p>The following names are reserved words instead of being members of the syntactic class <code>id</code> of lexical identifiers.</p>
<pre><code>abstract    case        catch       class       def
do          else        extends     false       final
finally     for         forSome     if          implicit
import      lazy        match       new         null
object      override    package     private     protected
return      sealed      super       this        throw       
trait       try         true        type        val         
var         while       with        yield
_    :    =    =&gt;    &lt;-    &lt;:    &lt;%     &gt;:    #    @</code></pre>
<p>The Unicode operators \u21D2 ‘<span class="math">\(\Rightarrow\)</span>’ and \u2190 ‘<span class="math">\(\leftarrow\)</span>’, which have the ASCII equivalents ‘=&gt;’ and ‘&lt;-’, are also reserved.</p>
<ol type="1">
<li><p>Here are examples of identifiers:</p>
<pre><code>    x         Object        maxIndex   p2p      empty_?
    +         `yield`       αρετη     _y       dot_product_*
    __system  _MAX_LEN_     </code></pre></li>
<li><p>Backquote-enclosed strings are a solution when one needs to access Java identifiers that are reserved words in Scala. For instance, the statement <code>Thread.yield()</code> is illegal, since <code>yield</code> is a reserved word in Scala. However, here's a work-around: <code class="sourceCode scala">Thread.`yield`()</code></p></li>
</ol>
<h2 id="newline-characters"><a href="#newline-characters"><span class="header-section-number">1.2</span> Newline Characters</a></h2>
<pre class="grammar"><code>semi ::= ‘;’ |  nl {nl}</code></pre>
<p>Scala is a line-oriented language where statements may be terminated by semi-colons or newlines. A newline in a Scala source text is treated as the special token “nl” if the three following criteria are satisfied:</p>
<ol>
<li>The token immediately preceding the newline can terminate a statement.</li>
<li>The token immediately following the newline can begin a statement.</li>
<li>The token appears in a region where newlines are enabled.</li>
</ol>
<p>The tokens that can terminate a statement are: literals, identifiers and the following delimiters and reserved words:</p>
<pre><code>this    null    true    false    return    type    &lt;xml-start&gt;    
_       )       ]       }</code></pre>
<p>The tokens that can begin a statement are all Scala tokens <em>except</em> the following delimiters and reserved words:</p>
<pre><code>catch    else    extends    finally    forSome    match        
with    yield    ,    .    ;    :    =    =&gt;    &lt;-    &lt;:    &lt;%    
&gt;:    #    [    )    ]    }</code></pre>
<p>A <code class="sourceCode scala"><span class="kw">case</span></code> token can begin a statement only if followed by a <code class="sourceCode scala"><span class="kw">class</span></code> or <code class="sourceCode scala"><span class="kw">object</span></code> token.</p>
<p>Newlines are enabled in:</p>
<ol>
<li>all of a Scala source file, except for nested regions where newlines are disabled, and</li>
<li>the interval between matching <code>{</code> and <code>}</code> brace tokens, except for nested regions where newlines are disabled.</li>
</ol>
<p>Newlines are disabled in:</p>
<ol>
<li>the interval between matching <code>(</code> and <code>)</code> parenthesis tokens, except for nested regions where newlines are enabled, and</li>
<li>the interval between matching <code>[</code> and <code>]</code> bracket tokens, except for nested regions where newlines are enabled.</li>
<li>The interval between a <code class="sourceCode scala"><span class="kw">case</span></code> token and its matching <code class="sourceCode scala">=&gt;</code> token, except for nested regions where newlines are enabled.</li>
<li>Any regions analyzed in <a href="#xml-mode">XML mode</a>.</li>
</ol>
<p>Note that the brace characters of <code>{...}</code> escapes in XML and string literals are not tokens, and therefore do not enclose a region where newlines are enabled.</p>
<p>Normally, only a single <code>nl</code> token is inserted between two consecutive non-newline tokens which are on different lines, even if there are multiple lines between the two tokens. However, if two tokens are separated by at least one completely blank line (i.e a line which contains no printable characters), then two <code>nl</code> tokens are inserted.</p>
<p>The Scala grammar (given in full <a href="#scala-syntax-summary">here</a>) contains productions where optional <code>nl</code> tokens, but not semicolons, are accepted. This has the effect that a newline in one of these positions does not terminate an expression or statement. These positions can be summarized as follows:</p>
<p>Multiple newline tokens are accepted in the following places (note that a semicolon in place of the newline would be illegal in every one of these cases):</p>
<ul>
<li>between the condition of an conditional expression (<a href="#conditional-expressions">here</a>) or while loop (<a href="#while-loop-expressions">here</a>) and the next following expression,</li>
<li>between the enumerators of a for-comprehension (<a href="#for-comprehensions-and-for-loops">here</a>) and the next following expression, and</li>
<li>after the initial <code class="sourceCode scala"><span class="kw">type</span></code> keyword in a type definition or declaration (<a href="#type-declarations-and-type-aliases">here</a>).</li>
</ul>
<p>A single new line token is accepted</p>
<ul>
<li>in front of an opening brace ‘{’, if that brace is a legal continuation of the current statement or expression,</li>
<li>after an infix operator, if the first token on the next line can start an expression (<a href="#prefix-infix-and-postfix-operations">here</a>),</li>
<li>in front of a parameter clause (<a href="#function-declarations-and-definitions">here</a>), and</li>
<li>after an annotation (<a href="#user-defined-annotations">here</a>).</li>
</ul>
<ol start="3" type="1">
<li><p>The following code contains four well-formed statements, each on two lines. The newline tokens between the two lines are not treated as statement separators.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">if</span> (x &gt; <span class="dv">0</span>)
  x = x - <span class="dv">1</span>

<span class="kw">while</span> (x &gt; <span class="dv">0</span>)
  x  = x / <span class="dv">2</span>

<span class="kw">for</span> (x &lt;- <span class="dv">1</span> to <span class="dv">10</span>)
  <span class="fu">println</span>(x)

<span class="kw">type</span>
  IntList = List[Int]</code></pre></li>
<li><p>The following code designates an anonymous class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> Iterator[Int]
{
  <span class="kw">private</span> <span class="kw">var</span> x = <span class="dv">0</span>
  <span class="kw">def</span> hasNext = <span class="kw">true</span>
  <span class="kw">def</span> next = { x += <span class="dv">1</span>; x }
}</code></pre>
<p>With an additional newline character, the same code is interpreted as an object creation followed by a local block:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> Iterator[Int] 

{
  <span class="kw">private</span> <span class="kw">var</span> x = <span class="dv">0</span>
  <span class="kw">def</span> hasNext = <span class="kw">true</span>
  <span class="kw">def</span> next = { x += <span class="dv">1</span>; x }
}</code></pre></li>
<li><p>The following code designates a single expression:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  x &lt; <span class="dv">0</span> ||
  x &gt; <span class="dv">10</span></code></pre>
<p>With an additional newline character, the same code is interpreted as two expressions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  x &lt; <span class="dv">0</span> ||

  x &gt; <span class="dv">10</span></code></pre></li>
<li><p>The following code designates a single, curried function definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">func</span>(x: Int)
        (y: Int) = x + y</code></pre>
<p>With an additional newline character, the same code is interpreted as an abstract function definition and a syntactically illegal statement:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">func</span>(x: Int)

        (y: Int) = x + y</code></pre></li>
<li><p>The following code designates an attributed definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">@serializable
<span class="kw">protected</span> <span class="kw">class</span> Data { ... }</code></pre>
<p>With an additional newline character, the same code is interpreted as an attribute and a separate statement (which is syntactically illegal).</p>
<pre class="sourceCode scala"><code class="sourceCode scala">@serializable

<span class="kw">protected</span> <span class="kw">class</span> Data { ... }</code></pre></li>
</ol>
<h2 id="literals"><a href="#literals"><span class="header-section-number">1.3</span> Literals</a></h2>
<p>There are literals for integer numbers, floating point numbers, characters, booleans, symbols, strings. The syntax of these literals is in each case as in Java.</p>
<!-- TODO 
  say that we take values from Java, give examples of some lits in
  particular float and double. 
-->

<pre class="grammar"><code>Literal  ::=  [‘-’] integerLiteral
           |  [‘-’] floatingPointLiteral
           |  booleanLiteral
           |  characterLiteral
           |  stringLiteral
           |  symbolLiteral
           |  ‘null’</code></pre>
<h3 id="integer-literals"><a href="#integer-literals"><span class="header-section-number">1.3.1</span> Integer Literals</a></h3>
<pre class="grammar"><code>integerLiteral  ::=  (decimalNumeral | hexNumeral | octalNumeral) [‘L’ | ‘l’]
decimalNumeral  ::=  ‘0’ | nonZeroDigit {digit}
hexNumeral      ::=  ‘0’ ‘x’ hexDigit {hexDigit}
octalNumeral    ::=  ‘0’ octalDigit {octalDigit}
digit           ::=  ‘0’ | nonZeroDigit
nonZeroDigit    ::=  ‘1’ | … | ‘9’
octalDigit      ::=  ‘0’ | … | ‘7’</code></pre>
<p>Integer literals are usually of type <code class="sourceCode scala">Int</code>, or of type <code class="sourceCode scala">Long</code> when followed by a <code>L</code> or <code>l</code> suffix. Values of type <code class="sourceCode scala">Int</code> are all integer numbers between <span class="math">\(-2^{31}\)</span> and <span class="math">\(2^{31}-1\)</span>, inclusive. Values of type <code class="sourceCode scala">Long</code> are all integer numbers between <span class="math">\(-2^{63}\)</span> and <span class="math">\(2^{63}-1\)</span>, inclusive. A compile-time error occurs if an integer literal denotes a number outside these ranges.</p>
<p>However, if the expected type <a href="#expression-typing"><em>pt</em></a> of a literal in an expression is either <code class="sourceCode scala">Byte</code>, <code class="sourceCode scala">Short</code>, or <code class="sourceCode scala">Char</code> and the integer number fits in the numeric range defined by the type, then the number is converted to type <em>pt</em> and the literal's type is <em>pt</em>. The numeric ranges given by these types are:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">Byte</code></td>
<td style="text-align: left;"><span class="math">\(-2^7\)</span> to <span class="math">\(2^7-1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">Short</code></td>
<td style="text-align: left;"><span class="math">\(-2^{15}\)</span> to <span class="math">\(2^{15}-1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">Char</code></td>
<td style="text-align: left;"><span class="math">\(0\)</span> to <span class="math">\(2^{16}-1\)</span></td>
</tr>
</tbody>
</table>
<ol start="8" type="1">
<li><p>Here are some integer literals:</p>
<pre><code>0          21          0xFFFFFFFF       0777L</code></pre></li>
</ol>
<h3 id="floating-point-literals"><a href="#floating-point-literals"><span class="header-section-number">1.3.2</span> Floating Point Literals</a></h3>
<pre class="grammar"><code>floatingPointLiteral  ::=  digit {digit} ‘.’ {digit} [exponentPart] [floatType]
                        |  ‘.’ digit {digit} [exponentPart] [floatType]
                        |  digit {digit} exponentPart [floatType]
                        |  digit {digit} [exponentPart] floatType
exponentPart          ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit {digit}
floatType             ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’</code></pre>
<p>Floating point literals are of type <code class="sourceCode scala">Float</code> when followed by a floating point type suffix <code>F</code> or <code>f</code>, and are of type <code class="sourceCode scala">Double</code> otherwise. The type <code class="sourceCode scala">Float</code> consists of all IEEE 754 32-bit single-precision binary floating point values, whereas the type <code class="sourceCode scala">Double</code> consists of all IEEE 754 64-bit double-precision binary floating point values.</p>
<p>If a floating point literal in a program is followed by a token starting with a letter, there must be at least one intervening whitespace character between the two tokens.</p>
<ol start="9" type="1">
<li><p>Here are some floating point literals:</p>
<pre><code>0.0        1e30f      3.14159f      1.0e-100      .1</code></pre></li>
<li><p>The phrase <code class="sourceCode scala"><span class="fl">1.</span>toString</code> parses as three different tokens: <code class="sourceCode scala"><span class="dv">1</span></code>, <code class="sourceCode scala">.</code>, and <code class="sourceCode scala">toString</code>. On the other hand, if a space is inserted after the period, the phrase <code class="sourceCode scala"><span class="dv">1</span>. toString</code> parses as the floating point literal <code class="sourceCode scala"><span class="dv">1</span>.</code> followed by the identifier <code class="sourceCode scala">toString</code>.</p></li>
</ol>
<h3 id="boolean-literals"><a href="#boolean-literals"><span class="header-section-number">1.3.3</span> Boolean Literals</a></h3>
<pre class="grammar"><code>booleanLiteral  ::=  ‘true’ | ‘false’</code></pre>
<p>The boolean literals <code class="sourceCode scala"><span class="kw">true</span></code> and <code class="sourceCode scala"><span class="kw">false</span></code> are members of type <code class="sourceCode scala">Boolean</code>.</p>
<h3 id="character-literals"><a href="#character-literals"><span class="header-section-number">1.3.4</span> Character Literals</a></h3>
<pre class="grammar"><code>characterLiteral  ::=  ‘&#39;’ printableChar ‘&#39;’
                    |  ‘&#39;’ charEscapeSeq ‘&#39;’</code></pre>
<p>A character literal is a single character enclosed in quotes. The character is either a printable unicode character or is described by an <a href="#escape-sequences">escape sequence</a>.</p>
<ol start="11" type="1">
<li><p>Here are some character literals:</p>
<pre><code>&#39;a&#39;    &#39;\u0041&#39;    &#39;\n&#39;    &#39;\t&#39;</code></pre></li>
</ol>
<p>Note that <code>'\u000A'</code> is <em>not</em> a valid character literal because Unicode conversion is done before literal parsing and the Unicode character \u000A (line feed) is not a printable character. One can use instead the escape sequence <code>'\n'</code> or the octal escape <code>'\12'</code> (<a href="#escape-sequences">see here</a>).</p>
<h3 id="string-literals"><a href="#string-literals"><span class="header-section-number">1.3.5</span> String Literals</a></h3>
<pre class="grammar"><code>stringLiteral  ::=  ‘\&quot;’ {stringElement} ‘\&quot;’
stringElement  ::=  printableCharNoDoubleQuote  |  charEscapeSeq</code></pre>
<p>A string literal is a sequence of characters in double quotes. The characters are either printable unicode character or are described by <a href="#escape-sequences">escape sequences</a>. If the string literal contains a double quote character, it must be escaped, i.e. <code>&quot;\&quot;&quot;</code>. The value of a string literal is an instance of class <code class="sourceCode scala">String</code>.</p>
<ol start="12" type="1">
<li><p>Here are some string literals:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="st">&quot;Hello,</span><span class="ch">\n</span><span class="st">World!&quot;</span>       
<span class="st">&quot;This string contains a </span><span class="ch">\&quot;</span><span class="st"> character.&quot;</span></code></pre></li>
</ol>
<h4 id="multi-line-string-literals"><a href="#multi-line-string-literals"><span class="header-section-number">1.3.5.1</span> Multi-Line String Literals</a></h4>
<pre><code>stringLiteral   ::=  ‘&quot;&quot;&quot;’ multiLineChars ‘&quot;&quot;&quot;’
multiLineChars  ::=  {[‘&quot;’] [‘&quot;’] charNoDoubleQuote} {‘&quot;’}</code></pre>
<p>A multi-line string literal is a sequence of characters enclosed in triple quotes <code class="sourceCode scala"><span class="st">&quot;&quot;&quot; ... &quot;&quot;&quot;</span></code>. The sequence of characters is arbitrary, except that it may contain three or more consuctive quote characters only at the very end. Characters must not necessarily be printable; newlines or other control characters are also permitted. Unicode escapes work as everywhere else, but none of the escape sequences <a href="#escape-sequences">here</a> are interpreted.</p>
<ol start="13" type="1">
<li><p>Here is a multi-line string literal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="st">&quot;&quot;&quot;the present string</span>
     spans three 
     lines.<span class="st">&quot;&quot;&quot;</span></code></pre>
<p>This would produce the string:</p>
<pre><code>the present string
     spans three 
     lines.</code></pre></li>
</ol>
<p>The Scala library contains a utility method <code>stripMargin</code> which can be used to strip leading whitespace from multi-line strings. The expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala"> <span class="st">&quot;&quot;&quot;the present string</span>
    spans three 
    lines.<span class="st">&quot;&quot;&quot;.stripMargin</span></code></pre>
<p>evaluates to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">the present string
spans three 
lines.</code></pre>
<p>Method <code>stripMargin</code> is defined in class <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.StringLike">scala.collection.immutable.StringLike</a>. Because there is a predefined <a href="#implicit-conversions">implicit conversion</a> from <code class="sourceCode scala">String</code> to <code class="sourceCode scala">StringLike</code>, the method is applicable to all strings.</p>
<h3 id="escape-sequences"><a href="#escape-sequences"><span class="header-section-number">1.3.6</span> Escape Sequences</a></h3>
<p>The following escape sequences are recognized in character and string literals.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>\b</code></td>
<td style="text-align: left;"><code>\u0008</code>: backspace BS</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\t</code></td>
<td style="text-align: left;"><code>\u0009</code>: horizontal tab HT</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>\n</code></td>
<td style="text-align: left;"><code>\u000a</code>: linefeed LF</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\f</code></td>
<td style="text-align: left;"><code>\u000c</code>: form feed FF</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>\r</code></td>
<td style="text-align: left;"><code>\u000d</code>: carriage return CR</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\&quot;</code></td>
<td style="text-align: left;"><code>\u0022</code>: double quote &quot;</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>\'</code></td>
<td style="text-align: left;"><code>\u0027</code>: single quote '</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\\</code></td>
<td style="text-align: left;"><code>\u005c</code>: backslash <code>\</code></td>
</tr>
</tbody>
</table>
<p>A character with Unicode between 0 and 255 may also be represented by an octal escape, i.e. a backslash ‘’ followed by a sequence of up to three octal characters.</p>
<p>It is a compile time error if a backslash character in a character or string literal does not start a valid escape sequence.</p>
<h3 id="symbol-literals"><a href="#symbol-literals"><span class="header-section-number">1.3.7</span> Symbol literals</a></h3>
<pre class="grammar"><code>symbolLiteral  ::=  ‘&#39;’ plainid</code></pre>
<p>A symbol literal <code class="sourceCode scala">&#39;x</code> is a shorthand for the expression <code class="sourceCode scala">scala.<span class="fu">Symbol</span>(<span class="st">&quot;x&quot;</span>)</code>. <code>Symbol</code> is a <a href="#case-classes">case class</a>, which is defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Symbol <span class="kw">private</span> (name: String) {
  <span class="kw">override</span> <span class="kw">def</span> toString: String = <span class="st">&quot;&#39;&quot;</span> + name
}</code></pre>
<p>The <code class="sourceCode scala">apply</code> method of <code class="sourceCode scala">Symbol</code>'s companion object caches weak references to <code class="sourceCode scala">Symbol</code>s, thus ensuring that identical symbol literals are equivalent with respect to reference equality.</p>
<h2 id="whitespace-and-comments"><a href="#whitespace-and-comments"><span class="header-section-number">1.4</span> Whitespace and Comments</a></h2>
<p>Tokens may be separated by whitespace characters and/or comments. Comments come in two forms:</p>
<p>A single-line comment is a sequence of characters which starts with <code>//</code> and extends to the end of the line.</p>
<p>A multi-line comment is a sequence of characters between <code>/*</code> and <code>*/</code>. Multi-line comments may be nested, but are required to be properly nested. Therefore, a comment like <code>/* /* */</code> will be rejected as having an unterminated comment.</p>
<h2 id="xml-mode"><a href="#xml-mode"><span class="header-section-number">1.5</span> XML mode</a></h2>
<p>In order to allow literal inclusion of XML fragments, lexical analysis switches from Scala mode to XML mode when encountering an opening angle bracket '&lt;' in the following circumstance: The '&lt;' must be preceded either by whitespace, an opening parenthesis or an opening brace and immediately followed by a character starting an XML name.</p>
<pre class="grammar"><code> ( whitespace | ‘(’ | ‘{’ ) ‘&lt;’ (XNameStart | ‘!’ | ‘?’)

  XNameStart ::= ‘_’ | BaseChar | Ideographic // as in W3C XML, but without ‘:’</code></pre>
<p>The scanner switches from XML mode to Scala mode if either</p>
<ul>
<li>the XML expression or the XML pattern started by the initial ‘&lt;’ has been successfully parsed, or if</li>
<li>the parser encounters an embedded Scala expression or pattern and forces the Scanner back to normal mode, until the Scala expression or pattern is successfully parsed. In this case, since code and XML fragments can be nested, the parser has to maintain a stack that reflects the nesting of XML and Scala expressions adequately.</li>
</ul>
<p>Note that no Scala tokens are constructed in XML mode, and that comments are interpreted as text.</p>
<ol start="14" type="1">
<li><p>The following value definition uses an XML literal with two embedded Scala expressions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> b = &lt;book&gt;
          &lt;title&gt;The Scala Language Specification&lt;/title&gt;
          &lt;version&gt;{scalaBook.<span class="fu">version</span>}&lt;/version&gt;
          &lt;authors&gt;{scalaBook.<span class="fu">authors</span>.<span class="fu">mkList</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;, &quot;</span>, <span class="st">&quot;&quot;</span>)}&lt;/authors&gt;
        &lt;/book&gt;</code></pre></li>
</ol>
<h1 id="identifiers-names-and-scopes"><a href="#identifiers-names-and-scopes"><span class="header-section-number">2</span> Identifiers, Names and Scopes</a></h1>
<p>Names in Scala identify types, values, methods, and classes which are collectively called <em>entities</em>. Names are introduced by local <a href="#basic-declarations-and-definitions">definitions and declarations</a>, <a href="#class-members">inheritance</a>, <a href="#import-clauses">import clauses</a>, or <a href="#packagings">package clauses</a> which are collectively called <em>bindings</em>.</p>
<p>Bindings of different kinds have a precedence defined on them:</p>
<ol>
<li>Definitions and declarations that are local, inherited, or made available by a package clause in the same compilation unit where the definition occurs have highest precedence.</li>
<li>Explicit imports have next highest precedence.</li>
<li>Wildcard imports have next highest precedence.</li>
<li>Definitions made available by a package clause not in the compilation unit where the definition occurs have lowest precedence.</li>
</ol>
<p>There are two different name spaces, one for <a href="#types">types</a> and one for <a href="#expressions">terms</a>. The same name may designate a type and a term, depending on the context where the name is used.</p>
<p>A binding has a <em>scope</em> in which the entity defined by a single name can be accessed using a simple name. Scopes are nested. A binding in some inner scope <em>shadows</em> bindings of lower precedence in the same scope as well as bindings of the same or lower precedence in outer scopes.</p>
<p>Note that shadowing is only a partial order. In a situation like</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x = <span class="dv">1</span>;
{ <span class="kw">import</span> p.<span class="fu">x</span>; 
  x }</code></pre>
<p>neither binding of <code>x</code> shadows the other. Consequently, the reference to <code>x</code> in the third line above would be ambiguous.</p>
<p>A reference to an unqualified (type- or term-) identifier <span class="math">\(x\)</span> is bound by the unique binding, which</p>
<ul>
<li>defines an entity with name <span class="math">\(x\)</span> in the same namespace as the identifier, and</li>
<li>shadows all other bindings that define entities with name <span class="math">\(x\)</span> in that namespace.</li>
</ul>
<p>It is an error if no such binding exists. If <span class="math">\(x\)</span> is bound by an import clause, then the simple name <span class="math">\(x\)</span> is taken to be equivalent to the qualified name to which <span class="math">\(x\)</span> is mapped by the import clause. If <span class="math">\(x\)</span> is bound by a definition or declaration, then <span class="math">\(x\)</span> refers to the entity introduced by that binding. In that case, the type of <span class="math">\(x\)</span> is the type of the referenced entity.</p>
<ol start="15" type="1">
<li><p>Assume the following two definitions of a objects named <code>X</code> in packages <code>P</code> and <code>Q</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> P {
  <span class="kw">object</span> X { <span class="kw">val</span> x = <span class="dv">1</span>; <span class="kw">val</span> y = <span class="dv">2</span> }
}

<span class="kw">package</span> Q {
  <span class="kw">object</span> X { <span class="kw">val</span> x = <span class="kw">true</span>; <span class="kw">val</span> y = <span class="st">&quot;&quot;</span> }
}</code></pre>
<p>The following program illustrates different kinds of bindings and precedences between them.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> P {                  <span class="co">// `X&#39; bound by package clause</span>
<span class="kw">import</span> Console.<span class="fu">_</span>             <span class="co">// `println&#39; bound by wildcard import</span>
<span class="kw">object</span> A {                   
  <span class="fu">println</span>(<span class="st">&quot;L4: &quot;</span>+X)          <span class="co">// `X&#39; refers to `P.X&#39; here</span>
  <span class="kw">object</span> B {
    <span class="kw">import</span> Q.<span class="fu">_</span>               <span class="co">// `X&#39; bound by wildcard import</span>
    <span class="fu">println</span>(<span class="st">&quot;L7: &quot;</span>+X)        <span class="co">// `X&#39; refers to `Q.X&#39; here</span>
    <span class="kw">import</span> X.<span class="fu">_</span>               <span class="co">// `x&#39; and `y&#39; bound by wildcard import</span>
    <span class="fu">println</span>(<span class="st">&quot;L8: &quot;</span>+x)        <span class="co">// `x&#39; refers to `Q.X.x&#39; here</span>
    <span class="kw">object</span> C {
      <span class="kw">val</span> x = <span class="dv">3</span>              <span class="co">// `x&#39; bound by local definition</span>
      <span class="fu">println</span>(<span class="st">&quot;L12: &quot;</span>+x)     <span class="co">// `x&#39; refers to constant `3&#39; here</span>
      { <span class="kw">import</span> Q.<span class="fu">X</span>.<span class="fu">_</span>         <span class="co">// `x&#39; and `y&#39; bound by wildcard import</span>
<span class="co">//      println(&quot;L14: &quot;+x)   // reference to `x&#39; is ambiguous here</span>
        <span class="kw">import</span> X.<span class="fu">y</span>           <span class="co">// `y&#39; bound by explicit import</span>
        <span class="fu">println</span>(<span class="st">&quot;L16: &quot;</span>+y)   <span class="co">// `y&#39; refers to `Q.X.y&#39; here</span>
        { <span class="kw">val</span> x = <span class="st">&quot;abc&quot;</span>      <span class="co">// `x&#39; bound by local definition</span>
          <span class="kw">import</span> P.<span class="fu">X</span>.<span class="fu">_</span>       <span class="co">// `x&#39; and `y&#39; bound by wildcard import</span>
<span class="co">//        println(&quot;L19: &quot;+y) // reference to `y&#39; is ambiguous here</span>
          <span class="fu">println</span>(<span class="st">&quot;L20: &quot;</span>+x) <span class="co">// `x&#39; refers to string ``abc&#39;&#39; here</span>
}}}}}}</code></pre></li>
</ol>
<p>A reference to a qualified (type- or term-) identifier <span class="math">\(e.x\)</span> refers to the member of the type <span class="math">\(T\)</span> of <span class="math">\(e\)</span> which has the name <span class="math">\(x\)</span> in the same namespace as the identifier. It is an error if <span class="math">\(T\)</span> is not a <a href="#value-types">value type</a>. The type of <span class="math">\(e.x\)</span> is the member type of the referenced entity in <span class="math">\(T\)</span>.</p>
<h1 id="types"><a href="#types"><span class="header-section-number">3</span> Types</a></h1>
<pre class="grammar"><code>  Type              ::=  FunctionArgTypes ‘=&gt;’ Type
                      |  InfixType [ExistentialClause]
  FunctionArgTypes  ::= InfixType
                      | ‘(’ [ ParamType {‘,’ ParamType } ] ‘)’
  ExistentialClause ::=  ‘forSome’ ‘{’ ExistentialDcl {semi ExistentialDcl} ‘}’
  ExistentialDcl    ::=  ‘type’ TypeDcl 
                      |  ‘val’ ValDcl
  InfixType         ::=  CompoundType {id [nl] CompoundType}
  CompoundType      ::=  AnnotType {‘with’ AnnotType} [Refinement]
                      |  Refinement
  AnnotType         ::=  SimpleType {Annotation}
  SimpleType        ::=  SimpleType TypeArgs
                      |  SimpleType ‘#’ id
                      |  StableId
                      |  Path ‘.’ ‘type’
                      |  ‘(’ Types ‘)’
  TypeArgs          ::=  ‘[’ Types ‘]’
  Types             ::=  Type {‘,’ Type}</code></pre>
<p>We distinguish between first-order types and type constructors, which take type parameters and yield types. A subset of first-order types called <em>value types</em> represents sets of (first-class) values. Value types are either <em>concrete</em> or <em>abstract</em>.</p>
<p>Every concrete value type can be represented as a <em>class type</em>, i.e. a <a href="#type-designators">type designator</a> that refers to a <a href="#class-definitions">class or a trait</a>,<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> or as a <a href="#compound-types">compound type</a> representing an intersection of types, possibly with a <a href="#compound-types">refinement</a> that further constrains the types of its members. <!-- 
A shorthand exists for denoting [function types](#function-types) 
--> Abstract value types are introduced by <a href="#type-parameters">type parameters</a> and <a href="#type-declarations-and-type-aliases">abstract type bindings</a>. Parentheses in types can be used for grouping.</p>
<p>Non-value types capture properties of identifiers that <a href="#non-value-types">are not values</a>. For example, a <a href="#type-constructors">type constructor</a> does not directly specify a type of values. However, when a type constructor is applied to the correct type arguments, it yields a first-order type, which may be a value type.</p>
<p>Non-value types are expressed indirectly in Scala. E.g., a method type is described by writing down a method signature, which in itself is not a real type, although it gives rise to a corresponding <a href="#method-types">method type</a>. Type constructors are another example, as one can write <code class="sourceCode scala"><span class="kw">type</span> Swap[m[_, _], a,b] = m[b, a]</code>, but there is no syntax to write the corresponding anonymous type function directly.</p>
<h2 id="paths"><a href="#paths"><span class="header-section-number">3.1</span> Paths</a></h2>
<pre class="grammar"><code>Path            ::=  StableId
                  |  [id ‘.’] this
StableId        ::=  id
                  |  Path ‘.’ id
                  |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id
ClassQualifier  ::= ‘[’ id ‘]’</code></pre>
<p>Paths are not types themselves, but they can be a part of named types and in that function form a central role in Scala's type system.</p>
<p>A path is one of the following.</p>
<ul>
<li>The empty path ε (which cannot be written explicitly in user programs).</li>
<li><code>$C$.this</code>, where <span class="math">\(C\)</span> references a class. The path <code>this</code> is taken as a shorthand for <code>$C$.this</code> where <span class="math">\(C\)</span> is the name of the class directly enclosing the reference.</li>
<li><code>$p$.$x$</code> where <span class="math">\(p\)</span> is a path and <span class="math">\(x\)</span> is a stable member of <span class="math">\(p\)</span>. <em>Stable members</em> are packages or members introduced by object definitions or by value definitions of <a href="#volatile-types">non-volatile types</a>.</li>
<li><code>$C$.super.$x$</code> or <code>$C$.super[$M$].$x$</code> where <span class="math">\(C\)</span> references a class and <span class="math">\(x\)</span> references a stable member of the super class or designated parent class <span class="math">\(M\)</span> of <span class="math">\(C\)</span>. The prefix <code class="sourceCode scala"><span class="kw">super</span></code> is taken as a shorthand for <code>$C$.super</code> where <span class="math">\(C\)</span> is the name of the class directly enclosing the reference.</li>
</ul>
<p>A <em>stable identifier</em> is a path which ends in an identifier.</p>
<h2 id="value-types"><a href="#value-types"><span class="header-section-number">3.2</span> Value Types</a></h2>
<p>Every value in Scala has a type which is of one of the following forms.</p>
<h3 id="singleton-types"><a href="#singleton-types"><span class="header-section-number">3.2.1</span> Singleton Types</a></h3>
<pre class="grammar"><code>SimpleType  ::=  Path ‘.’ type</code></pre>
<p>A singleton type is of the form <code class="sourceCode scala">$p$.<span class="fu">type</span></code>, where <span class="math">\(p\)</span> is a path pointing to a value expected to <a href="#expression-typing">conform</a> to <code class="sourceCode scala">scala.<span class="fu">AnyRef</span></code>. The type denotes the set of values consisting of <code class="sourceCode scala"><span class="kw">null</span></code> and the value denoted by <span class="math">\(p\)</span>.</p>
<p>A <em>stable type</em> is either a singleton type or a type which is declared to be a subtype of trait <code class="sourceCode scala">scala.<span class="fu">Singleton</span></code>.</p>
<h3 id="type-projection"><a href="#type-projection"><span class="header-section-number">3.2.2</span> Type Projection</a></h3>
<pre class="grammar"><code>SimpleType  ::=  SimpleType ‘#’ id</code></pre>
<p>A type projection <code class="sourceCode scala">$T$#$x$</code> references the type member named <span class="math">\(x\)</span> of type <span class="math">\(T\)</span>.</p>
<!--
The following is no longer necessary:
If $x$ references an abstract type member, then $T$ must be a 
[stable type](#singleton-types)
-->

<h3 id="type-designators"><a href="#type-designators"><span class="header-section-number">3.2.3</span> Type Designators</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleType  ::=  StableId</code></pre>
<p>A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections.</p>
<p>Specifically, the unqualified type name <span class="math">\(t\)</span> where <span class="math">\(t\)</span> is bound in some class, object, or package <span class="math">\(C\)</span> is taken as a shorthand for <code class="sourceCode scala">$C$.<span class="fu">this</span>.<span class="fu">type</span>#$t$</code>. If <span class="math">\(t\)</span> is not bound in a class, object, or package, then <span class="math">\(t\)</span> is taken as a shorthand for <code>ε.type#$t$</code>.</p>
<p>A qualified type designator has the form <code>p.t</code> where <code>p</code> is a <a href="#paths">path</a> and <em>t</em> is a type name. Such a type designator is equivalent to the type projection <code class="sourceCode scala">p.<span class="fu">type</span>#t</code>.</p>
<ol start="16" type="1">
<li><p>Some type designators and their expansions are listed below. We assume a local type parameter <span class="math">\(t\)</span>, a value <code>maintable</code> with a type member <code>Node</code> and the standard class <code class="sourceCode scala">scala.<span class="fu">Int</span></code>,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">t</td>
<td style="text-align: left;">ε.type#t</td>
</tr>
<tr class="even">
<td style="text-align: left;">Int</td>
<td style="text-align: left;">scala.type#Int</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scala.Int</td>
<td style="text-align: left;">scala.type#Int</td>
</tr>
<tr class="even">
<td style="text-align: left;">data.maintable.Node</td>
<td style="text-align: left;">data.maintable.type#Node</td>
</tr>
</tbody>
</table></li>
</ol>
<h3 id="parameterized-types"><a href="#parameterized-types"><span class="header-section-number">3.2.4</span> Parameterized Types</a></h3>
<pre class="grammar"><code>SimpleType      ::=  SimpleType TypeArgs
TypeArgs        ::=  ‘[’ Types ‘]’</code></pre>
<p>A parameterized type <span class="math">\(T[ U_1 , \ldots , U_n ]\)</span> consists of a type designator <span class="math">\(T\)</span> and type parameters <span class="math">\(U_1 , \ldots , U_n\)</span> where <span class="math">\(n \geq 1\)</span>. <span class="math">\(T\)</span> must refer to a type constructor which takes <span class="math">\(n\)</span> type parameters <span class="math">\(a_1 , \ldots , a_n\)</span>.</p>
<p>Say the type parameters have lower bounds <span class="math">\(L_1 , \ldots , L_n\)</span> and upper bounds <span class="math">\(U_1 ,  \ldots , U_n\)</span>. The parameterized type is well-formed if each actual type parameter <em>conforms to its bounds</em>, i.e. <span class="math">\(σ L_i &lt;: T_i &lt;: σ U_i\)</span> where <span class="math">\(σ\)</span> is the substitution <span class="math">\([ a_1 := T_1 , \ldots , a_n := T_n ]\)</span>.</p>
<ol start="17" type="1">
<li><p>Given the partial type definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> TreeMap[A &lt;: Comparable[A], B] { … }
<span class="kw">class</span> List[A] { … }
<span class="kw">class</span> I <span class="kw">extends</span> Comparable[I] { … }

<span class="kw">class</span> F[M[_], X] { … }
<span class="kw">class</span> S[K &lt;: String] { … }
<span class="kw">class</span> G[M[ Z &lt;: I ], I] { … }</code></pre>
<p>the following parameterized types are well formed:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  TreeMap[I, String]
  List[I]
  List[List[Boolean]]

  F[List, Int]
  G[S, String]</code></pre></li>
<li><p>Given the type definitions of (17), the following types are ill-formed:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">TreeMap[I]            <span class="co">// illegal: wrong number of parameters</span>
TreeMap[List[I], Int] <span class="co">// illegal: type parameter not within bound</span>

F[Int, Boolean]       <span class="co">// illegal: Int is not a type constructor</span>
F[TreeMap, Int]       <span class="co">// illegal: TreeMap takes two parameters,</span>
                      <span class="co">//   F expects a constructor taking one</span>
G[S, Int]             <span class="co">// illegal: S constrains its parameter to</span>
                      <span class="co">//   conform to String,</span>
                      <span class="co">// G expects type constructor with a parameter</span>
                      <span class="co">//   that conforms to Int</span></code></pre></li>
</ol>
<h3 id="tuple-types"><a href="#tuple-types"><span class="header-section-number">3.2.5</span> Tuple Types</a></h3>
<pre class="grammar"><code>SimpleType    ::=   ‘(’ Types ‘)’</code></pre>
<p>A tuple type <span class="math">\((T_1 , \ldots , T_n)\)</span> is an alias for the class <code>scala.Tuple$_n$[$T_1$, … , $T_n$]</code>, where <span class="math">\(n \geq 2\)</span>.</p>
<p>Tuple classes are case classes whose fields can be accessed using selectors <code>_1</code> , … , <code>_n</code>. Their functionality is abstracted in a corresponding <code>Product</code> trait. The <em>n</em>-ary tuple class and product trait are defined at least as follows in the standard Scala library (they might also add other methods and implement other traits).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Tuple$n$[+T1, … , +$T_n$](_1: T1, … , _n: $T_n$) 
<span class="kw">extends</span> Product_n[T1, … , $T_n$] {}

<span class="kw">trait</span> Product_n[+T1, … , +$T_n$] {
  <span class="kw">override</span> <span class="kw">def</span> arity = $n$
  <span class="kw">def</span> _1: T1
  …
  <span class="kw">def</span> _n: $T_n$
}</code></pre>
<h3 id="annotated-types"><a href="#annotated-types"><span class="header-section-number">3.2.6</span> Annotated Types</a></h3>
<pre class="grammar"><code>AnnotType  ::=  SimpleType {Annotation}</code></pre>
<p>An annotated type <span class="math">\(T\)</span> <code>$a_1 , \ldots , a_n$</code> attaches <a href="#user-defined-annotations">annotations</a> <span class="math">\(a_1 , \ldots , a_n\)</span> to the type <span class="math">\(T\)</span>.</p>
<ol start="19" type="1">
<li><p>The following type adds the <code class="sourceCode scala">@suspendable</code> annotation to the type <code class="sourceCode scala">String</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">String @suspendable</code></pre></li>
</ol>
<h3 id="compound-types"><a href="#compound-types"><span class="header-section-number">3.2.7</span> Compound Types</a></h3>
<pre class="grammar"><code>CompoundType    ::=  AnnotType {‘with’ AnnotType} [Refinement]
                  |  Refinement
Refinement      ::=  [nl] ‘{’ RefineStat {semi RefineStat} ‘}’
RefineStat      ::=  Dcl
                  |  ‘type’ TypeDef
                  |</code></pre>
<p>A compound type <code>$T_1$ with … with $T_n$ { $R$ }</code> represents objects with members as given in the component types <span class="math">\(T_1 , \ldots , T_n\)</span> and the refinement <code>{ $R$ }</code>. A refinement <code>{ $R$ }</code> contains declarations and type definitions. If a declaration or definition overrides a declaration or definition in one of the component types <span class="math">\(T_1 , \ldots , T_n\)</span>, the usual rules for <a href="#overriding">overriding</a> apply; otherwise the declaration or definition is said to be “structural”.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p>Within a method declaration in a structural refinement, the type of any value parameter may only refer to type parameters or abstract types that are contained inside the refinement. That is, it must refer either to a type parameter of the method itself, or to a type definition within the refinement. This restriction does not apply to the function's result type.</p>
<p>If no refinement is given, the empty refinement is implicitly added, i.e.  <code class="sourceCode scala">$T_1$ <span class="kw">with</span> … <span class="kw">with</span> $T_n$</code> is a shorthand for <code class="sourceCode scala">$T_1$ <span class="kw">with</span> … <span class="kw">with</span> $T_n$ {}</code>.</p>
<p>A compound type may also consist of just a refinement <code>{ $R$ }</code> with no preceding component types. Such a type is equivalent to <code class="sourceCode scala">AnyRef{ R }</code>.</p>
<ol start="20" type="1">
<li><p>The following example shows how to declare and use a function which parameter's type contains a refinement with structural declarations.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Bird</span> (<span class="kw">val</span> name: String) <span class="kw">extends</span> Object {
    <span class="kw">def</span> <span class="fu">fly</span>(height: Int) = …
…
}
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Plane</span> (<span class="kw">val</span> callsign: String) <span class="kw">extends</span> Object {
    <span class="kw">def</span> <span class="fu">fly</span>(height: Int) = …
…
}
<span class="kw">def</span> <span class="fu">takeoff</span>(
        runway: Int,
      r: { <span class="kw">val</span> callsign: String; <span class="kw">def</span> <span class="fu">fly</span>(height: Int) }) = {
  tower.<span class="fu">print</span>(r.<span class="fu">callsign</span> + <span class="st">&quot; requests take-off on runway &quot;</span> + runway)
  tower.<span class="fu">read</span>(r.<span class="fu">callsign</span> + <span class="st">&quot; is clear for take-off&quot;</span>)
  r.<span class="fu">fly</span>(<span class="dv">1000</span>)
}
<span class="kw">val</span> bird = <span class="kw">new</span> <span class="fu">Bird</span>(<span class="st">&quot;Polly the parrot&quot;</span>){ <span class="kw">val</span> callsign = name }
<span class="kw">val</span> a380 = <span class="kw">new</span> <span class="fu">Plane</span>(<span class="st">&quot;TZ-987&quot;</span>)
<span class="fu">takeoff</span>(<span class="dv">42</span>, bird)
<span class="fu">takeoff</span>(<span class="dv">89</span>, a380)</code></pre>
<p>Although <code>Bird</code> and <code>Plane</code> do not share any parent class other than <code>Object</code>, the parameter <em>r</em> of function <code>takeoff</code> is defined using a refinement with structural declarations to accept any object that declares a value <code>callsign</code> and a <code>fly</code> function.</p></li>
</ol>
<h3 id="infix-types"><a href="#infix-types"><span class="header-section-number">3.2.8</span> Infix Types</a></h3>
<pre class="grammar"><code>InfixType     ::=  CompoundType {id [nl] CompoundType}</code></pre>
<p>An infix type <code>$T_1$ \mathit{op} $T_2$</code> consists of an infix operator <span class="math">\(\mathit{op}\)</span> which gets applied to two type operands <span class="math">\(T_1\)</span> and <span class="math">\(T_2\)</span>. The type is equivalent to the type application <code>$\mathit{op}$[$T_1$, $T_2$]</code>. The infix operator <span class="math">\(\mathit{op}\)</span> may be an arbitrary identifier, except for <code>*</code>, which is reserved as a postfix modifier denoting a <a href="#repeated-parameters">repeated parameter type</a>.</p>
<p>All type infix operators have the same precedence; parentheses have to be used for grouping. The <a href="#prefix-infix-and-postfix-operations">associativity</a> of a type operator is determined as for term operators: type operators ending in a colon ‘:’ are right-associative; all other operators are left-associative.</p>
<p>In a sequence of consecutive type infix operations <span class="math">\(t_0 \, \mathit{op} \, t_1 \, \mathit{op_2} \, \ldots \, \mathit{op_n} \, t_n\)</span>, all operators <span class="math">\(\mathit{op}_1 , \ldots , \mathit{op}_n\)</span> must have the same associativity. If they are all left-associative, the sequence is interpreted as <span class="math">\((\ldots (t_0 \mathit{op_1} t_1) \mathit{op_2} \ldots) \mathit{op_n} t_n\)</span>, otherwise it is interpreted as <span class="math">\(t_0 \mathit{op_1} (t_1 \mathit{op_2} ( \ldots \mathit{op_n} t_n) \ldots)\)</span>.</p>
<h3 id="function-types"><a href="#function-types"><span class="header-section-number">3.2.9</span> Function Types</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">Type              ::=  FunctionArgs ‘=&gt;’ Type
FunctionArgs      ::=  InfixType
                    |  ‘(’ [ ParamType {‘,’ ParamType } ] ‘)’</code></pre>
<p>The type <span class="math">\((T_1 , \ldots , T_n) \Rightarrow U\)</span> represents the set of function values that take arguments of types <span class="math">\(T1 , \ldots , Tn\)</span> and yield results of type <span class="math">\(U\)</span>. In the case of exactly one argument type <span class="math">\(T \Rightarrow U\)</span> is a shorthand for <span class="math">\((T) \Rightarrow U\)</span>.<br />An argument type of the form <span class="math">\(\Rightarrow T\)</span> represents a <a href="#by-name-parameters">call-by-name parameter</a> of type <span class="math">\(T\)</span>.</p>
<p>Function types associate to the right, e.g. <span class="math">\(S \Rightarrow T \Rightarrow U\)</span> is the same as <span class="math">\(S \Rightarrow (T \Rightarrow U)\)</span>.</p>
<p>Function types are shorthands for class types that define <code>apply</code> functions. Specifically, the <span class="math">\(n\)</span>-ary function type <span class="math">\((T_1 , \ldots , T_n) \Rightarrow U\)</span> is a shorthand for the class type <code>Function$_n$[T1 , … , $T_n$, U]</code>. Such class types are defined in the Scala library for <span class="math">\(n\)</span> between 0 and 9 as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">trait</span> Function_n[-T1 , … , -T$_n$, +R] {
  <span class="kw">def</span> <span class="fu">apply</span>(x1: T1 , … , x$_n$: T$_n$): R 
  <span class="kw">override</span> <span class="kw">def</span> toString = <span class="st">&quot;&lt;function&gt;&quot;</span> 
}</code></pre>
<p>Hence, function types are <a href="#variance-annotations">covariant</a> in their result type and contravariant in their argument types.</p>
<h3 id="existential-types"><a href="#existential-types"><span class="header-section-number">3.2.10</span> Existential Types</a></h3>
<pre class="grammar"><code>Type               ::= InfixType ExistentialClauses
ExistentialClauses ::= ‘forSome’ ‘{’ ExistentialDcl 
                       {semi ExistentialDcl} ‘}’
ExistentialDcl     ::= ‘type’ TypeDcl 
                    |  ‘val’ ValDcl</code></pre>
<p>An existential type has the form <code>$T$ forSome { $Q$ }</code> where <span class="math">\(Q\)</span> is a sequence of <a href="#type-declarations-and-type-aliases">type declarations</a>.</p>
<p>Let <span class="math">\(t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1 , \ldots , t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n\)</span> be the types declared in <span class="math">\(Q\)</span> (any of the type parameter sections <code>[ $\mathit{tps}_i$ ]</code> might be missing). The scope of each type <span class="math">\(t_i\)</span> includes the type <span class="math">\(T\)</span> and the existential clause <span class="math">\(Q\)</span>. The type variables <span class="math">\(t_i\)</span> are said to be <em>bound</em> in the type <code>$T$ forSome { $Q$ }</code>. Type variables which occur in a type <span class="math">\(T\)</span> but which are not bound in <span class="math">\(T\)</span> are said to be <em>free</em> in <span class="math">\(T\)</span>.</p>
<p>A <em>type instance</em> of <code>$T$ forSome { $Q$ }</code> is a type <span class="math">\(\sigma T\)</span> where <span class="math">\(\sigma\)</span> is a substitution over <span class="math">\(t_1 , \ldots , t_n\)</span> such that, for each <span class="math">\(i\)</span>, <span class="math">\(\sigma L_i &lt;: \sigma t_i &lt;: \sigma U_i\)</span>. The set of values denoted by the existential type <code>$T$ forSome {$\,Q\,$}</code> is the union of the set of values of all its type instances.</p>
<p>A <em>skolemization</em> of <code>$T$ forSome { $Q$ }</code> is a type instance <span class="math">\(\sigma T\)</span>, where <span class="math">\(\sigma\)</span> is the substitution <span class="math">\([t&#39;_1/t_1 , \ldots , t&#39;_n/t_n]\)</span> and each <span class="math">\(t&#39;_i\)</span> is a fresh abstract type with lower bound <span class="math">\(\sigma L_i\)</span> and upper bound <span class="math">\(\sigma U_i\)</span>.</p>
<h4 id="simplification-rules"><a href="#simplification-rules"><span class="header-section-number">3.2.10.1</span> Simplification Rules</a></h4>
<p>Existential types obey the following four equivalences:</p>
<ol>
<li>Multiple for-clauses in an existential type can be merged. E.g., <code>$T$ forSome { $Q$ } forSome { $Q'$ }</code> is equivalent to <code>$T$ forSome { $Q$ ; $Q'$}</code>.</li>
<li>Unused quantifications can be dropped. E.g., <code>$T$ forSome { $Q$ ; $Q'$}</code> where none of the types defined in <span class="math">\(Q&#39;\)</span> are referred to by <span class="math">\(T\)</span> or <span class="math">\(Q\)</span>, is equivalent to <code>$T$ forSome {$ Q $}</code>.</li>
<li>An empty quantification can be dropped. E.g., <code>$T$ forSome { }</code> is equivalent to <span class="math">\(T\)</span>.</li>
<li>An existential type <code>$T$ forSome { $Q$ }</code> where <span class="math">\(Q\)</span> contains a clause <code>type $t[\mathit{tps}] &gt;: L &lt;: U$</code> is equivalent to the type <code>$T'$ forSome { $Q$ }</code> where <span class="math">\(T&#39;\)</span> results from <span class="math">\(T\)</span> by replacing every <a href="#variance-annotations">covariant occurrence</a> of <span class="math">\(t\)</span> in <span class="math">\(T\)</span> by <span class="math">\(U\)</span> and by replacing every contravariant occurrence of <span class="math">\(t\)</span> in <span class="math">\(T\)</span> by <span class="math">\(L\)</span>.</li>
</ol>
<h4 id="existential-quantification-over-values"><a href="#existential-quantification-over-values"><span class="header-section-number">3.2.10.2</span> Existential Quantification over Values</a></h4>
<p>As a syntactic convenience, the bindings clause in an existential type may also contain value declarations <code>val $x$: $T$</code>. An existential type <code>$T$ forSome { $Q$; val $x$: $S\,$;$\,Q'$ }</code> is treated as a shorthand for the type <code>$T'$ forSome { $Q$; type $t$ &lt;: $S$ with Singleton; $Q'$ }</code>, where <span class="math">\(t\)</span> is a fresh type name and <span class="math">\(T&#39;\)</span> results from <span class="math">\(T\)</span> by replacing every occurrence of <code>$x$.type</code> with <span class="math">\(t\)</span>.</p>
<h4 id="placeholder-syntax-for-existential-types"><a href="#placeholder-syntax-for-existential-types"><span class="header-section-number">3.2.10.3</span> Placeholder Syntax for Existential Types</a></h4>
<pre class="grammar"><code>WildcardType   ::=  ‘_’ TypeBounds</code></pre>
<p>Scala supports a placeholder syntax for existential types. A <em>wildcard type</em> is of the form <code>_$\;$&gt;:$\,L\,$&lt;:$\,U$</code>. Both bound clauses may be omitted. If a lower bound clause <code>&gt;:$\,L$</code> is missing, <code>&gt;:$\,$scala.Nothing</code> is assumed. If an upper bound clause <code>&lt;:$\,U$</code> is missing, <code>&lt;:$\,$scala.Any</code> is assumed. A wildcard type is a shorthand for an existentially quantified type variable, where the existential quantification is implicit.</p>
<p>A wildcard type must appear as type argument of a parameterized type. Let <span class="math">\(T = p.c[\mathit{targs},T,\mathit{targs}&#39;]\)</span> be a parameterized type where <span class="math">\(\mathit{targs}, \mathit{targs}&#39;\)</span> may be empty and <span class="math">\(T\)</span> is a wildcard type <code>_$\;$&gt;:$\,L\,$&lt;:$\,U$</code>. Then <span class="math">\(T\)</span> is equivalent to the existential type</p>
<pre><code>$p.c[\mathit{targs},t,\mathit{targs}&#39;]$ forSome { type $t$ &gt;: $L$ &lt;: $U$ }</code></pre>
<p>where <span class="math">\(t\)</span> is some fresh type variable. Wildcard types may also appear as parts of <a href="#infix-types">infix types</a> , <a href="#function-types">function types</a>, or <a href="#tuple-types">tuple types</a>. Their expansion is then the expansion in the equivalent parameterized type.</p>
<ol start="21" type="1">
<li><p>Assume the class definitions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Ref[T]
<span class="kw">abstract</span> <span class="kw">class</span> Outer { <span class="kw">type</span> T } .</code></pre>
<p>Here are some examples of existential types:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Ref[T] <span class="kw">forSome</span> { <span class="kw">type</span> T &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span> }
Ref[x.<span class="fu">T</span>] <span class="kw">forSome</span> { <span class="kw">val</span> x: Outer }
Ref[x_type # T] <span class="kw">forSome</span> { <span class="kw">type</span> x_type &lt;: Outer <span class="kw">with</span> Singleton }</code></pre>
<p>The last two types in this list are equivalent. An alternative formulation of the first type above using wildcard syntax is:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Ref[_ &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span>]</code></pre></li>
<li><p>The type <code>List[List[_]]</code> is equivalent to the existential type</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[List[t] <span class="kw">forSome</span> { <span class="kw">type</span> t }] . </code></pre></li>
<li><p>Assume a covariant type</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> List[+T]</code></pre>
<p>The type</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[T] <span class="kw">forSome</span> { <span class="kw">type</span> T &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span> }</code></pre>
<p>is equivalent (by simplification rule 4 above) to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[java.<span class="fu">lang</span>.<span class="fu">Number</span>] <span class="kw">forSome</span> { <span class="kw">type</span> T &lt;: java.<span class="fu">lang</span>.<span class="fu">Number</span> }</code></pre>
<p>which is in turn equivalent (by simplification rules 2 and 3 above) to <code>List[java.lang.Number]</code>.</p></li>
</ol>
<h2 id="non-value-types"><a href="#non-value-types"><span class="header-section-number">3.3</span> Non-Value Types</a></h2>
<p>The types explained in the following do not denote sets of values, nor do they appear explicitly in programs. They are introduced in this report as the internal types of defined identifiers.</p>
<h3 id="method-types"><a href="#method-types"><span class="header-section-number">3.3.1</span> Method Types</a></h3>
<p>A method type is denoted internally as <span class="math">\((\mathit{Ps})U\)</span>, where <span class="math">\((\mathit{Ps})\)</span> is a sequence of parameter names and types <span class="math">\((p_1:T_1 , \ldots , p_n:T_n)\)</span> for some <span class="math">\(n \geq 0\)</span> and <span class="math">\(U\)</span> is a (value or method) type. This type represents named methods that take arguments named <span class="math">\(p_1 , \ldots , p_n\)</span> of types <span class="math">\(T_1 , \ldots , T_n\)</span> and that return a result of type <span class="math">\(U\)</span>.</p>
<p>Method types associate to the right: <span class="math">\((\mathit{Ps}_1)(\mathit{Ps}_2)U\)</span> is treated as <span class="math">\((\mathit{Ps}_1)((\mathit{Ps}_2)U)\)</span>.</p>
<p>A special case are types of methods without any parameters. They are written here <code>=&gt; T</code>. Parameterless methods name expressions that are re-evaluated each time the parameterless method name is referenced.</p>
<p>Method types do not exist as types of values. If a method name is used as a value, its type is <a href="#implicit-conversions">implicitly converted</a> to a corresponding function type.</p>
<ol start="24" type="1">
<li><p>The declarations</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> a: Int
<span class="kw">def</span> <span class="fu">b</span> (x: Int): Boolean
<span class="kw">def</span> <span class="fu">c</span> (x: Int) (y: String, z: String): String</code></pre>
<p>produce the typings</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a: =&gt; Int
b: (Int) Boolean
c: (Int) (String, String) String</code></pre></li>
</ol>
<h3 id="polymorphic-method-types"><a href="#polymorphic-method-types"><span class="header-section-number">3.3.2</span> Polymorphic Method Types</a></h3>
<p>A polymorphic method type is denoted internally as <code>[$\mathit{tps}\,$]$T$</code> where <code>[$\mathit{tps}\,$]</code> is a type parameter section <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]</code> for some <span class="math">\(n \geq 0\)</span> and <span class="math">\(T\)</span> is a (value or method) type. This type represents named methods that take type arguments <code>$S_1 , \ldots , S_n$</code> which <a href="#parameterized-types">conform</a> to the lower bounds <code>$L_1 , \ldots , L_n$</code> and the upper bounds <code>$U_1 , \ldots , U_n$</code> and that yield results of type <span class="math">\(T\)</span>.</p>
<ol start="25" type="1">
<li><p>The declarations</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> empty[A]: List[A]
<span class="kw">def</span> union[A &lt;: Comparable[A]] (x: Set[A], xs: Set[A]): Set[A]</code></pre>
<p>produce the typings</p>
<pre class="sourceCode scala"><code class="sourceCode scala">empty : [A &gt;: Nothing &lt;: Any] List[A]
union : [A &gt;: Nothing &lt;: Comparable[A]] (x: Set[A], xs: Set[A]) Set[A]  .</code></pre></li>
</ol>
<h3 id="type-constructors"><a href="#type-constructors"><span class="header-section-number">3.3.3</span> Type Constructors</a></h3>
<p>A type constructor is represented internally much like a polymorphic method type. <code>[$\pm$ $a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , \pm a_n$ &gt;: $L_n$ &lt;: $U_n$] $T$</code> represents a type that is expected by a <a href="#type-params">type constructor parameter</a> or an <a href="#type-declarations-and-type-aliases">abstract type constructor binding</a> with the corresponding type parameter clause.</p>
<ol start="26" type="1">
<li><p>Consider this fragment of the <code class="sourceCode scala">Iterable[+X]</code> class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Iterable[+X] {
  <span class="kw">def</span> flatMap[newType[+X] &lt;: Iterable[X], S](f: X =&gt; newType[S]): newType[S]
}</code></pre>
<p>Conceptually, the type constructor <code>Iterable</code> is a name for the anonymous type <code>[+X] Iterable[X]</code>, which may be passed to the <code>newType</code> type constructor parameter in <code>flatMap</code>.</p></li>
</ol>
<h2 id="base-types-and-member-definitions"><a href="#base-types-and-member-definitions"><span class="header-section-number">3.4</span> Base Types and Member Definitions</a></h2>
<p>Types of class members depend on the way the members are referenced. Central here are three notions, namely: #. the notion of the set of base types of a type <span class="math">\(T\)</span>, #. the notion of a type <span class="math">\(T\)</span> in some class <span class="math">\(C\)</span> seen from some prefix type <span class="math">\(S\)</span>, #. the notion of the set of member bindings of some type <span class="math">\(T\)</span>.</p>
<p>These notions are defined mutually recursively as follows.</p>
<ol>
<li><p>The set of <em>base types</em> of a type is a set of class types, given as follows.</p>
<ul>
<li>The base types of a class type <span class="math">\(C\)</span> with parents <span class="math">\(T_1 , \ldots , T_n\)</span> are <span class="math">\(C\)</span> itself, as well as the base types of the compound type <code>$T_1$ with … with $T_n$ { $R$ }</code>.</li>
<li>The base types of an aliased type are the base types of its alias.</li>
<li>The base types of an abstract type are the base types of its upper bound.</li>
<li>The base types of a parameterized type <code>$C$[$T_1 , \ldots , T_n$]</code> are the base types of type <span class="math">\(C\)</span>, where every occurrence of a type parameter <span class="math">\(a_i\)</span> of <span class="math">\(C\)</span> has been replaced by the corresponding parameter type <span class="math">\(T_i\)</span>.</li>
<li>The base types of a singleton type <code>$p$.type</code> are the base types of the type of <span class="math">\(p\)</span>.</li>
<li>The base types of a compound type <code>$T_1$ with $\ldots$ with $T_n$ { $R$ }</code> are the <em>reduced union</em> of the base classes of all <span class="math">\(T_i\)</span>'s. This means: Let the multi-set <span class="math">\(\mathscr{S}\)</span> be the multi-set-union of the base types of all <span class="math">\(T_i\)</span>'s. If <span class="math">\(\mathscr{S}\)</span> contains several type instances of the same class, say <code>$S^i$#$C$[$T^i_1 , \ldots , T^i_n$]</code> <span class="math">\((i \in I)\)</span>, then all those instances are replaced by one of them which conforms to all others. It is an error if no such instance exists. It follows that the reduced union, if it exists, produces a set of class types, where different types are instances of different classes.</li>
<li>The base types of a type selection <code>$S$#$T$</code> are determined as follows. If <span class="math">\(T\)</span> is an alias or abstract type, the previous clauses apply. Otherwise, <span class="math">\(T\)</span> must be a (possibly parameterized) class type, which is defined in some class <span class="math">\(B\)</span>. Then the base types of <code>$S$#$T$</code> are the base types of <span class="math">\(T\)</span> in <span class="math">\(B\)</span> seen from the prefix type <span class="math">\(S\)</span>.</li>
<li>The base types of an existential type <code>$T$ forSome { $Q$ }</code> are all types <code>$S$ forSome { $Q$ }</code> where <span class="math">\(S\)</span> is a base type of <span class="math">\(T\)</span>.</li>
</ul></li>
<li>The notion of a type <span class="math">\(T\)</span> <em>in class <span class="math">\(C\)</span> seen from some prefix type <span class="math">\(S\)</span></em> makes sense only if the prefix type <span class="math">\(S\)</span> has a type instance of class <span class="math">\(C\)</span> as a base type, say <code>$S'$#$C$[$T_1 , \ldots , T_n$]</code>. Then we define as follows.
<ul>
<li>If <code>$S$ = $\epsilon$.type</code>, then <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is <span class="math">\(T\)</span> itself.</li>
<li>Otherwise, if <span class="math">\(S\)</span> is an existential type <code>$S'$ forSome { $Q$ }</code>, and <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S&#39;\)</span> is <span class="math">\(T&#39;\)</span>, then <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is <code>$T'$ forSome {$\,Q\,$}</code>.</li>
<li>Otherwise, if <span class="math">\(T\)</span> is the <span class="math">\(i\)</span>'th type parameter of some class <span class="math">\(D\)</span>, then
<ul>
<li>If <span class="math">\(S\)</span> has a base type <code>$D$[$U_1 , \ldots , U_n$]</code>, for some type parameters <code>[$U_1 , \ldots , U_n$]</code>, then <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is <span class="math">\(U_i\)</span>.</li>
<li>Otherwise, if <span class="math">\(C\)</span> is defined in a class <span class="math">\(C&#39;\)</span>, then <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is the same as <span class="math">\(T\)</span> in <span class="math">\(C&#39;\)</span> seen from <span class="math">\(S&#39;\)</span>.</li>
<li>Otherwise, if <span class="math">\(C\)</span> is not defined in another class, then<br /> <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is <span class="math">\(T\)</span> itself.</li>
</ul></li>
<li>Otherwise, if <span class="math">\(T\)</span> is the singleton type <code>$D$.this.type</code> for some class <span class="math">\(D\)</span> then
<ul>
<li>If <span class="math">\(D\)</span> is a subclass of <span class="math">\(C\)</span> and <span class="math">\(S\)</span> has a type instance of class <span class="math">\(D\)</span> among its base types, then <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is <span class="math">\(S\)</span>.</li>
<li>Otherwise, if <span class="math">\(C\)</span> is defined in a class <span class="math">\(C&#39;\)</span>, then <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is the same as <span class="math">\(T\)</span> in <span class="math">\(C&#39;\)</span> seen from <span class="math">\(S&#39;\)</span>.</li>
<li>Otherwise, if <span class="math">\(C\)</span> is not defined in another class, then<br /> <span class="math">\(T\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(S\)</span> is <span class="math">\(T\)</span> itself.</li>
</ul></li>
<li>If <span class="math">\(T\)</span> is some other type, then the described mapping is performed to all its type components.</li>
</ul>
<p>If <span class="math">\(T\)</span> is a possibly parameterized class type, where <span class="math">\(T\)</span>'s class is defined in some other class <span class="math">\(D\)</span>, and <span class="math">\(S\)</span> is some prefix type, then we use <code>$T$ seen from $S$'' as a shorthand for</code><span class="math">\(T\)</span> in <span class="math">\(D\)</span> seen from <span class="math">\(S\)</span>''.</p></li>
<li><p>The <em>member bindings</em> of a type <span class="math">\(T\)</span> are (1) all bindings <span class="math">\(d\)</span> such that there exists a type instance of some class <span class="math">\(C\)</span> among the base types of <span class="math">\(T\)</span> and there exists a definition or declaration <span class="math">\(d&#39;\)</span> in <span class="math">\(C\)</span> such that <span class="math">\(d\)</span> results from <span class="math">\(d&#39;\)</span> by replacing every type <span class="math">\(T&#39;\)</span> in <span class="math">\(d&#39;\)</span> by <span class="math">\(T&#39;\)</span> in <span class="math">\(C\)</span> seen from <span class="math">\(T\)</span>, and (2) all bindings of the type's <a href="#compound-types">refinement</a>, if it has one.</p></li>
</ol>
<p>The <em>definition</em> of a type projection <code>$S$#$t$</code> is the member binding <span class="math">\(d_t\)</span> of the type <span class="math">\(t\)</span> in <span class="math">\(S\)</span>. In that case, we also say that ~<span class="math">\(S\)</span>#<span class="math">\(t\)</span>` <em>is defined by</em> <span class="math">\(d_t\)</span>. share a to</p>
<h2 id="relations-between-types"><a href="#relations-between-types"><span class="header-section-number">3.5</span> Relations between types</a></h2>
<p>We define two relations between types.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Type equivalence</td>
<td style="text-align: left;"><span class="math">\(T \equiv U\)</span></td>
<td style="text-align: left;"><span class="math">\(T\)</span> and <span class="math">\(U\)</span> are interchangeable in all contexts.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Conformance</td>
<td style="text-align: left;"><span class="math">\(T &lt;: U\)</span></td>
<td style="text-align: left;">Type <span class="math">\(T\)</span> conforms to type <span class="math">\(U\)</span>.</td>
</tr>
</tbody>
</table>
<h3 id="type-equivalence"><a href="#type-equivalence"><span class="header-section-number">3.5.1</span> Type Equivalence</a></h3>
<p>Equivalence <span class="math">\((\equiv)\)</span> between types is the smallest congruence<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> such that the following holds:</p>
<ul>
<li>If <span class="math">\(t\)</span> is defined by a type alias <code>type $t$ = $T$</code>, then <span class="math">\(t\)</span> is equivalent to <span class="math">\(T\)</span>.</li>
<li>If a path <span class="math">\(p\)</span> has a singleton type <code>$q$.type</code>, then <code>$p$.type $\equiv q$.type</code>.</li>
<li>If <span class="math">\(O\)</span> is defined by an object definition, and <span class="math">\(p\)</span> is a path consisting only of package or object selectors and ending in <span class="math">\(O\)</span>, then <code>$O$.this.type $\equiv p$.type</code>.</li>
<li>Two <a href="#compound-types">compound types</a> are equivalent if the sequences of their component are pairwise equivalent, and occur in the same order, and their refinements are equivalent. Two refinements are equivalent if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements.</li>
<li>Two <a href="#method-types">method types</a> are equivalent if they have equivalent result types, both have the same number of parameters, and corresponding parameters have equivalent types. Note that the names of parameters do not matter for method type equivalence.</li>
<li>Two <a href="#polymorphic-method-types">polymorphic method types</a> are equivalent if they have the same number of type parameters, and, after renaming one set of type parameters by another, the result types as well as lower and upper bounds of corresponding type parameters are equivalent.</li>
<li>Two <a href="#existential-types">existential types</a> are equivalent if they have the same number of quantifiers, and, after renaming one list of type quantifiers by another, the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent.</li>
<li>Two <a href="#type-constructors">type constructors</a> are equivalent if they have the same number of type parameters, and, after renaming one list of type parameters by another, the result types as well as variances, lower and upper bounds of corresponding type parameters are equivalent.</li>
</ul>
<h3 id="conformance"><a href="#conformance"><span class="header-section-number">3.5.2</span> Conformance</a></h3>
<p>The conformance relation <span class="math">\((&lt;:)\)</span> is the smallest transitive relation that satisfies the following conditions.</p>
<ul>
<li>Conformance includes equivalence. If <span class="math">\(T \equiv U\)</span> then <span class="math">\(T &lt;: U\)</span>.</li>
<li>For every value type <span class="math">\(T\)</span>, <code>scala.Nothing &lt;: $T$ &lt;: scala.Any</code>.</li>
<li><p>For every type constructor <span class="math">\(T\)</span> (with any number of type parameters), <code>scala.Nothing &lt;: $T$ &lt;: scala.Any</code>.</p></li>
<li>For every class type <span class="math">\(T\)</span> such that <code>$T$ &lt;: scala.AnyRef</code> and not <code>$T$ &lt;: scala.NotNull</code> one has <code>scala.Null &lt;: $T$</code>.</li>
<li>A type variable or abstract type <span class="math">\(t\)</span> conforms to its upper bound and its lower bound conforms to <span class="math">\(t\)</span>.</li>
<li>A class type or parameterized type conforms to any of its base-types.</li>
<li>A singleton type <code>$p$.type</code> conforms to the type of the path <span class="math">\(p\)</span>.</li>
<li>A singleton type <code>$p$.type</code> conforms to the type <code>scala.Singleton</code>.</li>
<li>A type projection <code>$T$#$t$</code> conforms to <code>$U$#$t$</code> if <span class="math">\(T\)</span> conforms to <span class="math">\(U\)</span>.</li>
<li>A parameterized type <code>$T$[$T_1$ , … , $T_n$]</code> conforms to <code>$T$[$U_1$ , … , $U_n$]</code> if the following three conditions hold for <span class="math">\(i \in \{ 1 , \ldots , n \}\)</span>:
<ol>
<li>If the <span class="math">\(i\)</span>'th type parameter of <span class="math">\(T\)</span> is declared covariant, then <span class="math">\(T_i &lt;: U_i\)</span>.</li>
<li>If the <span class="math">\(i\)</span>'th type parameter of <span class="math">\(T\)</span> is declared contravariant, then <span class="math">\(U_i &lt;: T_i\)</span>.</li>
<li>If the <span class="math">\(i\)</span>'th type parameter of <span class="math">\(T\)</span> is declared neither covariant nor contravariant, then <span class="math">\(U_i \equiv T_i\)</span>.</li>
</ol></li>
<li>A compound type <code>$T_1$ with $\ldots$ with $T_n$ {$R\,$}</code> conforms to each of its component types <span class="math">\(T_i\)</span>.</li>
<li>If <span class="math">\(T &lt;: U_i\)</span> for <span class="math">\(i \in \{ 1 , \ldots , n \}\)</span> and for every binding <span class="math">\(d\)</span> of a type or value <span class="math">\(x\)</span> in <span class="math">\(R\)</span> there exists a member binding of <span class="math">\(x\)</span> in <span class="math">\(T\)</span> which subsumes <span class="math">\(d\)</span>, then <span class="math">\(T\)</span> conforms to the compound type <code>$U_1$ with $\ldots$ with $U_n$ {$R\,$}</code>.</li>
<li>The existential type <code>$T$ forSome {$\,Q\,$}</code> conforms to <span class="math">\(U\)</span> if its <a href="#existential-types">skolemization</a> conforms to <span class="math">\(U\)</span>.</li>
<li>The type <span class="math">\(T\)</span> conforms to the existential type <code>$U$ forSome {$\,Q\,$}</code> if <span class="math">\(T\)</span> conforms to one of the <a href="#existential-types">type instances</a> of <code>$U$ forSome {$\,Q\,$}</code>.</li>
<li>If <span class="math">\(T_i \equiv T&#39;_i\)</span> for <span class="math">\(i \in \{ 1 , \ldots , n\}\)</span> and <span class="math">\(U\)</span> conforms to <span class="math">\(U&#39;\)</span> then the method type <span class="math">\((p_1:T_1 , \ldots , p_n:T_n) U\)</span> conforms to <span class="math">\((p&#39;_1:T&#39;_1 , \ldots , p&#39;_n:T&#39;_n) U&#39;\)</span>.</li>
<li>The polymorphic type <span class="math">\([a_1 &gt;: L_1 &lt;: U_1 , \ldots , a_n &gt;: L_n &lt;: U_n] T\)</span> conforms to the polymorphic type <span class="math">\([a_1 &gt;: L&#39;_1 &lt;: U&#39;_1 , \ldots , a_n &gt;: L&#39;_n &lt;: U&#39;_n] T&#39;\)</span> if, assuming <span class="math">\(L&#39;_1 &lt;: a_1 &lt;: U&#39;_1 , \ldots , L&#39;_n &lt;: a_n &lt;: U&#39;_n\)</span> one has <span class="math">\(T &lt;: T&#39;\)</span> and <span class="math">\(L_i &lt;: L&#39;_i\)</span> and <span class="math">\(U&#39;_i &lt;: U_i\)</span> for <span class="math">\(i \in \{ 1 , \ldots , n \}\)</span>.</li>
<li>Type constructors <span class="math">\(T\)</span> and <span class="math">\(T&#39;\)</span> follow a similar discipline. We characterize <span class="math">\(T\)</span> and <span class="math">\(T&#39;\)</span> by their type parameter clauses <span class="math">\([a_1 , \ldots , a_n]\)</span> and <span class="math">\([a&#39;_1 , \ldots , a&#39;_n ]\)</span>, where an <span class="math">\(a_i\)</span> or <span class="math">\(a&#39;_i\)</span> may include a variance annotation, a higher-order type parameter clause, and bounds. Then, <span class="math">\(T\)</span> conforms to <span class="math">\(T&#39;\)</span> if any list <span class="math">\([t_1 , \ldots , t_n]\)</span> -- with declared variances, bounds and higher-order type parameter clauses -- of valid type arguments for <span class="math">\(T&#39;\)</span> is also a valid list of type arguments for <span class="math">\(T\)</span> and <span class="math">\(T[t_1 , \ldots , t_n] &lt;: T&#39;[t_1 , \ldots , t_n]\)</span>. Note that this entails that:
<ul>
<li>The bounds on <span class="math">\(a_i\)</span> must be weaker than the corresponding bounds declared for <span class="math">\(a&#39;_i\)</span>.</li>
<li>The variance of <span class="math">\(a_i\)</span> must match the variance of <span class="math">\(a&#39;_i\)</span>, where covariance matches covariance, contravariance matches contravariance and any variance matches invariance.</li>
<li>Recursively, these restrictions apply to the corresponding higher-order type parameter clauses of <span class="math">\(a_i\)</span> and <span class="math">\(a&#39;_i\)</span>.</li>
</ul></li>
</ul>
<p>A declaration or definition in some compound type of class type <span class="math">\(C\)</span> <em>subsumes</em> another declaration of the same name in some compound type or class type <span class="math">\(C&#39;\)</span>, if one of the following holds.</p>
<ul>
<li>A value declaration or definition that defines a name <span class="math">\(x\)</span> with type <span class="math">\(T\)</span> subsumes a value or method declaration that defines <span class="math">\(x\)</span> with type <span class="math">\(T&#39;\)</span>, provided <span class="math">\(T &lt;: T&#39;\)</span>.</li>
<li>A method declaration or definition that defines a name <span class="math">\(x\)</span> with type <span class="math">\(T\)</span> subsumes a method declaration that defines <span class="math">\(x\)</span> with type <span class="math">\(T&#39;\)</span>, provided <span class="math">\(T &lt;: T&#39;\)</span>.</li>
<li>A type alias <code>type $t$[$T_1$ , … , $T_n$] = $T$</code> subsumes a type alias <code>type $t$[$T_1$ , … , $T_n$] = $T'$</code> if <span class="math">\(T \equiv T&#39;\)</span>.</li>
<li>A type declaration <code>type $t$[$T_1$ , … , $T_n$] &gt;: $L$ &lt;: $U$</code> subsumes a type declaration <code>type $t$[$T_1$ , … , $T_n$] &gt;: $L'$ &lt;: $U'$</code> if <span class="math">\(L&#39; &lt;: L\)</span> and <span class="math">\(U &lt;: U&#39;\)</span>.</li>
<li>A type or class definition that binds a type name <span class="math">\(t\)</span> subsumes an abstract type declaration <code>type t[$T_1$ , … , $T_n$] &gt;: L &lt;: U</code> if <span class="math">\(L &lt;: t &lt;: U\)</span>.</li>
</ul>
<p>The <span class="math">\((&lt;:)\)</span> relation forms pre-order between types, i.e. it is transitive and reflexive. <em>least upper bounds</em> and <em>greatest lower bounds</em> of a set of types are understood to be relative to that order.</p>
<blockquote>
<p><strong>Note</strong>: The least upper bound or greatest lower bound of a set of types does not always exist. For instance, consider the class definitions</p>
</blockquote>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> A[+T] {}
<span class="kw">class</span> B <span class="kw">extends</span> A[B]
<span class="kw">class</span> C <span class="kw">extends</span> A[C]</code></pre>
<blockquote>
<p>Then the types <code>A[Any], A[A[Any]], A[A[A[Any]]], ...</code> form a descending sequence of upper bounds for <code>B</code> and <code>C</code>. The least upper bound would be the infinite limit of that sequence, which does not exist as a Scala type. Since cases like this are in general impossible to detect, a Scala compiler is free to reject a term which has a type specified as a least upper or greatest lower bound, and that bound would be more complex than some compiler-set limit.<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup></p>
<p>The least upper bound or greatest lower bound might also not be unique. For instance <code>A with B</code> and <code>B with A</code> are both greatest lower of <code>A</code> and <code>B</code>. If there are several least upper bounds or greatest lower bounds, the Scala compiler is free to pick any one of them.</p>
</blockquote>
<h3 id="weak-conformance"><a href="#weak-conformance"><span class="header-section-number">3.5.3</span> Weak Conformance</a></h3>
<p>In some situations Scala uses a more general conformance relation. A type <span class="math">\(S\)</span> <em>weakly conforms</em> to a type <span class="math">\(T\)</span>, written <span class="math">\(S &lt;:_w T\)</span>, if <span class="math">\(S &lt;: T\)</span> or both <span class="math">\(S\)</span> and <span class="math">\(T\)</span> are primitive number types and <span class="math">\(S\)</span> precedes <span class="math">\(T\)</span> in the following ordering.</p>
<pre><code>Byte  $&lt;:_w$ Short 
Short $&lt;:_w$ Int
Char  $&lt;:_w$ Int
Int   $&lt;:_w$ Long
Long  $&lt;:_w$ Float
Float $&lt;:_w$ Double</code></pre>
<p>A <em>weak least upper bound</em> is a least upper bound with respect to weak conformance.</p>
<h2 id="volatile-types"><a href="#volatile-types"><span class="header-section-number">3.6</span> Volatile Types</a></h2>
<p>Type volatility approximates the possibility that a type parameter or abstract type instance of a type does not have any non-null values. A value member of a volatile type cannot appear in a <a href="#paths">path</a>.</p>
<p>A type is <em>volatile</em> if it falls into one of four categories:</p>
<p>A compound type <code>$T_1$ with … with $T_n$ {$R\,$}</code> is volatile if one of the following two conditions hold.</p>
<ol>
<li>One of <span class="math">\(T_2 , \ldots , T_n\)</span> is a type parameter or abstract type, or</li>
<li><span class="math">\(T_1\)</span> is an abstract type and and either the refinement <span class="math">\(R\)</span> or a type <span class="math">\(T_j\)</span> for <span class="math">\(j &gt; 1\)</span> contributes an abstract member to the compound type, or</li>
<li>one of <span class="math">\(T_1 , \ldots , T_n\)</span> is a singleton type.</li>
</ol>
<p>Here, a type <span class="math">\(S\)</span> <em>contributes an abstract member</em> to a type <span class="math">\(T\)</span> if <span class="math">\(S\)</span> contains an abstract member that is also a member of <span class="math">\(T\)</span>. A refinement <span class="math">\(R\)</span> contributes an abstract member to a type <span class="math">\(T\)</span> if <span class="math">\(R\)</span> contains an abstract declaration which is also a member of <span class="math">\(T\)</span>.</p>
<p>A type designator is volatile if it is an alias of a volatile type, or if it designates a type parameter or abstract type that has a volatile type as its upper bound.</p>
<p>A singleton type <code>$p$.type</code> is volatile, if the underlying type of path <span class="math">\(p\)</span> is volatile.</p>
<p>An existential type <code>$T$ forSome {$\,Q\,$}</code> is volatile if <span class="math">\(T\)</span> is volatile.</p>
<h2 id="type-erasure"><a href="#type-erasure"><span class="header-section-number">3.7</span> Type Erasure</a></h2>
<p>A type is called <em>generic</em> if it contains type arguments or type variables. <em>Type erasure</em> is a mapping from (possibly generic) types to non-generic types. We write <span class="math">\(|T|\)</span> for the erasure of type <span class="math">\(T\)</span>. The erasure mapping is defined as follows.</p>
<ul>
<li>The erasure of an alias type is the erasure of its right-hand side.</li>
<li>The erasure of an abstract type is the erasure of its upper bound.</li>
<li>The erasure of the parameterized type <code>scala.Array$[T_1]$</code> is <code>scala.Array$[|T_1|]$</code>.</li>
<li>The erasure of every other parameterized type <span class="math">\(T[T_1 , \ldots , T_n]\)</span> is <span class="math">\(|T|\)</span>.</li>
<li>The erasure of a singleton type <code>$p$.type</code> is the erasure of the type of <span class="math">\(p\)</span>.</li>
<li>The erasure of a type projection <code>$T$#$x$</code> is <code>|$T$|#$x$</code>.</li>
<li>The erasure of a compound type <code>$T_1$ with $\ldots$ with $T_n$ {$R\,$}</code> is the erasure of the intersection dominator of <span class="math">\(T_1 , \ldots , T_n\)</span>.</li>
<li>The erasure of an existential type <code>$T$ forSome {$\,Q\,$}</code> is <span class="math">\(|T|\)</span>.</li>
</ul>
<p>The <em>intersection dominator</em> of a list of types <span class="math">\(T_1 , \ldots , T_n\)</span> is computed as follows. Let <span class="math">\(T_{i_1} , \ldots , T_{i_m}\)</span> be the subsequence of types <span class="math">\(T_i\)</span><br />which are not supertypes of some other type <span class="math">\(T_j\)</span>. If this subsequence contains a type designator <span class="math">\(T_c\)</span> that refers to a class which is not a trait, the intersection dominator is <span class="math">\(T_c\)</span>. Otherwise, the intersection dominator is the first element of the subsequence, <span class="math">\(T_{i_1}\)</span>.</p>
<h1 id="basic-declarations-and-definitions"><a href="#basic-declarations-and-definitions"><span class="header-section-number">4</span> Basic Declarations and Definitions</a></h1>
<pre class="grammar"><code>Dcl         ::=  ‘val’ ValDcl
              |  ‘var’ VarDcl
              |  ‘def’ FunDcl
              |  ‘type’ {nl} TypeDcl
PatVarDef   ::=  ‘val’ PatDef
              |  ‘var’ VarDef
Def         ::=  PatVarDef
              |  ‘def’ FunDef
              |  ‘type’ {nl} TypeDef
              |  TmplDef</code></pre>
<p>A <em>declaration</em> introduces names and assigns them types. It can form part of a <a href="#templates">class definition</a> or of a refinement in a <a href="#compound-types">compound type</a>.</p>
<p>A <em>definition</em> introduces names that denote terms or types. It can form part of an object or class definition or it can be local to a block. Both declarations and definitions produce <em>bindings</em> that associate type names with type definitions or bounds, and that associate term names with types.</p>
<p>The scope of a name introduced by a declaration or definition is the whole statement sequence containing the binding. However, there is a restriction on forward references in blocks: In a statement sequence <span class="math">\(s_1 \ldots s_n\)</span> making up a block, if a simple name in <span class="math">\(s_i\)</span> refers to an entity defined by <span class="math">\(s_j\)</span> where <span class="math">\(j \geq i\)</span>, then for all <span class="math">\(s_k\)</span> between and including <span class="math">\(s_i\)</span> and <span class="math">\(s_j\)</span>,</p>
<ul>
<li><span class="math">\(s_k\)</span> cannot be a variable definition.</li>
<li>If <span class="math">\(s_k\)</span> is a value definition, it must be lazy.</li>
</ul>
<h2 id="value-declarations-and-definitions"><a href="#value-declarations-and-definitions"><span class="header-section-number">4.1</span> Value Declarations and Definitions</a></h2>
<pre class="grammar"><code>Dcl          ::=  ‘val’ ValDcl
ValDcl       ::=  ids ‘:’ Type
PatVarDef    ::=  ‘val’ PatDef 
PatDef       ::=  Pattern2 {‘,’ Pattern2} [‘:’ Type] ‘=’ Expr
ids          ::=  id {‘,’ id}</code></pre>
<p>A value declaration <code>val $x$: $T$</code> introduces <span class="math">\(x\)</span> as a name of a value of type <span class="math">\(T\)</span>.</p>
<p>A value definition <code>val $x$: $T$ = $e$</code> defines <span class="math">\(x\)</span> as a name of the value that results from the evaluation of <span class="math">\(e\)</span>. If the value definition is not recursive, the type <span class="math">\(T\)</span> may be omitted, in which case the <a href="#expression-typing">packed type</a> of expression <span class="math">\(e\)</span> is assumed. If a type <span class="math">\(T\)</span> is given, then <span class="math">\(e\)</span> is expected to conform to it.</p>
<p>Evaluation of the value definition implies evaluation of its right-hand side <span class="math">\(e\)</span>, unless it has the modifier <code>lazy</code>. The effect of the value definition is to bind <span class="math">\(x\)</span> to the value of <span class="math">\(e\)</span> converted to type <span class="math">\(T\)</span>. A <code>lazy</code> value definition evaluates its right hand side <span class="math">\(e\)</span> the first time the value is accessed.</p>
<p>A <em>constant value definition</em> is of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">val</span> x = e</code></pre>
<p>where <code>e</code> is a <a href="#constant-expressions">constant expression</a>. The <code>final</code> modifier must be present and no type annotation may be given. References to the constant value <code>x</code> are themselves treated as constant expressions; in the generated code they are replaced by the definition's right-hand side <code>e</code>.</p>
<p>Value definitions can alternatively have a <a href="#patterns">pattern</a> as left-hand side. If <span class="math">\(p\)</span> is some pattern other than a simple name or a name followed by a colon and a type, then the value definition <code>val $p$ = $e$</code> is expanded as follows:</p>
<ol type="1">
<li>If the pattern <span class="math">\(p\)</span> has bound variables <span class="math">\(x_1 , \ldots , x_n\)</span>, where <span class="math">\(n &gt; 1\)</span>:</li>
</ol>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> $\$ x$ = $e$ <span class="kw">match</span> {<span class="kw">case</span> $p$ =&gt; {$x_1 , \ldots , x_n$}}
<span class="kw">val</span> $x_1$ = $\$ x$.<span class="fu">_1</span>
$\ldots$
<span class="kw">val</span> $x_n$ = $\$ x$.<span class="fu">_n</span>  .</code></pre>
<p>Here, <span class="math">\(\$ x\)</span> is a fresh name.</p>
<ol start="2" type="1">
<li>If <span class="math">\(p\)</span> has a unique bound variable <span class="math">\(x\)</span>:</li>
</ol>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> $x$ = $e$ <span class="kw">match</span> { <span class="kw">case</span> $p$ =&gt; $x$ }</code></pre>
<ol start="3" type="1">
<li>If <span class="math">\(p\)</span> has no bound variables:</li>
</ol>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$ <span class="kw">match</span> { <span class="kw">case</span> $p$ =&gt; ()}</code></pre>
<ol start="27" type="1">
<li><p>The following are examples of value definitions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> pi = <span class="fl">3.1415</span> 
<span class="kw">val</span> pi: Double = <span class="fl">3.1415</span>   <span class="co">// equivalent to first definition</span>
<span class="kw">val</span> Some(x) = <span class="fu">f</span>()         <span class="co">// a pattern definition</span>
<span class="kw">val</span> x :: xs = mylist      <span class="co">// an infix pattern definition</span></code></pre>
<p>The last two definitions have the following expansions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x = <span class="fu">f</span>() <span class="kw">match</span> { <span class="kw">case</span> Some(x) =&gt; x }

<span class="kw">val</span> x$\$$ = mylist <span class="kw">match</span> { <span class="kw">case</span> x :: xs =&gt; {x, xs} }
<span class="kw">val</span> x = x$\$$.<span class="fu">_1</span> 
<span class="kw">val</span> xs = x$\$$.<span class="fu">_2</span> </code></pre></li>
</ol>
<p>The name of any declared or defined value may not end in <code>_=</code>.</p>
<p>A value declaration <code>val $x_1 , \ldots , x_n$: $T$</code> is a shorthand for the sequence of value declarations <code>val $x_1$: $T$; ...; val $x_n$: $T$</code>. A value definition <code>val $p_1 , \ldots , p_n$ = $e$</code> is a shorthand for the sequence of value definitions <code>val $p_1$ = $e$; ...; val $p_n$ = $e$</code>. A value definition <code>val $p_1 , \ldots , p_n: T$ = $e$</code> is a shorthand for the sequence of value definitions <code>val $p_1: T$ = $e$; ...; val $p_n: T$ = $e$</code>.</p>
<h2 id="variable-declarations-and-definitions"><a href="#variable-declarations-and-definitions"><span class="header-section-number">4.2</span> Variable Declarations and Definitions</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">Dcl            ::=  ‘var’ VarDcl
PatVarDef      ::=  ‘var’ VarDef
VarDcl         ::=  ids ‘:’ Type
VarDef         ::=  PatDef
                 |  ids ‘:’ Type ‘=’ ‘_’</code></pre>
<p>A variable declaration <code>var $x$: $T$</code> is equivalent to declarations of a <em>getter function</em> <span class="math">\(x\)</span> and a <em>setter function</em> <code>$x$_=</code>, defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> $x$: $T$ 
<span class="kw">def</span> $x$_= ($y$: $T$): Unit</code></pre>
<p>An implementation of a class containing variable declarations may define these variables using variable definitions, or it may define setter and getter functions directly.</p>
<p>A variable definition <code>var $x$: $T$ = $e$</code> introduces a mutable variable with type <span class="math">\(T\)</span> and initial value as given by the expression <span class="math">\(e\)</span>. The type <span class="math">\(T\)</span> can be omitted, in which case the type of <span class="math">\(e\)</span> is assumed. If <span class="math">\(T\)</span> is given, then <span class="math">\(e\)</span> is expected to <a href="#expression-typing">conform to it</a>.</p>
<p>Variable definitions can alternatively have a <a href="#patterns">pattern</a> as left-hand side. A variable definition <code>var $p$ = $e$</code> where <span class="math">\(p\)</span> is a pattern other than a simple name or a name followed by a colon and a type is expanded in the same way as a <a href="#value-declarations-and-definitions">value definition</a> <code>val $p$ = $e$</code>, except that the free names in <span class="math">\(p\)</span> are introduced as mutable variables, not values.</p>
<p>The name of any declared or defined variable may not end in <code>_=</code>.</p>
<p>A variable definition <code>var $x$: $T$ = _</code> can appear only as a member of a template. It introduces a mutable field with type  <span class="math">\(T\)</span> and a default initial value. The default value depends on the type <span class="math">\(T\)</span> as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;">if <span class="math">\(T\)</span> is <code>Int</code> or one of its subrange types</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0L</code></td>
<td style="text-align: left;">if <span class="math">\(T\)</span> is <code>Long</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0.0f</code></td>
<td style="text-align: left;">if <span class="math">\(T\)</span> is <code>Float</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0.0d</code></td>
<td style="text-align: left;">if <span class="math">\(T\)</span> is <code>Double</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>false</code></td>
<td style="text-align: left;">if <span class="math">\(T\)</span> is <code>Boolean</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>{}</code></td>
<td style="text-align: left;">if <span class="math">\(T\)</span> is <code>Unit</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>null</code></td>
<td style="text-align: left;">for all other types <span class="math">\(T\)</span></td>
</tr>
</tbody>
</table>
<p>When they occur as members of a template, both forms of variable definition also introduce a getter function <span class="math">\(x\)</span> which returns the value currently assigned to the variable, as well as a setter function <code>$x$_=</code> which changes the value currently assigned to the variable. The functions have the same signatures as for a variable declaration. The template then has these getter and setter functions as members, whereas the original variable cannot be accessed directly as a template member.</p>
<ol start="28" type="1">
<li><p>The following example shows how <em>properties</em> can be simulated in Scala. It defines a class <code>TimeOfDayVar</code> of time values with updatable integer fields representing hours, minutes, and seconds. Its implementation contains tests that allow only legal values to be assigned to these fields. The user code, on the other hand, accesses these fields just like normal variables.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> TimeOfDayVar {
  <span class="kw">private</span> <span class="kw">var</span> h: Int = <span class="dv">0</span> 
  <span class="kw">private</span> <span class="kw">var</span> m: Int = <span class="dv">0</span> 
  <span class="kw">private</span> <span class="kw">var</span> s: Int = <span class="dv">0</span> 

  <span class="kw">def</span> hours              =  h 
  <span class="kw">def</span> hours_= (h: Int)   =  <span class="kw">if</span> (<span class="dv">0</span> &lt;= h &amp;&amp; h &lt; <span class="dv">24</span>) <span class="kw">this</span>.<span class="fu">h</span> = h 
                            <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DateError</span>() 

  <span class="kw">def</span> minutes            =  m 
  <span class="kw">def</span> minutes_= (m: Int) =  <span class="kw">if</span> (<span class="dv">0</span> &lt;= m &amp;&amp; m &lt; <span class="dv">60</span>) <span class="kw">this</span>.<span class="fu">m</span> = m
                            <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DateError</span>() 

  <span class="kw">def</span> seconds            =  s 
  <span class="kw">def</span> seconds_= (s: Int) =  <span class="kw">if</span> (<span class="dv">0</span> &lt;= s &amp;&amp; s &lt; <span class="dv">60</span>) <span class="kw">this</span>.<span class="fu">s</span> = s
                            <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DateError</span>() 
}
<span class="kw">val</span> d = <span class="kw">new</span> TimeOfDayVar 
d.<span class="fu">hours</span> = <span class="dv">8</span>; d.<span class="fu">minutes</span> = <span class="dv">30</span>; d.<span class="fu">seconds</span> = <span class="dv">0</span> 
d.<span class="fu">hours</span> = <span class="dv">25</span>                  <span class="co">// throws a DateError exception</span></code></pre></li>
</ol>
<p>A variable declaration <code>var $x_1 , \ldots , x_n$: $T$</code> is a shorthand for the sequence of variable declarations <code>var $x_1$: $T$; ...; var $x_n$: $T$</code>. A variable definition <code>var $x_1 , \ldots , x_n$ = $e$</code> is a shorthand for the sequence of variable definitions <code>var $x_1$ = $e$; ...; var $x_n$ = $e$</code>. A variable definition <code>var $x_1 , \ldots , x_n: T$ = $e$</code> is a shorthand for the sequence of variable definitions <code>var $x_1: T$ = $e$; ...; var $x_n: T$ = $e$</code>.</p>
<h2 id="type-declarations-and-type-aliases"><a href="#type-declarations-and-type-aliases"><span class="header-section-number">4.3</span> Type Declarations and Type Aliases</a></h2>
<!-- TODO: Higher-kinded tdecls should have a separate section -->

<pre class="grammar"><code>Dcl        ::=  ‘type’ {nl} TypeDcl
TypeDcl    ::=  id [TypeParamClause] [‘&gt;:’ Type] [‘&lt;:’ Type]
Def        ::=  type {nl} TypeDef
TypeDef    ::=  id [TypeParamClause] ‘=’ Type</code></pre>
<p>A <em>type declaration</em> <code>type $t$[$\mathit{tps}\,$] &gt;: $L$ &lt;: $U$</code> declares <span class="math">\(t\)</span> to be an abstract type with lower bound type <span class="math">\(L\)</span> and upper bound type <span class="math">\(U\)</span>. If the type parameter clause <code>[$\mathit{tps}\,$]</code> is omitted, <span class="math">\(t\)</span> abstracts over a first-order type, otherwise <span class="math">\(t\)</span> stands for a type constructor that accepts type arguments as described by the type parameter clause.</p>
<p>If a type declaration appears as a member declaration of a type, implementations of the type may implement <span class="math">\(t\)</span> with any type <span class="math">\(T\)</span> for which <span class="math">\(L &lt;: T &lt;: U\)</span>. It is a compile-time error if <span class="math">\(L\)</span> does not conform to <span class="math">\(U\)</span>. Either or both bounds may be omitted. If the lower bound <span class="math">\(L\)</span> is absent, the bottom type <code>scala.Nothing</code> is assumed. If the upper bound <span class="math">\(U\)</span> is absent, the top type <code>scala.Any</code> is assumed.</p>
<p>A type constructor declaration imposes additional restrictions on the concrete types for which <span class="math">\(t\)</span> may stand. Besides the bounds <span class="math">\(L\)</span> and <span class="math">\(U\)</span>, the type parameter clause may impose higher-order bounds and variances, as governed by the <a href="#conformance">conformance of type constructors</a>.</p>
<p>The scope of a type parameter extends over the bounds <code>&gt;: $L$ &lt;: $U$</code> and the type parameter clause <span class="math">\(\mathit{tps}\)</span> itself. A higher-order type parameter clause (of an abstract type constructor <span class="math">\(tc\)</span>) has the same kind of scope, restricted to the declaration of the type parameter <span class="math">\(tc\)</span>.</p>
<p>To illustrate nested scoping, these declarations are all equivalent: <code>type t[m[x] &lt;: Bound[x], Bound[x]]</code>, <code>type t[m[x] &lt;: Bound[x], Bound[y]]</code> and <code>type t[m[x] &lt;: Bound[x], Bound[_]]</code>, as the scope of, e.g., the type parameter of <span class="math">\(m\)</span> is limited to the declaration of <span class="math">\(m\)</span>. In all of them, <span class="math">\(t\)</span> is an abstract type member that abstracts over two type constructors: <span class="math">\(m\)</span> stands for a type constructor that takes one type parameter and that must be a subtype of <span class="math">\(Bound\)</span>, <span class="math">\(t\)</span>'s second type constructor parameter. <code>t[MutableList, Iterable]</code> is a valid use of <span class="math">\(t\)</span>.</p>
<p>A <em>type alias</em> <code>type $t$ = $T$</code> defines <span class="math">\(t\)</span> to be an alias name for the type <span class="math">\(T\)</span>. The left hand side of a type alias may have a type parameter clause, e.g. <code>type $t$[$\mathit{tps}\,$] = $T$</code>. The scope of a type parameter extends over the right hand side <span class="math">\(T\)</span> and the type parameter clause <span class="math">\(\mathit{tps}\)</span> itself.</p>
<p>The scope rules for <a href="#basic-declarations-and-definitions">definitions</a> and <a href="#function-declarations-and-definitions">type parameters</a> make it possible that a type name appears in its own bound or in its right-hand side. However, it is a static error if a type alias refers recursively to the defined type constructor itself.<br />That is, the type <span class="math">\(T\)</span> in a type alias <code>type $t$[$\mathit{tps}\,$] = $T$</code> may not refer directly or indirectly to the name <span class="math">\(t\)</span>. It is also an error if an abstract type is directly or indirectly its own upper or lower bound.</p>
<ol start="29" type="1">
<li><p>The following are legal type declarations and definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> IntList = List[Integer]
<span class="kw">type</span> T &lt;: Comparable[T]
<span class="kw">type</span> Two[A] = Tuple2[A, A]
<span class="kw">type</span> MyCollection[+X] &lt;: Iterable[X]</code></pre>
<p>The following are illegal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Abs = Comparable[Abs]      <span class="co">// recursive type alias</span>

<span class="kw">type</span> S &lt;: T                     <span class="co">// S, T are bounded by themselves.</span>
<span class="kw">type</span> T &lt;: S

<span class="kw">type</span> T &gt;: Comparable[T.<span class="fu">That</span>]    <span class="co">// Cannot select from T.</span>
                                <span class="co">// T is a type, not a value</span>
<span class="kw">type</span> MyCollection &lt;: Iterable   <span class="co">// Type constructor members must explicitly </span>
                                <span class="co">// state their type parameters.</span></code></pre></li>
</ol>
<p>If a type alias <code>type $t$[$\mathit{tps}\,$] = $S$</code> refers to a class type <span class="math">\(S\)</span>, the name <span class="math">\(t\)</span> can also be used as a constructor for objects of type <span class="math">\(S\)</span>.</p>
<ol start="30" type="1">
<li><p>The <code>Predef</code> object contains a definition which establishes <code>Pair</code> as an alias of the parameterized class <code>Tuple2</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Pair[+A, +B] = Tuple2[A, B] 
<span class="kw">object</span> Pair {
  <span class="kw">def</span> apply[A, B](x: A, y: B) = <span class="fu">Tuple2</span>(x, y)
  <span class="kw">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}</code></pre>
<p>As a consequence, for any two types <span class="math">\(S\)</span> and <span class="math">\(T\)</span>, the type <code>Pair[$S$, $T\,$]</code> is equivalent to the type <code>Tuple2[$S$, $T\,$]</code>. <code>Pair</code> can also be used as a constructor instead of <code>Tuple2</code>, as in:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: Pair[Int, String] = <span class="kw">new</span> Pair(<span class="dv">1</span>, <span class="st">&quot;abc&quot;</span>)</code></pre></li>
</ol>
<h2 id="type-parameters"><a href="#type-parameters"><span class="header-section-number">4.4</span> Type Parameters</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">TypeParamClause  ::= ‘[’ VariantTypeParam {‘,’ VariantTypeParam} ‘]’
VariantTypeParam ::= {Annotation} [‘+’ | ‘-’] TypeParam
TypeParam        ::= (id | ‘_’) [TypeParamClause] [‘&gt;:’ Type] [‘&lt;:’ Type] [‘:’ Type]</code></pre>
<p>Type parameters appear in type definitions, class definitions, and function definitions. In this section we consider only type parameter definitions with lower bounds <code>&gt;: $L$</code> and upper bounds <code>&lt;: $U$</code> whereas a discussion of context bounds <code>: $U$</code> and view bounds <code>&lt;% $U$</code> is deferred to <a href="#context-bounds-and-view-bounds">here</a>.</p>
<p>The most general form of a first-order type parameter is <code>$@a_1 \ldots @a_n$ $\pm$ $t$ &gt;: $L$ &lt;: $U$</code>. Here, <span class="math">\(L\)</span>, and <span class="math">\(U\)</span> are lower and upper bounds that constrain possible type arguments for the parameter. It is a compile-time error if <span class="math">\(L\)</span> does not conform to <span class="math">\(U\)</span>. <span class="math">\(\pm\)</span> is a <em>variance</em>, i.e. an optional prefix of either <code>+</code>, or <code>-</code>. One or more annotations may precede the type parameter.</p>
<!--
The upper bound $U$ in a type parameter clauses may not be a final
class. The lower bound may not denote a value type.

TODO: Why
-->

<!--
TODO: this is a pretty awkward description of scoping and distinctness of binders
-->

<p>The names of all type parameters must be pairwise different in their enclosing type parameter clause. The scope of a type parameter includes in each case the whole type parameter clause. Therefore it is possible that a type parameter appears as part of its own bounds or the bounds of other type parameters in the same clause. However, a type parameter may not be bounded directly or indirectly by itself.<br /> A type constructor parameter adds a nested type parameter clause to the type parameter. The most general form of a type constructor parameter is <code>$@a_1\ldots@a_n$ $\pm$ $t[\mathit{tps}\,]$ &gt;: $L$ &lt;: $U$</code>.</p>
<p>The above scoping restrictions are generalized to the case of nested type parameter clauses, which declare higher-order type parameters. Higher-order type parameters (the type parameters of a type parameter <span class="math">\(t\)</span>) are only visible in their immediately surrounding parameter clause (possibly including clauses at a deeper nesting level) and in the bounds of <span class="math">\(t\)</span>. Therefore, their names must only be pairwise different from the names of other visible parameters. Since the names of higher-order type parameters are thus often irrelevant, they may be denoted with a ‘_’, which is nowhere visible.</p>
<ol start="31" type="1">
<li><p>Here are some well-formed type parameter clauses:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">[S, T]
[@specialized T, U]
[Ex &lt;: Throwable]
[A &lt;: Comparable[B], B &lt;: A]
[A, B &gt;: A, C &gt;: A &lt;: B]
[M[X], N[X]]
[M[_], N[_]] <span class="co">// equivalent to previous clause</span>
[M[X &lt;: Bound[X]], Bound[_]]
[M[+X] &lt;: Iterable[X]]</code></pre>
<p>The following type parameter clauses are illegal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">[A &gt;: A]                  <span class="co">// illegal, `A&#39; has itself as bound</span>
[A &lt;: B, B &lt;: C, C &lt;: A]  <span class="co">// illegal, `A&#39; has itself as bound</span>
[A, B, C &gt;: A &lt;: B]       <span class="co">// illegal lower bound `A&#39; of `C&#39; does</span>
                          <span class="co">// not conform to upper bound `B&#39;.</span></code></pre></li>
</ol>
<h2 id="variance-annotations"><a href="#variance-annotations"><span class="header-section-number">4.5</span> Variance Annotations</a></h2>
<p>Variance annotations indicate how instances of parameterized types vary with respect to <a href="#conformance">subtyping</a>. A ‘+’ variance indicates a covariant dependency, a ‘-’ variance indicates a contravariant dependency, and a missing variance indication indicates an invariant dependency.</p>
<p>A variance annotation constrains the way the annotated type variable may appear in the type or class which binds the type parameter. In a type definition <code>type $T$[$\mathit{tps}\,$] = $S$</code>, or a type declaration <code>type $T$[$\mathit{tps}\,$] &gt;: $L$ &lt;: $U$</code> type parameters labeled ‘+’ must only appear in covariant position whereas type parameters labeled ‘-’ must only appear in contravariant position. Analogously, for a class definition <code>class $C$[$\mathit{tps}\,$]($\mathit{ps}\,$) extends $T$ { $x$: $S$ =&gt; ...}</code>, type parameters labeled ‘+’ must only appear in covariant position in the self type <span class="math">\(S\)</span> and the template <span class="math">\(T\)</span>, whereas type parameters labeled ‘-’ must only appear in contravariant position.</p>
<p>The variance position of a type parameter in a type or template is defined as follows. Let the opposite of covariance be contravariance, and the opposite of invariance be itself. The top-level of the type or template is always in covariant position. The variance position changes at the following constructs.</p>
<ul>
<li>The variance position of a method parameter is the opposite of the variance position of the enclosing parameter clause.</li>
<li>The variance position of a type parameter is the opposite of the variance position of the enclosing type parameter clause.</li>
<li>The variance position of the lower bound of a type declaration or type parameter is the opposite of the variance position of the type declaration or parameter.<br /></li>
<li>The type of a mutable variable is always in invariant position.</li>
<li>The prefix <span class="math">\(S\)</span> of a type selection <code>$S$#$T$</code> is always in invariant position.</li>
<li>For a type argument <span class="math">\(T\)</span> of a type <code>$S$[$\ldots T \ldots$ ]</code>: If the corresponding type parameter is invariant, then <span class="math">\(T\)</span> is in invariant position. If the corresponding type parameter is contravariant, the variance position of <span class="math">\(T\)</span> is the opposite of the variance position of the enclosing type <code>$S$[$\ldots T \ldots$ ]</code>.</li>
</ul>
<!-- TODO: handle type aliases --> 

<p>References to the type parameters in <a href="#modifiers">object-private values, variables, or methods</a> of the class are not checked for their variance position. In these members the type parameter may appear anywhere without restricting its legal variance annotations.</p>
<ol start="32" type="1">
<li><p>The following variance annotation is legal.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> P[+A, +B] {
  <span class="kw">def</span> fst: A; <span class="kw">def</span> snd: B
}</code></pre>
<p>With this variance annotation, type instances of <span class="math">\(P\)</span> subtype covariantly with respect to their arguments. For instance,</p>
<pre class="sourceCode scala"><code class="sourceCode scala">P[IOException, String] &lt;: P[Throwable, AnyRef]</code></pre>
<p>If the members of <span class="math">\(P\)</span> are mutable variables, the same variance annotation becomes illegal.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Q[+A, +B](x: A, y: B) { 
  <span class="kw">var</span> fst: A = x           <span class="co">// **** error: illegal variance:</span>
  <span class="kw">var</span> snd: B = y           <span class="co">// `A&#39;, `B&#39; occur in invariant position.</span>
}</code></pre>
<p>If the mutable variables are object-private, the class definition becomes legal again:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> R[+A, +B](x: A, y: B) { 
  <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> fst: A = x        <span class="co">// OK</span>
  <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> snd: B = y        <span class="co">// OK</span>
}</code></pre></li>
<li><p>The following variance annotation is illegal, since <span class="math">\(a\)</span> appears in contravariant position in the parameter of <code>append</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Sequence[+A] {
  <span class="kw">def</span> <span class="fu">append</span>(x: Sequence[A]): Sequence[A]  
                  <span class="co">// **** error: illegal variance: </span>
                  <span class="co">// `A&#39; occurs in contravariant position.</span>
}</code></pre>
<p>The problem can be avoided by generalizing the type of <code>append</code> by means of a lower bound:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Sequence[+A] {
  <span class="kw">def</span> append[B &gt;: A](x: Sequence[B]): Sequence[B] 
}</code></pre></li>
<li><p>Here is a case where a contravariant type parameter is useful.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> OutputChannel[-A] {
  <span class="kw">def</span> <span class="fu">write</span>(x: A): Unit
}</code></pre>
<p>With that annotation, we have that <code>OutputChannel[AnyRef]</code> conforms to <code>OutputChannel[String]</code>.<br />That is, a channel on which one can write any object can substitute for a channel on which one can write only strings.</p></li>
</ol>
<h2 id="function-declarations-and-definitions"><a href="#function-declarations-and-definitions"><span class="header-section-number">4.6</span> Function Declarations and Definitions</a></h2>
<pre class="grammar"><code>Dcl                ::=  ‘def’ FunDcl
FunDcl             ::=  FunSig ‘:’ Type
Def                ::=  ‘def’ FunDef
FunDef             ::=  FunSig [‘:’ Type] ‘=’ Expr 
FunSig             ::=  id [FunTypeParamClause] ParamClauses
FunTypeParamClause ::=  ‘[’ TypeParam {‘,’ TypeParam} ‘]’ 
ParamClauses       ::=  {ParamClause} [[nl] ‘(’ ‘implicit’ Params ‘)’]
ParamClause        ::=  [nl] ‘(’ [Params] ‘)’} 
Params             ::=  Param {‘,’ Param}
Param              ::=  {Annotation} id [‘:’ ParamType] [‘=’ Expr]
ParamType          ::=  Type 
                     |  ‘=&gt;’ Type 
                     |  Type ‘*’</code></pre>
<p>A function declaration has the form <code>def $f\,\mathit{psig}$: $T$</code>, where <span class="math">\(f\)</span> is the function's name, <span class="math">\(\mathit{psig}\)</span> is its parameter signature and <span class="math">\(T\)</span> is its result type. A function definition <code>def $f\,\mathit{psig}$: $T$ = $e$</code> also includes a <em>function body</em> <span class="math">\(e\)</span>, i.e. an expression which defines the function's result. A parameter signature consists of an optional type parameter clause <code>[$\mathit{tps}\,$]</code>, followed by zero or more value parameter clauses <code>($\mathit{ps}_1$)$\ldots$($\mathit{ps}_n$)</code>. Such a declaration or definition introduces a value with a (possibly polymorphic) method type whose parameter types and result type are as given.</p>
<p>The type of the function body is expected to <a href="#expr-typing">conform</a> to the function's declared result type, if one is given. If the function definition is not recursive, the result type may be omitted, in which case it is determined from the packed type of the function body.</p>
<p>A type parameter clause <span class="math">\(\mathit{tps}\)</span> consists of one or more <a href="#type-declarations-and-type-aliases">type declarations</a>, which introduce type parameters, possibly with bounds. The scope of a type parameter includes the whole signature, including any of the type parameter bounds as well as the function body, if it is present.</p>
<p>A value parameter clause <span class="math">\(\mathit{ps}\)</span> consists of zero or more formal parameter bindings such as <code>$x$: $T$</code> or <code>$x: T = e$</code>, which bind value parameters and associate them with their types. Each value parameter declaration may optionally define a default argument. The default argument expression <span class="math">\(e\)</span> is type-checked with an expected type <span class="math">\(T&#39;\)</span> obtained by replacing all occurences of the function's type parameters in <span class="math">\(T\)</span> by the undefined type.</p>
<p>For every parameter <span class="math">\(p_{i,j}\)</span> with a default argument a method named <code>$f\$$default$\$$n</code> is generated which computes the default argument expression. Here, <span class="math">\(n\)</span> denotes the parameter's position in the method declaration. These methods are parametrized by the type parameter clause <code>[$\mathit{tps}\,$]</code> and all value parameter clauses <code>($\mathit{ps}_1$)$\ldots$($\mathit{ps}_{i-1}$)</code> preceeding <span class="math">\(p_{i,j}\)</span>. The <code>$f\$$default$\$$n</code> methods are inaccessible for user programs.</p>
<p>The scope of a formal value parameter name <span class="math">\(x\)</span> comprises all subsequent parameter clauses, as well as the method return type and the function body, if they are given.<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup> Both type parameter names and value parameter names must be pairwise distinct.</p>
<ol start="35" type="1">
<li><p>In the method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> compare[T](a: T = <span class="dv">0</span>)(b: T = a) = (a == b)</code></pre>
<p>the default expression <code>0</code> is type-checked with an undefined expected type. When applying <code>compare()</code>, the default value <code>0</code> is inserted and <code>T</code> is instantiated to <code>Int</code>. The methods computing the default arguments have the form:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> compare$\$$default$\$$<span class="dv">1</span>[T]: Int = <span class="dv">0</span>
<span class="kw">def</span> compare$\$$default$\$$<span class="dv">2</span>[T](a: T): T = a</code></pre></li>
</ol>
<h3 id="by-name-parameters"><a href="#by-name-parameters"><span class="header-section-number">4.6.1</span> By-Name Parameters</a></h3>
<pre class="grammar"><code>ParamType          ::=  ‘=&gt;’ Type</code></pre>
<p>The type of a value parameter may be prefixed by <code>=&gt;</code>, e.g.<br /><code>$x$: =&gt; $T$</code>. The type of such a parameter is then the parameterless method type <code>=&gt; $T$</code>. This indicates that the corresponding argument is not evaluated at the point of function application, but instead is evaluated at each use within the function. That is, the argument is evaluated using <em>call-by-name</em>.</p>
<p>The by-name modifier is disallowed for parameters of classes that carry a <code>val</code> or <code>var</code> prefix, including parameters of case classes for which a <code>val</code> prefix is implicitly generated. The by-name modifier is also disallowed for <a href="#implicit-parameters">implicit parameters</a>.</p>
<ol start="36" type="1">
<li><p>The declaration</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">whileLoop</span> (cond: =&gt; Boolean) (stat: =&gt; Unit): Unit</code></pre>
<p>indicates that both parameters of <code>whileLoop</code> are evaluated using call-by-name.</p></li>
</ol>
<h3 id="repeated-parameters"><a href="#repeated-parameters"><span class="header-section-number">4.6.2</span> Repeated Parameters</a></h3>
<pre class="grammar"><code>ParamType          ::=  Type ‘*’</code></pre>
<p>The last value parameter of a parameter section may be suffixed by “*”, e.g. <code>(..., $x$:$T$*)</code>. The type of such a <em>repeated</em> parameter inside the method is then the sequence type <code>scala.Seq[$T$]</code>. Methods with repeated parameters <code>$T$*</code> take a variable number of arguments of type <span class="math">\(T\)</span>. That is, if a method <span class="math">\(m\)</span> with type <code>($p_1:T_1 , \ldots , p_n:T_n, p_s:S$*)$U$</code> is applied to arguments <span class="math">\((e_1 , \ldots , e_k)\)</span> where <span class="math">\(k \geq n\)</span>, then <span class="math">\(m\)</span> is taken in that application to have type <span class="math">\((p_1:T_1 , \ldots , p_n:T_n, p_s:S , \ldots , p_{s&#39;}S)U\)</span>, with <span class="math">\(k - n\)</span> occurrences of type <span class="math">\(S\)</span> where any parameter names beyond <span class="math">\(p_s\)</span> are fresh. The only exception to this rule is if the last argument is marked to be a <em>sequence argument</em> via a <code>_*</code> type annotation. If <span class="math">\(m\)</span> above is applied to arguments <code>($e_1 , \ldots , e_n, e'$: _*)</code>, then the type of <span class="math">\(m\)</span> in that application is taken to be <code>($p_1:T_1, \ldots , p_n:T_n,p_{s}:$scala.Seq[$S$])</code>.</p>
<p>It is not allowed to define any default arguments in a parameter section with a repeated parameter.</p>
<ol start="37" type="1">
<li><p>The following method definition computes the sum of the squares of a variable number of integer arguments.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sum</span>(args: Int*) = {
  <span class="kw">var</span> result = <span class="dv">0</span>
  <span class="kw">for</span> (arg &lt;- args) result += arg * arg
  result
}</code></pre>
<p>The following applications of this method yield <code>0</code>, <code>1</code>, <code>6</code>, in that order.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>()
<span class="fu">sum</span>(<span class="dv">1</span>)
<span class="fu">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p>Furthermore, assume the definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p>The following application of method <code>sum</code> is ill-formed:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(xs)       <span class="co">// ***** error: expected: Int, found: List[Int]</span></code></pre>
<p>By contrast, the following application is well formed and yields again the result <code>6</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(xs: _*) </code></pre></li>
</ol>
<h3 id="procedures"><a href="#procedures"><span class="header-section-number">4.6.3</span> Procedures</a></h3>
<pre class="grammar"><code>FunDcl   ::=  FunSig
FunDef   ::=  FunSig [nl] ‘{’ Block ‘}’</code></pre>
<p>Special syntax exists for procedures, i.e. functions that return the  value . A procedure declaration is a function declaration where the result type is omitted. The result type is then implicitly completed to the  type. E.g., <code>def $f$($\mathit{ps}$)</code> is equivalent to <code>def $f$($\mathit{ps}$): Unit</code>.</p>
<p>A procedure definition is a function definition where the result type and the equals sign are omitted; its defining expression must be a block. E.g., <code>def $f$($\mathit{ps}$) {$\mathit{stats}$}</code> is equivalent to <code>def $f$($\mathit{ps}$): Unit = {$\mathit{stats}$}</code>.</p>
<ol start="38" type="1">
<li><p>Here is a declaration and a definition of a procedure named <code>write</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Writer { 
  <span class="kw">def</span> <span class="fu">write</span>(str: String)
}
<span class="kw">object</span> Terminal <span class="kw">extends</span> Writer {
  <span class="kw">def</span> <span class="fu">write</span>(str: String) { System.<span class="fu">out</span>.<span class="fu">println</span>(str) }
}</code></pre>
<p>The code above is implicitly completed to the following code:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Writer { 
  <span class="kw">def</span> <span class="fu">write</span>(str: String): Unit
}
<span class="kw">object</span> Terminal <span class="kw">extends</span> Writer {
  <span class="kw">def</span> <span class="fu">write</span>(str: String): Unit = { System.<span class="fu">out</span>.<span class="fu">println</span>(str) }
}</code></pre></li>
</ol>
<h3 id="method-return-type-inference"><a href="#method-return-type-inference"><span class="header-section-number">4.6.4</span> Method Return Type Inference</a></h3>
<p>A class member definition <span class="math">\(m\)</span> that overrides some other function <span class="math">\(m&#39;\)</span> in a base class of <span class="math">\(C\)</span> may leave out the return type, even if it is recursive. In this case, the return type <span class="math">\(R&#39;\)</span> of the overridden function <span class="math">\(m&#39;\)</span>, seen as a member of <span class="math">\(C\)</span>, is taken as the return type of <span class="math">\(m\)</span> for each recursive invocation of <span class="math">\(m\)</span>. That way, a type <span class="math">\(R\)</span> for the right-hand side of <span class="math">\(m\)</span> can be determined, which is then taken as the return type of <span class="math">\(m\)</span>. Note that <span class="math">\(R\)</span> may be different from <span class="math">\(R&#39;\)</span>, as long as <span class="math">\(R\)</span> conforms to <span class="math">\(R&#39;\)</span>.</p>
<ol start="39" type="1">
<li><p>Assume the following definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> I {
  <span class="kw">def</span> <span class="fu">factorial</span>(x: Int): Int
}
<span class="kw">class</span> C <span class="kw">extends</span> I {
  <span class="kw">def</span> <span class="fu">factorial</span>(x: Int) = <span class="kw">if</span> (x == <span class="dv">0</span>) <span class="dv">1</span> <span class="kw">else</span> x * <span class="fu">factorial</span>(x - <span class="dv">1</span>)
}</code></pre>
<p>Here, it is OK to leave out the result type of <code>factorial</code> in <code>C</code>, even though the method is recursive.</p></li>
</ol>
<h2 id="import-clauses"><a href="#import-clauses"><span class="header-section-number">4.7</span> Import Clauses</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">Import          ::= ‘import’ ImportExpr {‘,’ ImportExpr}
ImportExpr      ::= StableId ‘.’ (id | ‘_’ | ImportSelectors)
ImportSelectors ::= ‘{’ {ImportSelector ‘,’} 
                    (ImportSelector | ‘_’) ‘}’
ImportSelector  ::= id [‘=&gt;’ id | ‘=&gt;’ ‘_’]</code></pre>
<p>An import clause has the form <code>import $p$.$I$</code> where <span class="math">\(p\)</span> is a <a href="#paths">stable identifier</a> and <span class="math">\(I\)</span> is an import expression. The import expression determines a set of names of importable members of <span class="math">\(p\)</span> which are made available without qualification. A member <span class="math">\(m\)</span> of <span class="math">\(p\)</span> is <em>importable</em> if it is not <a href="#modifiers">object-private</a>. The most general form of an import expression is a list of {}</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ $x_1$ =&gt; $y_1 , \ldots , x_n$ =&gt; $y_n$, _ } </code></pre>
<p>for <span class="math">\(n \geq 0\)</span>, where the final wildcard ‘_’ may be absent. It makes available each importable member <code>$p$.$x_i$</code> under the unqualified name <span class="math">\(y_i\)</span>. I.e. every import selector <code>$x_i$ =&gt; $y_i$</code> renames <code>$p$.$x_i$</code> to <span class="math">\(y_i\)</span>. If a final wildcard is present, all importable members <span class="math">\(z\)</span> of <span class="math">\(p\)</span> other than <code>$x_1 , \ldots , x_n,y_1 , \ldots , y_n$</code> are also made available under their own unqualified names.</p>
<p>Import selectors work in the same way for type and term members. For instance, an import clause <code>import $p$.{$x$ =&gt; $y\,$}</code> renames the term name <code>$p$.$x$</code> to the term name <span class="math">\(y\)</span> and the type name <code>$p$.$x$</code> to the type name <span class="math">\(y\)</span>. At least one of these two names must reference an importable member of <span class="math">\(p\)</span>.</p>
<p>If the target in an import selector is a wildcard, the import selector hides access to the source member. For instance, the import selector <code>$x$ =&gt; _</code> “renames” <span class="math">\(x\)</span> to the wildcard symbol (which is unaccessible as a name in user programs), and thereby effectively prevents unqualified access to <span class="math">\(x\)</span>. This is useful if there is a final wildcard in the same import selector list, which imports all members not mentioned in previous import selectors.</p>
<p>The scope of a binding introduced by an import-clause starts immediately after the import clause and extends to the end of the enclosing block, template, package clause, or compilation unit, whichever comes first.</p>
<p>Several shorthands exist. An import selector may be just a simple name <span class="math">\(x\)</span>. In this case, <span class="math">\(x\)</span> is imported without renaming, so the import selector is equivalent to <code>$x$ =&gt; $x$</code>. Furthermore, it is possible to replace the whole import selector list by a single identifier or wildcard. The import clause <code>import $p$.$x$</code> is equivalent to <code>import $p$.{$x\,$}</code>, i.e. it makes available without qualification the member <span class="math">\(x\)</span> of <span class="math">\(p\)</span>. The import clause <code>import $p$._</code> is equivalent to <code>import $p$.{_}</code>, i.e. it makes available without qualification all members of <span class="math">\(p\)</span> (this is analogous to <code>import $p$.*</code> in Java).</p>
<p>An import clause with multiple import expressions <code>import $p_1$.$I_1 , \ldots , p_n$.$I_n$</code> is interpreted as a sequence of import clauses <code>import $p_1$.$I_1$; $\ldots$; import $p_n$.$I_n$</code>.</p>
<ol start="40" type="1">
<li><p>Consider the object definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> M { 
  <span class="kw">def</span> z = <span class="dv">0</span>, one = <span class="dv">1</span>  
  <span class="kw">def</span> <span class="fu">add</span>(x: Int, y: Int): Int = x + y 
}</code></pre>
<p>Then the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">import</span> M.{one, z =&gt; zero, _}; <span class="fu">add</span>(zero, one) }</code></pre>
<p>is equivalent to the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ M.<span class="fu">add</span>(M.<span class="fu">z</span>, M.<span class="fu">one</span>) } </code></pre></li>
</ol>
<h1 id="classes-and-objects"><a href="#classes-and-objects"><span class="header-section-number">5</span> Classes and Objects</a></h1>
<pre class="grammar"><code>TmplDef          ::= [`case&#39;] `class&#39; ClassDef
                  |  [`case&#39;] `object&#39; ObjectDef
                  |  `trait&#39; TraitDef</code></pre>
<p><a href="#class-definitions">Classes</a> and <a href="#object-definitions">objects</a> are both defined in terms of <em>templates</em>.</p>
<h2 id="templates"><a href="#templates"><span class="header-section-number">5.1</span> Templates</a></h2>
<pre class="grammar"><code>ClassTemplate   ::=  [EarlyDefs] ClassParents [TemplateBody]
TraitTemplate   ::=  [EarlyDefs] TraitParents [TemplateBody]
ClassParents    ::=  Constr {`with&#39; AnnotType}
TraitParents    ::=  AnnotType {`with&#39; AnnotType}
TemplateBody    ::=  [nl] `{&#39; [SelfType] TemplateStat {semi TemplateStat} `}&#39;
SelfType        ::=  id [`:&#39; Type] `=&gt;&#39;
                 |   this `:&#39; Type `=&gt;&#39;</code></pre>
<p>A template defines the type signature, behavior and initial state of a trait or class of objects or of a single object. Templates form part of instance creation expressions, class definitions, and object definitions. A template <code>$sc$ with $mt_1$ with $\ldots$ with $mt_n$ { $\mathit{stats}$ }</code> consists of a constructor invocation <span class="math">\(sc\)</span> which defines the template's <em>superclass</em>, trait references <code>$mt_1 , \ldots , mt_n$</code> <span class="math">\((n \geq 0)\)</span>, which define the template's <em>traits</em>, and a statement sequence <span class="math">\(\mathit{stats}\)</span> which contains initialization code and additional member definitions for the template.</p>
<p>Each trait reference <span class="math">\(mt_i\)</span> must denote a <a href="#traits">trait</a>. By contrast, the superclass constructor <span class="math">\(sc\)</span> normally refers to a class which is not a trait. It is possible to write a list of parents that starts with a trait reference, e.g. <code>$mt_1$ with $\ldots$ with $mt_n$</code>. In that case the list of parents is implicitly extended to include the supertype of <span class="math">\(mt_1\)</span> as first parent type. The new supertype must have at least one constructor that does not take parameters. In the following, we will always assume that this implicit extension has been performed, so that the first parent class of a template is a regular superclass constructor, not a trait reference.</p>
<p>The list of parents of every class is also always implicitly extended by a reference to the <code>scala.ScalaObject</code> trait as last mixin. E.g.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ { $\mathit{stats}$ }</code></pre>
<p>becomes</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ <span class="kw">with</span> ScalaObject { $\mathit{stats}$ }.</code></pre>
<p>The list of parents of a template must be well-formed. This means that the class denoted by the superclass constructor <span class="math">\(sc\)</span> must be a subclass of the superclasses of all the traits <span class="math">\(mt_1 , \ldots , mt_n\)</span>. In other words, the non-trait classes inherited by a template form a chain in the inheritance hierarchy which starts with the template's superclass.</p>
<p>The <em>least proper supertype</em> of a template is the class type or <a href="#compound-types">compound type</a> consisting of all its parent class types.</p>
<p>The statement sequence <span class="math">\(\mathit{stats}\)</span> contains member definitions that define new members or overwrite members in the parent classes. If the template forms part of an abstract class or trait definition, the statement part <span class="math">\(\mathit{stats}\)</span> may also contain declarations of abstract members. If the template forms part of a concrete class definition, <span class="math">\(\mathit{stats}\)</span> may still contain declarations of abstract type members, but not of abstract term members. Furthermore, <span class="math">\(\mathit{stats}\)</span> may in any case also contain expressions; these are executed in the order they are given as part of the initialization of a template.</p>
<p>The sequence of template statements may be prefixed with a formal parameter definition and an arrow, e.g. <code>$x$ =&gt;</code>, or <code>$x$:$T$ =&gt;</code>. If a formal parameter is given, it can be used as an alias for the reference <code>this</code> throughout the body of the template.<br />If the formal parameter comes with a type <span class="math">\(T\)</span>, this definition affects the <em>self type</em> <span class="math">\(S\)</span> of the underlying class or object as follows: Let <span class="math">\(C\)</span> be the type of the class or trait or object defining the template. If a type <span class="math">\(T\)</span> is given for the formal self parameter, <span class="math">\(S\)</span> is the greatest lower bound of <span class="math">\(T\)</span> and <span class="math">\(C\)</span>. If no type <span class="math">\(T\)</span> is given, <span class="math">\(S\)</span> is just <span class="math">\(C\)</span>. Inside the template, the type of <code>this</code> is assumed to be <span class="math">\(S\)</span>.</p>
<p>The self type of a class or object must conform to the self types of all classes which are inherited by the template <span class="math">\(t\)</span>.</p>
<p>A second form of self type annotation reads just <code>this: $S$ =&gt;</code>. It prescribes the type <span class="math">\(S\)</span> for <code>this</code> without introducing an alias name for it.</p>
<ol start="41" type="1">
<li><p>Consider the following class definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Base <span class="kw">extends</span> Object {}
<span class="kw">trait</span> Mixin <span class="kw">extends</span> Base {}
<span class="kw">object</span> O <span class="kw">extends</span> Mixin {}</code></pre>
<p>In this case, the definition of <code>O</code> is expanded to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> O <span class="kw">extends</span> Base <span class="kw">with</span> Mixin {}</code></pre></li>
</ol>
<!-- TODO: Make all references to Java generic -->

<p><strong>Inheriting from Java Types</strong><br />A template may have a Java class as its superclass and Java interfaces as its mixins.</p>
<p><strong>Template Evaluation</strong><br />Consider a template <code>$sc$ with $mt_1$ with $mt_n$ { $\mathit{stats}$ }</code>.</p>
<p>If this is the template of a <a href="#traits">trait</a> then its <em>mixin-evaluation</em> consists of an evaluation of the statement sequence <span class="math">\(\mathit{stats}\)</span>.</p>
<p>If this is not a template of a trait, then its <em>evaluation</em> consists of the following steps.</p>
<ul>
<li>First, the superclass constructor <span class="math">\(sc\)</span> is <a href="#constructor-invocations">evaluated</a>.</li>
<li>Then, all base classes in the template's <a href="#class-linearization">linearization</a> up to the template's superclass denoted by <span class="math">\(sc\)</span> are mixin-evaluated. Mixin-evaluation happens in reverse order of occurrence in the linearization.</li>
<li>Finally the statement sequence <span class="math">\(\mathit{stats}\,\)</span> is evaluated.</li>
</ul>
<p><em>Delayed Initializaton</em><br />The initialization code of an object or class (but not a trait) that follows the superclass constructor invocation and the mixin-evaluation of the template's base classes is passed to a special hook, which is inaccessible from user code. Normally, that hook simply executes the code that is passed to it. But templates inheriting the <code>scala.DelayedInit</code> trait can override the hook by re-implementing the <code>delayedInit</code> method, which is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">delayedInit</span>(body: =&gt; Unit)</code></pre>
<h3 id="constructor-invocations"><a href="#constructor-invocations"><span class="header-section-number">5.1.1</span> Constructor Invocations</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">Constr  ::=  AnnotType {`(&#39; [Exprs] `)&#39;}</code></pre>
<p>Constructor invocations define the type, members, and initial state of objects created by an instance creation expression, or of parts of an object's definition which are inherited by a class or object definition. A constructor invocation is a function application <code>$x$.$c$[$\mathit{targs}$]($\mathit{args}_1$)$\ldots$($\mathit{args}_n$)</code>, where <span class="math">\(x\)</span> is a <a href="#paths">stable identifier</a>, <span class="math">\(c\)</span> is a type name which either designates a class or defines an alias type for one, <span class="math">\(\mathit{targs}\)</span> is a type argument list, <span class="math">\(\mathit{args}_1 , \ldots , \mathit{args}_n\)</span> are argument lists, and there is a constructor of that class which is <a href="#function-applications">applicable</a> to the given arguments. If the constructor invocation uses named or default arguments, it is transformed into a block expression using the same transformation as described <a href="sec:named-default">here</a>.</p>
<p>The prefix `<code>$x$.</code>' can be omitted. A type argument list can be given only if the class <span class="math">\(c\)</span> takes type parameters. Even then it can be omitted, in which case a type argument list is synthesized using <a href="#local-type-inference">local type inference</a>. If no explicit arguments are given, an empty list <code>()</code> is implicitly supplied.</p>
<p>An evaluation of a constructor invocation <code>$x$.$c$[$\mathit{targs}$]($\mathit{args}_1$)$\ldots$($\mathit{args}_n$)</code> consists of the following steps:</p>
<ul>
<li>First, the prefix <span class="math">\(x\)</span> is evaluated.</li>
<li>Then, the arguments <span class="math">\(\mathit{args}_1 , \ldots , \mathit{args}_n\)</span> are evaluated from left to right.</li>
<li>Finally, the class being constructed is initialized by evaluating the template of the class referred to by <span class="math">\(c\)</span>.</li>
</ul>
<h3 id="class-linearization"><a href="#class-linearization"><span class="header-section-number">5.1.2</span> Class Linearization</a></h3>
<p>The classes reachable through transitive closure of the direct inheritance relation from a class <span class="math">\(C\)</span> are called the <em>base classes</em> of <span class="math">\(C\)</span>. Because of mixins, the inheritance relationship on base classes forms in general a directed acyclic graph. A linearization of this graph is defined as follows.</p>
<blockquote>
<p>Let <span class="math">\(C\)</span> be a class with template <code>$C_1$ with ... with $C_n$ { $\mathit{stats}$ }</code>. The <em>linearization</em> of <span class="math">\(C\)</span>, <span class="math">\(\mathcal{L}(C)\)</span> is defined as follows:</p>
<p><span class="math">\(\mathcal{L}(C) = C, \mathcal{L}(C_n) \; \vec{+} \; \ldots \; \vec{+} \; \mathcal{L}(C_1)\)</span></p>
<p>Here <span class="math">\(\vec{+}\)</span> denotes concatenation where elements of the right operand replace identical elements of the left operand:</p>
<pre class="math"><code>\[
\begin{array}{lcll}
\{a, A\} \;\vec{+}\; B &amp;=&amp; a, (A \;\vec{+}\; B)  &amp;{\bf if} \; a \not\in B \\
                       &amp;=&amp; A \;\vec{+}\; B       &amp;{\bf if} \; a \in B
\end{array}
\]</code></pre>
</blockquote>
<ol start="42" type="1">
<li><p>Consider the following class definitions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> AbsIterator <span class="kw">extends</span> AnyRef { ... }
<span class="kw">trait</span> RichIterator <span class="kw">extends</span> AbsIterator { ... }
<span class="kw">class</span> StringIterator <span class="kw">extends</span> AbsIterator { ... }
<span class="kw">class</span> Iter <span class="kw">extends</span> StringIterator <span class="kw">with</span> RichIterator { ... }</code></pre>
<p>Then the linearization of class <code>Iter</code> is</p>
<pre><code>{ Iter, RichIterator, StringIterator, AbsIterator, ScalaObject, AnyRef, Any }</code></pre>
<p>Trait <code>ScalaObject</code> appears in this list because it is added as last mixin to every Scala class ( <a href="#templates">see here</a> ).</p>
<p>Note that the linearization of a class refines the inheritance relation: if <span class="math">\(C\)</span> is a subclass of <span class="math">\(D\)</span>, then <span class="math">\(C\)</span> precedes <span class="math">\(D\)</span> in any linearization where both <span class="math">\(C\)</span> and <span class="math">\(D\)</span> occur.  also satisfies the property that a linearization of a class always contains the linearization of its direct superclass as a suffix. For instance, the linearization of <code>StringIterator</code> is</p>
<pre><code>{ StringIterator, AbsIterator, ScalaObject, AnyRef, Any }</code></pre>
<p>which is a suffix of the linearization of its subclass <code>Iter</code>. The same is not true for the linearization of mixins. For instance, the linearization of <code>RichIterator</code> is</p>
<pre><code>{ RichIterator, AbsIterator, ScalaObject, AnyRef, Any }</code></pre>
<p>which is not a suffix of the linearization of <code>Iter</code>.</p></li>
</ol>
<h3 id="class-members"><a href="#class-members"><span class="header-section-number">5.1.3</span> Class Members</a></h3>
<p>A class <span class="math">\(C\)</span> defined by a template <code>$C_1$ with $\ldots$ with $C_n$ { $\mathit{stats}$ }</code> can define members in its statement sequence <span class="math">\(\mathit{stats}\)</span> and can inherit members from all parent classes. Scala adopts Java and C#'s conventions for static overloading of methods. It is thus possible that a class defines and/or inherits several methods with the same name. To decide whether a defined member of a class <span class="math">\(C\)</span> overrides a member of a parent class, or whether the two co-exist as overloaded variants in <span class="math">\(C\)</span>, Scala uses the following definition of <em>matching</em> on members:</p>
<blockquote>
<p><strong>Definition</strong><br />A member definition <span class="math">\(M\)</span> <em>matches</em> a member definition <span class="math">\(M&#39;\)</span>, if <span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span> bind the same name, and one of following holds.</p>
<ol>
<li>Neither <span class="math">\(M\)</span> nor <span class="math">\(M&#39;\)</span> is a method definition.</li>
<li><span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span> define both monomorphic methods with equivalent argument types.</li>
<li><span class="math">\(M\)</span> defines a parameterless method and <span class="math">\(M&#39;\)</span> defines a method with an empty parameter list <code>()</code> or <em>vice versa</em>.</li>
<li><span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span> define both polymorphic methods with equal number of argument types <span class="math">\(\overline T\)</span>, <span class="math">\(\overline T&#39;\)</span> and equal numbers of type parameters <span class="math">\(\overline t\)</span>, <span class="math">\(\overline t&#39;\)</span>, say, and <span class="math">\(\overline T&#39; = [\overline t&#39;/\overline t]\overline T\)</span>. by the corresponding type parameter <span class="math">\(t\)</span> of <span class="math">\(M\)</span>.</li>
</ol>
</blockquote>
<p>Member definitions fall into two categories: concrete and abstract. Members of class <span class="math">\(C\)</span> are either <em>directly defined</em> (i.e. they appear in <span class="math">\(C\)</span>'s statement sequence <span class="math">\(\mathit{stats}\)</span>) or they are <em>inherited</em>. There are two rules that determine the set of members of a class, one for each category:</p>
<blockquote>
<p>A <em>concrete member</em> of a class <span class="math">\(C\)</span> is any concrete definition <span class="math">\(M\)</span> in some class <span class="math">\(C_i \in \mathcal{L}(C)\)</span>, except if there is a preceding class <span class="math">\(C_j \in \mathcal{L}(C)\)</span> where <span class="math">\(j &lt; i\)</span> which directly defines a concrete member <span class="math">\(M&#39;\)</span> matching <span class="math">\(M\)</span>.</p>
<p>An <em>abstract member</em> of a class <span class="math">\(C\)</span> is any abstract definition <span class="math">\(M\)</span> in some class <span class="math">\(C_i \in \mathcal{L}(C)\)</span>, except if <span class="math">\(C\)</span> contains already a concrete member <span class="math">\(M&#39;\)</span> matching <span class="math">\(M\)</span>, or if there is a preceding class <span class="math">\(C_j \in \mathcal{L}(C)\)</span> where <span class="math">\(j &lt; i\)</span> which directly defines an abstract member <span class="math">\(M&#39;\)</span> matching <span class="math">\(M\)</span>.</p>
</blockquote>
<p>This definition also determines the <a href="#overriding">overriding</a> relationships between matching members of a class <span class="math">\(C\)</span> and its parents.<br />First, a concrete definition always overrides an abstract definition. Second, for definitions <span class="math">\(M\)</span> and <span class="math">\(M\)</span>' which are both concrete or both abstract, <span class="math">\(M\)</span> overrides <span class="math">\(M&#39;\)</span> if <span class="math">\(M\)</span> appears in a class that precedes (in the linearization of <span class="math">\(C\)</span>) the class in which <span class="math">\(M&#39;\)</span> is defined.</p>
<p>It is an error if a template directly defines two matching members. It is also an error if a template contains two members (directly defined or inherited) with the same name and the same <a href="#type-erasure">erased type</a>. Finally, a template is not allowed to contain two methods (directly defined or inherited) with the same name which both define default arguments.</p>
<ol start="43" type="1">
<li><p>Consider the trait definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> A { <span class="kw">def</span> f: Int }
<span class="kw">trait</span> B <span class="kw">extends</span> A { <span class="kw">def</span> f: Int = <span class="dv">1</span> ; <span class="kw">def</span> g: Int = <span class="dv">2</span> ; <span class="kw">def</span> h: Int = <span class="dv">3</span> }
<span class="kw">trait</span> C <span class="kw">extends</span> A { <span class="kw">override</span> <span class="kw">def</span> f: Int = <span class="dv">4</span> ; <span class="kw">def</span> g: Int }
<span class="kw">trait</span> D <span class="kw">extends</span> B <span class="kw">with</span> C { <span class="kw">def</span> h: Int }</code></pre>
<p>Then trait <code>D</code> has a directly defined abstract member <code>h</code>. It inherits member <code>f</code> from trait <code>C</code> and member <code>g</code> from trait <code>B</code>.</p></li>
</ol>
<h3 id="overriding"><a href="#overriding"><span class="header-section-number">5.1.4</span> Overriding</a></h3>
<!-- TODO: Explain that classes cannot override each other -->

<p>A member <span class="math">\(M\)</span> of class <span class="math">\(C\)</span> that <a href="#class-members">matches</a> a non-private member <span class="math">\(M&#39;\)</span> of a base class of <span class="math">\(C\)</span> is said to <em>override</em> that member. In this case the binding of the overriding member <span class="math">\(M\)</span> must <a href="#conformance">subsume</a> the binding of the overridden member <span class="math">\(M&#39;\)</span>. Furthermore, the following restrictions on modifiers apply to <span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span>:</p>
<ul>
<li><span class="math">\(M&#39;\)</span> must not be labeled <code>final</code>.</li>
<li><span class="math">\(M\)</span> must not be <a href="#modifiers"><code>private</code></a>.</li>
<li>If <span class="math">\(M\)</span> is labeled <code>private[$C$]</code> for some enclosing class or package <span class="math">\(C\)</span>, then <span class="math">\(M&#39;\)</span> must be labeled <code>private[$C'$]</code> for some class or package <span class="math">\(C&#39;\)</span> where <span class="math">\(C&#39;\)</span> equals <span class="math">\(C\)</span> or <span class="math">\(C&#39;\)</span> is contained in <span class="math">\(C\)</span>. <!-- TODO: check whether this is accurate --></li>
<li>If <span class="math">\(M\)</span> is labeled <code>protected</code>, then <span class="math">\(M&#39;\)</span> must also be labeled <code>protected</code>.</li>
<li>If <span class="math">\(M&#39;\)</span> is not an abstract member, then <span class="math">\(M\)</span> must be labeled <code>override</code>. Furthermore, one of two possibilities must hold:
<ul>
<li>either <span class="math">\(M\)</span> is defined in a subclass of the class where is <span class="math">\(M&#39;\)</span> is defined,</li>
<li>or both <span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span> override a third member <span class="math">\(M&#39;&#39;\)</span> which is defined in a base class of both the classes containing <span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span></li>
</ul></li>
<li>If <span class="math">\(M&#39;\)</span> is <a href="#modifiers">incomplete</a> in <span class="math">\(C\)</span> then <span class="math">\(M\)</span> must be labeled <code>abstract override</code>.</li>
<li>If <span class="math">\(M\)</span> and <span class="math">\(M&#39;\)</span> are both concrete value definitions, then either none of them is marked <code>lazy</code> or both must be marked <code>lazy</code>.</li>
</ul>
<p>A special rule concerns parameterless methods. If a paramterless method defined as <code>def $f$: $T$ = ...</code> or <code>def $f$ = ...</code> overrides a method of type <span class="math">\(()T&#39;\)</span> which has an empty parameter list, then <span class="math">\(f\)</span> is also assumed to have an empty parameter list.</p>
<p>Another restriction applies to abstract type members: An abstract type member with a <a href="#volatile-types">volatile type</a> as its upper bound may not override an abstract type member which does not have a volatile upper bound.</p>
<p>An overriding method inherits all default arguments from the definition in the superclass. By specifying default arguments in the overriding method it is possible to add new defaults (if the corresponding parameter in the superclass does not have a default) or to override the defaults of the superclass (otherwise).</p>
<ol start="44" type="1">
<li><p>Consider the definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Root { <span class="kw">type</span> T &lt;: Root }
<span class="kw">trait</span> A <span class="kw">extends</span> Root { <span class="kw">type</span> T &lt;: A }
<span class="kw">trait</span> B <span class="kw">extends</span> Root { <span class="kw">type</span> T &lt;: B }
<span class="kw">trait</span> C <span class="kw">extends</span> A <span class="kw">with</span> B </code></pre>
<p>Then the class definition <code>C</code> is not well-formed because the binding of <code>T</code> in <code>C</code> is <code>type T &lt;: B</code>, which fails to subsume the binding <code>type T &lt;: A</code> of <code>T</code> in type <code>A</code>. The problem can be solved by adding an overriding definition of type <code>T</code> in class <code>C</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> C <span class="kw">extends</span> A <span class="kw">with</span> B { <span class="kw">type</span> T &lt;: C }</code></pre></li>
</ol>
<h3 id="inheritance-closure"><a href="#inheritance-closure"><span class="header-section-number">5.1.5</span> Inheritance Closure</a></h3>
<p>Let <span class="math">\(C\)</span> be a class type. The <em>inheritance closure</em> of <span class="math">\(C\)</span> is the smallest set <span class="math">\(\mathscr{S}\)</span> of types such that</p>
<ul>
<li>If <span class="math">\(T\)</span> is in <span class="math">\(\mathscr{S}\)</span>, then every type <span class="math">\(T&#39;\)</span> which forms syntactically a part of <span class="math">\(T\)</span> is also in <span class="math">\(\mathscr{S}\)</span>.</li>
<li>If <span class="math">\(T\)</span> is a class type in <span class="math">\(\mathscr{S}\)</span>, then all <a href="#templates">parents</a> of <span class="math">\(T\)</span> are also in <span class="math">\(\mathscr{S}\)</span>.</li>
</ul>
<p>It is a static error if the inheritance closure of a class type consists of an infinite number of types. (This restriction is necessary to make subtyping decidable <span class="citation" data-cites="kennedy-pierce:decidable">(Kennedy and Pierce 2007)</span>).</p>
<h3 id="early-definitions"><a href="#early-definitions"><span class="header-section-number">5.1.6</span> Early Definitions</a></h3>
<pre class="sourceCode scala"><code class="sourceCode scala">EarlyDefs         ::= `{&#39; [EarlyDef {semi EarlyDef}] `}&#39; `with&#39;
EarlyDef          ::=  {Annotation} {Modifier} PatVarDef</code></pre>
<p>A template may start with an <em>early field definition</em> clause, which serves to define certain field values before the supertype constructor is called. In a template</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> $p_1$: $T_1$ = $e_1$
  ...
  <span class="kw">val</span> $p_n$: $T_n$ = $e_n$
} <span class="kw">with</span> $sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $mt_n$ { $\mathit{stats}$ }</code></pre>
<p>The initial pattern definitions of <span class="math">\(p_1 , \ldots , p_n\)</span> are called <em>early definitions</em>. They define fields which form part of the template. Every early definition must define at least one variable.</p>
<p>An early definition is type-checked and evaluated in the scope which is in effect just before the template being defined, augmented by any type parameters of the enclosing class and by any early definitions preceding the one being defined. In particular, any reference to <code>this</code> in the right-hand side of an early definition refers to the identity of <code>this</code> just outside the template. Consequently, it is impossible that an early definition refers to the object being constructed by the template, or refers to one of its fields and methods, except for any other preceding early definition in the same section. Furthermore, references to preceding early definitions always refer to the value that's defined there, and do not take into account overriding definitions. In other words, a block of early definitions is evaluated exactly as if it was a local bock containing a number of value definitions.</p>
<p>Early definitions are evaluated in the order they are being defined before the superclass constructor of the template is called.</p>
<ol start="45" type="1">
<li><p>Early definitions are particularly useful for traits, which do not have normal constructor parameters. Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Greeting {
  <span class="kw">val</span> name: String
  <span class="kw">val</span> msg = <span class="st">&quot;How are you, &quot;</span>+name
}
<span class="kw">class</span> C <span class="kw">extends</span> {
  <span class="kw">val</span> name = <span class="st">&quot;Bob&quot;</span>
} <span class="kw">with</span> Greeting {
  <span class="fu">println</span>(msg)
}</code></pre>
<p>In the code above, the field <code>name</code> is initialized before the constructor of <code>Greeting</code> is called. Therefore, field <code>msg</code> in class <code>Greeting</code> is properly initialized to <code>&quot;How are you, Bob&quot;</code>.</p>
<p>If <code>name</code> had been initialized instead in <code>C</code>'s normal class body, it would be initialized after the constructor of <code>Greeting</code>. In that case, <code>msg</code> would be initialized to <code>&quot;How are you, &lt;null&gt;&quot;</code>.</p></li>
</ol>
<h2 id="modifiers"><a href="#modifiers"><span class="header-section-number">5.2</span> Modifiers</a></h2>
<pre class="grammar"><code>Modifier          ::=  LocalModifier 
                    |  AccessModifier
                    |  `override&#39;
LocalModifier     ::=  `abstract&#39;
                    |  `final&#39;
                    |  `sealed&#39;
                    |  `implicit&#39;
                    |  `lazy&#39;
AccessModifier    ::=  (`private&#39; | `protected&#39;) [AccessQualifier]
AccessQualifier   ::=  `[&#39; (id | `this&#39;) `]&#39;</code></pre>
<p>Member definitions may be preceded by modifiers which affect the accessibility and usage of the identifiers bound by them. If several modifiers are given, their order does not matter, but the same modifier may not occur more than once. Modifiers preceding a repeated definition apply to all constituent definitions. The rules governing the validity and meaning of a modifier are as follows.</p>
<ul>
<li>The <code>private</code> modifier can be used with any definition or declaration in a template. Such members can be accessed only from within the directly enclosing template and its companion module or <a href="#object-definitions">companion class</a>. They are not inherited by subclasses and they may not override definitions in parent classes.</li>
</ul>
<p>The modifier can be <em>qualified</em> with an identifier <span class="math">\(C\)</span> (e.g. <code>private[$C$]</code>) that must denote a class or package enclosing the definition. Members labeled with such a modifier are accessible respectively only from code inside the package <span class="math">\(C\)</span> or only from code inside the class <span class="math">\(C\)</span> and its <a href="#object-definitions">companion module</a>. Such members are also inherited only from templates inside <span class="math">\(C\)</span>.</p>
<p>An different form of qualification is <code>private[this]</code>. A member <span class="math">\(M\)</span> marked with this modifier can be accessed only from within the object in which it is defined. That is, a selection <span class="math">\(p.M\)</span> is only legal if the prefix is <code>this</code> or <code>$O$.this</code>, for some class <span class="math">\(O\)</span> enclosing the reference. In addition, the restrictions for unqualified <code>private</code> apply.</p>
<p>Members marked private without a qualifier are called <em>class-private</em>, whereas members labeled with <code>private[this]</code> are called <em>object-private</em>. A member <em>is private</em> if it is either class-private or object-private, but not if it is marked <code>private[$C$]</code> where <span class="math">\(C\)</span> is an identifier; in the latter case the member is called <em>qualified private</em>.</p>
<p>Class-private or object-private members may not be abstract, and may not have <code>protected</code> or <code>override</code> modifiers.</p>
<ul>
<li>The <code>protected</code> modifier applies to class member definitions. Protected members of a class can be accessed from within
<ul>
<li>the template of the defining class,</li>
<li>all templates that have the defining class as a base class,</li>
<li>the companion module of any of those classes. A <code>protected</code> modifier can be qualified with an identifier <span class="math">\(C\)</span> (e.g. <code>protected[$C$]</code>) that must denote a class or package enclosing the definition. Members labeled with such a modifier are also accessible respectively from all code inside the package <span class="math">\(C\)</span> or from all code inside the class <span class="math">\(C\)</span> and its <a href="#object-definitions">companion module</a>.</li>
</ul></li>
</ul>
<p>A protected identifier <span class="math">\(x\)</span> may be used as a member name in a selection <code>$r$.$x$</code> only if one of the following applies: - The access is within the template defining the member, or, if a qualification <span class="math">\(C\)</span> is given, inside the package <span class="math">\(C\)</span>, or the class <span class="math">\(C\)</span>, or its companion module, or - <span class="math">\(r\)</span> is one of the reserved words <code>this</code> and <code>super</code>, or - <span class="math">\(r\)</span>'s type conforms to a type-instance of the class which contains the access.</p>
<p>A different form of qualification is <code>protected[this]</code>. A member <span class="math">\(M\)</span> marked with this modifier can be accessed only from within the object in which it is defined. That is, a selection <span class="math">\(p.M\)</span> is only legal if the prefix is <code>this</code> or <code>$O$.this</code>, for some class <span class="math">\(O\)</span> enclosing the reference. In addition, the restrictions for unqualified <code>protected</code> apply.</p>
<ul>
<li><p>The <code>override</code> modifier applies to class member definitions or declarations. It is mandatory for member definitions or declarations that override some other concrete member definition in a parent class. If an <code>override</code> modifier is given, there must be at least one overridden member definition or declaration (either concrete or abstract).</p></li>
<li><p>The <code>override</code> modifier has an additional significance when combined with the <code>abstract</code> modifier. That modifier combination is only allowed for value members of traits.</p></li>
</ul>
<p>We call a member <span class="math">\(M\)</span> of a template <em>incomplete</em> if it is either abstract (i.e. defined by a declaration), or it is labeled <code>abstract</code> and <code>override</code> and every member overridden by <span class="math">\(M\)</span> is again incomplete.</p>
<p>Note that the <code>abstract override</code> modifier combination does not influence the concept whether a member is concrete or abstract. A member is <em>abstract</em> if only a declaration is given for it; it is <em>concrete</em> if a full definition is given.</p>
<ul>
<li>The <code>abstract</code> modifier is used in class definitions. It is redundant for traits, and mandatory for all other classes which have incomplete members. Abstract classes cannot be <a href="#instance-creation-expressions">instantiated</a> with a constructor invocation unless followed by mixins and/or a refinement which override all incomplete members of the class. Only abstract classes and traits can have abstract term members.</li>
</ul>
<p>The <code>abstract</code> modifier can also be used in conjunction with <code>override</code> for class member definitions. In that case the previous discussion applies.</p>
<ul>
<li><p>The <code>final</code> modifier applies to class member definitions and to class definitions. A <code>final</code> class member definition may not be overridden in subclasses. A <code>final</code> class may not be inherited by a template. <code>final</code> is redundant for object definitions. Members of final classes or objects are implicitly also final, so the <code>final</code> modifier is generally redundant for them, too. Note, however, that <a href="#value-declarations-and-definitions">constant value definitions</a> do require an explicit <code>final</code> modifier, even if they are defined in a final class or object. <code>final</code> may not be applied to incomplete members, and it may not be combined in one modifier list with <code>sealed</code>.</p></li>
<li><p>The <code>sealed</code> modifier applies to class definitions. A <code>sealed</code> class may not be directly inherited, except if the inheriting template is defined in the same source file as the inherited class. However, subclasses of a sealed class can be inherited anywhere.</p></li>
<li><p>The <code>lazy</code> modifier applies to value definitions. A <code>lazy</code> value is initialized the first time it is accessed (which might never happen at all). Attempting to access a lazy value during its initialization might lead to looping behavior. If an exception is thrown during initialization, the value is considered uninitialized, and a later access will retry to evaluate its right hand side.</p></li>
</ul>
<ol start="46" type="1">
<li><p>The following code illustrates the use of qualified private:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> outerpkg.<span class="fu">innerpkg</span>
<span class="kw">class</span> Outer {
  <span class="kw">class</span> Inner {
    <span class="kw">private</span>[Outer] <span class="kw">def</span> <span class="fu">f</span>()
    <span class="kw">private</span>[innerpkg] <span class="kw">def</span> <span class="fu">g</span>()
    <span class="kw">private</span>[outerpkg] <span class="kw">def</span> <span class="fu">h</span>()
  }
}</code></pre>
<p>Here, accesses to the method <code>f</code> can appear anywhere within <code>OuterClass</code>, but not outside it. Accesses to method <code>g</code> can appear anywhere within the package <code>outerpkg.innerpkg</code>, as would be the case for package-private methods in Java. Finally, accesses to method <code>h</code> can appear anywhere within package <code>outerpkg</code>, including packages contained in it.</p></li>
<li><p>A useful idiom to prevent clients of a class from constructing new instances of that class is to declare the class <code>abstract</code> and <code>sealed</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> m {
  <span class="kw">abstract</span> <span class="kw">sealed</span> <span class="kw">class</span> <span class="fu">C</span> (x: Int) {
    <span class="kw">def</span> nextC = <span class="kw">new</span> <span class="fu">C</span>(x + <span class="dv">1</span>) {}
  }
  <span class="kw">val</span> empty = <span class="kw">new</span> <span class="fu">C</span>(<span class="dv">0</span>) {}
}</code></pre>
<p>For instance, in the code above clients can create instances of class <code>m.C</code> only by calling the <code>nextC</code> method of an existing <code>m.C</code> object; it is not possible for clients to create objects of class <code>m.C</code> directly. Indeed the following two lines are both in error:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> m.<span class="fu">C</span>(<span class="dv">0</span>)    <span class="co">// **** error: C is abstract, so it cannot be instantiated.</span>
<span class="kw">new</span> m.<span class="fu">C</span>(<span class="dv">0</span>) {} <span class="co">// **** error: illegal inheritance from sealed class.</span></code></pre>
<p>A similar access restriction can be achieved by marking the primary constructor <code>private</code> (see ).</p></li>
</ol>
<h2 id="class-definitions"><a href="#class-definitions"><span class="header-section-number">5.3</span> Class Definitions</a></h2>
<pre class="grammar"><code>TmplDef           ::=  `class&#39; ClassDef 
ClassDef          ::=  id [TypeParamClause] {Annotation} 
                       [AccessModifier] ClassParamClauses ClassTemplateOpt 
ClassParamClauses ::=  {ClassParamClause} 
                       [[nl] `(&#39; implicit ClassParams `)&#39;]
ClassParamClause  ::=  [nl] `(&#39; [ClassParams] &#39;)&#39;
ClassParams       ::=  ClassParam {`,&#39; ClassParam}
ClassParam        ::=  {Annotation} [{Modifier} (`val&#39; | `var&#39;)] 
                       id [`:&#39; ParamType] [`=&#39; Expr]
ClassTemplateOpt  ::=  `extends&#39; ClassTemplate | [[`extends&#39;] TemplateBody]</code></pre>
<p>The most general form of class definition is</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> $c$[$\mathit{tps}\,$] $as$ $m$($\mathit{ps}_1$)$\ldots$($\mathit{ps}_n$) <span class="kw">extends</span> $t$    $\<span class="fu">gap</span>(n \geq <span class="dv">0</span>)$.</code></pre>
<p>Here,</p>
<ul>
<li><span class="math">\(c\)</span> is the name of the class to be defined.</li>
<li><span class="math">\(\mathit{tps}\)</span> is a non-empty list of type parameters of the class being defined. The scope of a type parameter is the whole class definition including the type parameter section itself. It is illegal to define two type parameters with the same name. The type parameter section <code>[$\mathit{tps}\,$]</code> may be omitted. A class with a type parameter section is called <em>polymorphic</em>, otherwise it is called <em>monomorphic</em>.</li>
<li><span class="math">\(as\)</span> is a possibly empty sequence of <a href="#user-defined-annotations">annotations</a>. If any annotations are given, they apply to the primary constructor of the class.</li>
<li><span class="math">\(m\)</span> is an <a href="#modifiers">access modifier</a> such as <code>private</code> or <code>protected</code>, possibly with a qualification. If such an access modifier is given it applies to the primary constructor to the class.</li>
<li><p><span class="math">\((\mathit{ps}_1)\ldots(\mathit{ps}_n)\)</span> are formal value parameter clauses for the {} of the class. The scope of a formal value parameter includes all subsequent parameter sections and the template <span class="math">\(t\)</span>. However, a formal value parameter may not form part of the types of any of the parent classes or members of the class template <span class="math">\(t\)</span>. It is illegal to define two formal value parameters with the same name. If no formal parameter sections are given, an empty parameter section <code>()</code> is assumed.</p>
If a formal parameter declaration <span class="math">\(x: T\)</span> is preceded by a <code>val</code> or <code>var</code> keyword, an accessor (getter) <a href="#variable-declarations-and-definitions">definition</a> for this parameter is implicitly added to the class. The getter introduces a value member <span class="math">\(x\)</span> of class <span class="math">\(c\)</span> that is defined as an alias of the parameter. If the introducing keyword is <code>var</code>, a setter accessor <a href="#variable-declarations-and-definitions"><code>$x$_=</code></a> is also implicitly added to the class. In invocation of that setter <code>$x$_=($e$)</code> changes the value of the parameter to the result of evaluating <span class="math">\(e\)</span>. The formal parameter declaration may contain modifiers, which then carry over to the accessor definition(s). A formal parameter prefixed by <code>val</code> or <code>var</code> may not at the same time be a <a href="#by-name-parameters">call-by-name parameter</a>.</li>
<li><p><span class="math">\(t\)</span> is a <a href="#templates">template</a> of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_m$ { $\mathit{stats}$ } <span class="co">// $m \geq 0$</span></code></pre>
<p>which defines the base classes, behavior and initial state of objects of the class. The extends clause <code>extends $sc$ with $mt_1$ with $\ldots$ with $mt_m$</code> can be omitted, in which case <code>extends scala.AnyRef</code> is assumed. The class body <code>{ $\mathit{stats}$ }</code> may also be omitted, in which case the empty body <code>{}</code> is assumed.</p></li>
</ul>
<p>This class definition defines a type <code>$c$[$\mathit{tps}\,$]</code> and a constructor which when applied to parameters conforming to types <span class="math">\(\mathit{ps}\)</span> initializes instances of type <code>$c$[$\mathit{tps}\,$]</code> by evaluating the template <span class="math">\(t\)</span>.</p>
<ol start="48" type="1">
<li><p>The following example illustrates <code>val</code> and <code>var</code> parameters of a class <code>C</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">C</span>(x: Int, <span class="kw">val</span> y: String, <span class="kw">var</span> z: List[String])
<span class="kw">val</span> c = <span class="kw">new</span> <span class="fu">C</span>(<span class="dv">1</span>, <span class="st">&quot;abc&quot;</span>, List())
c.<span class="fu">z</span> = c.<span class="fu">y</span> :: c.<span class="fu">z</span></code></pre></li>
<li><p>The following class can be created only from its companion module.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Sensitive {
  <span class="kw">def</span> <span class="fu">makeSensitive</span>(credentials: Certificate): Sensitive = 
    <span class="kw">if</span> (credentials == Admin) <span class="kw">new</span> <span class="fu">Sensitive</span>() 
    <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> SecurityViolationException
}
<span class="kw">class</span> Sensitive <span class="kw">private</span> () {
  ...
}</code></pre></li>
</ol>
<h3 id="constructor-definitions"><a href="#constructor-definitions"><span class="header-section-number">5.3.1</span> Constructor Definitions</a></h3>
<pre class="grammar"><code>FunDef         ::= `this&#39; ParamClause ParamClauses 
                   (`=&#39; ConstrExpr | [nl] ConstrBlock)
ConstrExpr     ::= SelfInvocation
                |  ConstrBlock
ConstrBlock    ::= `{&#39; SelfInvocation {semi BlockStat} `}&#39;
SelfInvocation ::= `this&#39; ArgumentExprs {ArgumentExprs}</code></pre>
<p>A class may have additional constructors besides the primary constructor. These are defined by constructor definitions of the form <code>def this($\mathit{ps}_1$)$\ldots$($\mathit{ps}_n$) = $e$</code>. Such a definition introduces an additional constructor for the enclosing class, with parameters as given in the formal parameter lists <span class="math">\(\mathit{ps}_1 , \ldots , \mathit{ps}_n\)</span>, and whose evaluation is defined by the constructor expression <span class="math">\(e\)</span>. The scope of each formal parameter is the subsequent parameter sections and the constructor expression <span class="math">\(e\)</span>. A constructor expression is either a self constructor invocation <code>this($\mathit{args}_1$)$\ldots$($\mathit{args}_n$)</code> or a block which begins with a self constructor invocation. The self constructor invocation must construct a generic instance of the class. I.e. if the class in question has name <span class="math">\(C\)</span> and type parameters <code>[$\mathit{tps}\,$]</code>, then a self constructor invocation must generate an instance of <code>$C$[$\mathit{tps}\,$]</code>; it is not permitted to instantiate formal type parameters.</p>
<p>The signature and the self constructor invocation of a constructor definition are type-checked and evaluated in the scope which is in effect at the point of the enclosing class definition, augmented by any type parameters of the enclosing class and by any <a href="#early-definitions">early definitions</a> of the enclosing template. The rest of the constructor expression is type-checked and evaluated as a function body in the current class.</p>
<p>If there are auxiliary constructors of a class <span class="math">\(C\)</span>, they form together with <span class="math">\(C\)</span>'s primary <a href="#class-definitions">constructor</a> an overloaded constructor definition. The usual rules for <a href="#overloading-resolution">overloading resolution</a> apply for constructor invocations of <span class="math">\(C\)</span>, including for the self constructor invocations in the constructor expressions themselves. However, unlike other methods, constructors are never inherited. To prevent infinite cycles of constructor invocations, there is the restriction that every self constructor invocation must refer to a constructor definition which precedes it (i.e. it must refer to either a preceding auxiliary constructor or the primary constructor of the class).</p>
<ol start="50" type="1">
<li><p>Consider the class definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> LinkedList[A]() {
  <span class="kw">var</span> head = _ 
  <span class="kw">var</span> tail = <span class="kw">null</span> 
  <span class="kw">def</span> isEmpty = tail != <span class="kw">null</span>   
  <span class="kw">def</span> <span class="kw">this</span>(head: A) = { <span class="kw">this</span>(); <span class="kw">this</span>.<span class="fu">head</span> = head }
  <span class="kw">def</span> <span class="kw">this</span>(head: A, tail: List[A]) = { <span class="kw">this</span>(head); <span class="kw">this</span>.<span class="fu">tail</span> = tail }
}</code></pre>
<p>This defines a class <code>LinkedList</code> with three constructors. The second constructor constructs an singleton list, while the third one constructs a list with a given head and tail.</p></li>
</ol>
<h2 id="case-classes"><a href="#case-classes"><span class="header-section-number">5.4</span> Case Classes</a></h2>
<pre class="grammar"><code>TmplDef  ::=  `case&#39; `class&#39; ClassDef</code></pre>
<p>If a class definition is prefixed with <code>case</code>, the class is said to be a <em>case class</em>.</p>
<p>The formal parameters in the first parameter section of a case class are called <em>elements</em>; they are treated specially. First, the value of such a parameter can be extracted as a field of a constructor pattern. Second, a <code>val</code> prefix is implicitly added to such a parameter, unless the parameter carries already a <code>val</code> or <code>var</code> modifier. Hence, an accessor definition for the parameter is <a href="#class-definitions">generated</a>.</p>
<p>A case class definition of <code>$c$[$\mathit{tps}\,$]($\mathit{ps}_1\,$)$\ldots$($\mathit{ps}_n$)</code> with type parameters <span class="math">\(\mathit{tps}\)</span> and value parameters <span class="math">\(\mathit{ps}\)</span> implicitly generates an <a href="#extractor-patterns">extractor object</a> which is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> $c$ {
  <span class="kw">def</span> apply[$\mathit{tps}\,$]($\mathit{ps}_1\,$)$\ldots$($\mathit{ps}_n$): $c$[$\mathit{tps}\,$] = <span class="kw">new</span> $c$[$\mathit{Ts}\,$]($\mathit{xs}_1\,$)$\ldots$($\mathit{xs}_n$)
  <span class="kw">def</span> unapply[$\mathit{tps}\,$]($x$: $c$[$\mathit{tps}\,$]) =
    <span class="kw">if</span> (x eq <span class="kw">null</span>) scala.<span class="fu">None</span>
    <span class="kw">else</span> scala.<span class="fu">Some</span>($x.\mathit{xs}_{<span class="dv">11</span>}, \ldots , x.\mathit{xs}_{1k}$)
}</code></pre>
<p>Here, <span class="math">\(\mathit{Ts}\)</span> stands for the vector of types defined in the type parameter section <span class="math">\(\mathit{tps}\)</span>, each <span class="math">\(\mathit{xs}_i\)</span> denotes the parameter names of the parameter section <span class="math">\(\mathit{ps}_i\)</span>, and <span class="math">\(\mathit{xs}_{11}, \ldots , \mathit{xs}_{1k}\)</span> denote the names of all parameters in the first parameter section <span class="math">\(\mathit{xs}_1\)</span>. If a type parameter section is missing in the class, it is also missing in the <code>apply</code> and <code>unapply</code> methods. The definition of <code>apply</code> is omitted if class <span class="math">\(c\)</span> is <code>abstract</code>.</p>
<p>If the case class definition contains an empty value parameter list, the <code>unapply</code> method returns a <code>Boolean</code> instead of an <code>Option</code> type and is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> unapply[$\mathit{tps}\,$]($x$: $c$[$\mathit{tps}\,$]) = x ne <span class="kw">null</span></code></pre>
<p>The name of the <code>unapply</code> method is changed to <code>unapplySeq</code> if the first parameter section <span class="math">\(\mathit{ps}_1\)</span> of <span class="math">\(c\)</span> ends in a <a href="#repeated-parameters">repeated parameter</a>. If a companion object <span class="math">\(c\)</span> exists already, no new object is created, but the <code>apply</code> and <code>unapply</code> methods are added to the existing object instead.</p>
<p>A method named <code>copy</code> is implicitly added to every case class unless the class already has a member (directly defined or inherited) with that name. The method is defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> copy[$\mathit{tps}\,$]($\mathit{ps}&#39;_1\,$)$\ldots$($\mathit{ps}&#39;_n$): $c$[$\mathit{tps}\,$] = <span class="kw">new</span> $c$[$\mathit{Ts}\,$]($\mathit{xs}_1\,$)$\ldots$($\mathit{xs}_n$)</code></pre>
<p>Again, <span class="math">\(\mathit{Ts}\)</span> stands for the vector of types defined in the type parameter section <span class="math">\(\mathit{tps}\)</span> and each <span class="math">\(\mathit{xs}_i\)</span> denotes the parameter names of the parameter section <span class="math">\(\mathit{ps}&#39;_i\)</span>. Every value parameter <span class="math">\(\mathit{ps}&#39;_{i,j}\)</span> of the <code>copy</code> method has the form <code>$x_{i,j}$:$T_{i,j}$=this.$x_{i,j}$</code>, where <span class="math">\(x_{i,j}\)</span> and <span class="math">\(T_{i,j}\)</span> refer to the name and type of the corresponding class parameter <span class="math">\(\mathit{ps}_{i,j}\)</span>.</p>
<p>Every case class implicitly overrides some method definitions of class <a href="#root-classes"><code>scala.AnyRef</code></a> unless a definition of the same method is already given in the case class itself or a concrete definition of the same method is given in some base class of the case class different from <code>AnyRef</code>. In particular:</p>
<ul>
<li>Method <code>equals: (Any)Boolean</code> is structural equality, where two instances are equal if they both belong to the case class in question and they have equal (with respect to <code>equals</code>) constructor arguments.</li>
<li>Method <code>hashCode: Int</code> computes a hash-code. If the hashCode methods of the data structure members map equal (with respect to equals) values to equal hash-codes, then the case class hashCode method does too.</li>
<li>Method <code>toString: String</code> returns a string representation which contains the name of the class and its elements.</li>
</ul>
<ol start="51" type="1">
<li><p>Here is the definition of abstract syntax for lambda calculus:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Expr 
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Var</span>   (x: String)          <span class="kw">extends</span> Expr
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Apply</span> (f: Expr, e: Expr)   <span class="kw">extends</span> Expr
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Lambda</span>(x: String, e: Expr) <span class="kw">extends</span> Expr </code></pre>
<p>This defines a class <code>Expr</code> with case classes <code>Var</code>, <code>Apply</code> and <code>Lambda</code>. A call-by-value evaluator for lambda expressions could then be written as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Env = String =&gt; Value 
<span class="kw">case</span> <span class="kw">class</span> Value(e: Expr, env: Env) 

<span class="kw">def</span> <span class="fu">eval</span>(e: Expr, env: Env): Value = e <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Var</span> (x) =&gt;
    <span class="fu">env</span>(x)
  <span class="kw">case</span> <span class="fu">Apply</span>(f, g) =&gt;
    <span class="kw">val</span> Value(<span class="fu">Lambda</span> (x, e1), env1) = <span class="fu">eval</span>(f, env) 
    <span class="kw">val</span> v = <span class="fu">eval</span>(g, env) 
    <span class="fu">eval</span> (e1, (y =&gt; <span class="kw">if</span> (y == x) v <span class="kw">else</span> <span class="fu">env1</span>(y)))
  <span class="kw">case</span> <span class="fu">Lambda</span>(_, _) =&gt;
    Value(e, env)
}</code></pre>
<p>It is possible to define further case classes that extend type <code>Expr</code> in other parts of the program, for instance</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Number(x: Int) <span class="kw">extends</span> Expr </code></pre>
<p>This form of extensibility can be excluded by declaring the base class <code>Expr</code> <code>sealed</code>; in this case, all classes that directly extend <code>Expr</code> must be in the same source file as <code>Expr</code>.</p></li>
</ol>
<h3 id="traits"><a href="#traits"><span class="header-section-number">5.4.1</span> Traits</a></h3>
<pre class="grammar"><code>TmplDef          ::=  `trait&#39; TraitDef
TraitDef         ::=  id [TypeParamClause] TraitTemplateOpt
TraitTemplateOpt ::=  `extends&#39; TraitTemplate | [[`extends&#39;] TemplateBody]</code></pre>
<p>A trait is a class that is meant to be added to some other class as a mixin. Unlike normal classes, traits cannot have constructor parameters. Furthermore, no constructor arguments are passed to the superclass of the trait. This is not necessary as traits are initialized after the superclass is initialized.</p>
<p>Assume a trait <span class="math">\(D\)</span> defines some aspect of an instance <span class="math">\(x\)</span> of type <span class="math">\(C\)</span> (i.e. <span class="math">\(D\)</span> is a base class of <span class="math">\(C\)</span>). Then the {} of <span class="math">\(D\)</span> in <span class="math">\(x\)</span> is the compound type consisting of all the base classes in <span class="math">\(\mathcal{L}(C)\)</span> that succeed <span class="math">\(D\)</span>. The actual supertype gives the context for resolving a <a href="#this-and-super"><code>super</code> reference</a> in a trait. Note that the actual supertype depends on the type to which the trait is added in a mixin composition; it is not statically known at the time the trait is defined.</p>
<p>If <span class="math">\(D\)</span> is not a trait, then its actual supertype is simply its least proper supertype (which is statically known).</p>
<ol start="52" type="1">
<li><p>The following trait defines the property of being comparable to objects of some type. It contains an abstract method <code>&lt;</code> and default implementations of the other comparison operators <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Comparable[T &lt;: Comparable[T]] { self: T =&gt;
  <span class="kw">def</span> &lt; (that: T): Boolean
  <span class="kw">def</span> &lt;=(that: T): Boolean = <span class="kw">this</span> &lt; that || <span class="kw">this</span> == that
  <span class="kw">def</span> &gt; (that: T): Boolean = that &lt; <span class="kw">this</span> 
  <span class="kw">def</span> &gt;=(that: T): Boolean = that &lt;= <span class="kw">this</span>
}</code></pre></li>
<li><p>Consider an abstract class <code>Table</code> that implements maps from a type of keys <code>A</code> to a type of values <code>B</code>. The class has a method <code>set</code> to enter a new key / value pair into the table, and a method <code>get</code> that returns an optional value matching a given key. Finally, there is a method <code>apply</code> which is like <code>get</code>, except that it returns a given default value if the table is undefined for the given key. This class is implemented as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Table[A, B](defaultValue: B) {
  <span class="kw">def</span> <span class="fu">get</span>(key: A): Option[B]
  <span class="kw">def</span> <span class="fu">set</span>(key: A, value: B)
  <span class="kw">def</span> <span class="fu">apply</span>(key: A) = <span class="fu">get</span>(key) <span class="kw">match</span> {
    <span class="kw">case</span> Some(value) =&gt; value
    <span class="kw">case</span> None =&gt; defaultValue
  }
}</code></pre>
<p>Here is a concrete implementation of the <code>Table</code> class.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> ListTable[A, B](defaultValue: B) <span class="kw">extends</span> Table[A, B](defaultValue) {
  <span class="kw">private</span> <span class="kw">var</span> elems: List[(A, B)]
  <span class="kw">def</span> <span class="fu">get</span>(key: A) = elems.<span class="fu">find</span>(.<span class="fu">_1</span>.==(key)).<span class="fu">map</span>(.<span class="fu">_2</span>)
  <span class="kw">def</span> <span class="fu">set</span>(key: A, value: B) = { elems = (key, value) :: elems }
}</code></pre>
<p>Here is a trait that prevents concurrent access to the <code>get</code> and <code>set</code> operations of its parent class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> SynchronizedTable[A, B] <span class="kw">extends</span> Table[A, B] {
  <span class="kw">abstract</span> <span class="kw">override</span> <span class="kw">def</span> <span class="fu">get</span>(key: A): B = 
    synchronized { <span class="kw">super</span>.<span class="fu">get</span>(key) }
  <span class="kw">abstract</span> <span class="kw">override</span> <span class="kw">def</span> <span class="fu">set</span>((key: A, value: B) = 
    synchronized { <span class="kw">super</span>.<span class="fu">set</span>(key, value) }
}</code></pre>
<p>Note that <code>SynchronizedTable</code> does not pass an argument to its superclass, <code>Table</code>, even though <code>Table</code> is defined with a formal parameter. Note also that the <code>super</code> calls in <code>SynchronizedTable</code>'s <code>get</code> and <code>set</code> methods statically refer to abstract methods in class <code>Table</code>. This is legal, as long as the calling method is labeled <a href="#modifiers"><code>abstract override</code></a>.</p>
<p>Finally, the following mixin composition creates a synchronized list table with strings as keys and integers as values and with a default value <code>0</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> MyTable <span class="kw">extends</span> ListTable[String, Int](<span class="dv">0</span>) <span class="kw">with</span> SynchronizedTable</code></pre>
<p>The object <code>MyTable</code> inherits its <code>get</code> and <code>set</code> method from <code>SynchronizedTable</code>. The <code>super</code> calls in these methods are re-bound to refer to the corresponding implementations in <code>ListTable</code>, which is the actual supertype of <code>SynchronizedTable</code> in <code>MyTable</code>.</p></li>
</ol>
<h2 id="object-definitions"><a href="#object-definitions"><span class="header-section-number">5.5</span> Object Definitions</a></h2>
<pre class="grammar"><code>ObjectDef       ::=  id ClassTemplate</code></pre>
<p>An object definition defines a single object of a new class. Its most general form is <code>object $m$ extends $t$</code>. Here, <span class="math">\(m\)</span> is the name of the object to be defined, and <span class="math">\(t\)</span> is a <a href="#templates">template</a> of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ { $\mathit{stats}$ }</code></pre>
<p>which defines the base classes, behavior and initial state of <span class="math">\(m\)</span>. The extends clause <code>extends $sc$ with $mt_1$ with $\ldots$ with $mt_n$</code> can be omitted, in which case <code>extends scala.AnyRef</code> is assumed. The class body <code>{ $\mathit{stats}$ }</code> may also be omitted, in which case the empty body <code>{}</code> is assumed.</p>
<p>The object definition defines a single object (or: <em>module</em>) conforming to the template <span class="math">\(t\)</span>. It is roughly equivalent to the following definition of a lazy value:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">lazy</span> <span class="kw">val</span> $m$ = <span class="kw">new</span> $sc$ <span class="kw">with</span> $mt_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $mt_n$ { <span class="kw">this</span>: $m.<span class="fu">type</span>$ =&gt; $\mathit{stats}$ }</code></pre>
<p>Note that the value defined by an object definition is instantiated lazily. The <code>new $m\Dollar$cls</code> constructor is evaluated not at the point of the object definition, but is instead evaluated the first time <span class="math">\(m\)</span> is dereferenced during execution of the program (which might be never at all). An attempt to dereference <span class="math">\(m\)</span> again in the course of evaluation of the constructor leads to a infinite loop or run-time error.<br />Other threads trying to dereference <span class="math">\(m\)</span> while the constructor is being evaluated block until evaluation is complete.</p>
<p>The expansion given above is not accurate for top-level objects. It cannot be because variable and method definition cannot appear on the top-level outside of a <a href="#package-objects">package object</a>. Instead, top-level objects are translated to static fields.</p>
<ol start="54" type="1">
<li><p>Classes in Scala do not have static members; however, an equivalent effect can be achieved by an accompanying object definition E.g.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Point {
  <span class="kw">val</span> x: Double 
  <span class="kw">val</span> y: Double 
  <span class="kw">def</span> isOrigin = (x == <span class="fl">0.0</span> &amp;&amp; y == <span class="fl">0.0</span>) 
}
<span class="kw">object</span> Point {
  <span class="kw">val</span> origin = <span class="kw">new</span> Point() { <span class="kw">val</span> x = <span class="fl">0.0</span>; <span class="kw">val</span> y = <span class="fl">0.0</span> }
}</code></pre>
<p>This defines a class <code>Point</code> and an object <code>Point</code> which contains <code>origin</code> as a member. Note that the double use of the name <code>Point</code> is legal, since the class definition defines the name <code>Point</code> in the type name space, whereas the object definition defines a name in the term namespace.</p>
<p>This technique is applied by the Scala compiler when interpreting a Java class with static members. Such a class <span class="math">\(C\)</span> is conceptually seen as a pair of a Scala class that contains all instance members of <span class="math">\(C\)</span> and a Scala object that contains all static members of <span class="math">\(C\)</span>.</p>
<p>Generally, a <em>companion module</em> of a class is an object which has the same name as the class and is defined in the same scope and compilation unit. Conversely, the class is called the <em>companion class</em> of the module.</p></li>
</ol>
<h1 id="expressions"><a href="#expressions"><span class="header-section-number">6</span> Expressions</a></h1>
<pre class="grammar"><code>  Expr              ::=  (Bindings | id | `_&#39;) `=&gt;&#39; Expr
                      |  Expr1
  Expr1             ::=  `if&#39; `(&#39; Expr `)&#39; {nl} Expr [[semi] else Expr]
                      |  `while&#39; `(&#39; Expr `)&#39; {nl} Expr
                      |  `try&#39; `{&#39; Block `}&#39; [`catch&#39;  `{&#39; CaseClauses `}&#39;] 
                         [`finally&#39; Expr]
                      |  `do&#39; Expr [semi] `while&#39; `(&#39; Expr &#39;)&#39;
                      |  `for&#39; (`(&#39; Enumerators `)&#39; | `{&#39; Enumerators `}&#39;) 
                         {nl} [`yield&#39;] Expr
                      |  `throw&#39; Expr
                      |  `return&#39; [Expr]
                      |  [SimpleExpr `.&#39;] id `=&#39; Expr
                      |  SimpleExpr1 ArgumentExprs `=&#39; Expr
                      |  PostfixExpr
                      |  PostfixExpr Ascription
                      |  PostfixExpr `match&#39; `{&#39; CaseClauses `}&#39;
  PostfixExpr       ::=  InfixExpr [id [nl]]
  InfixExpr         ::=  PrefixExpr
                      |  InfixExpr id [nl] InfixExpr
  PrefixExpr        ::=  [`-&#39; | `+&#39; | `~&#39; | `!&#39;] SimpleExpr 
  SimpleExpr        ::=  `new&#39; (ClassTemplate | TemplateBody)
                      |  BlockExpr
                      |  SimpleExpr1 [`_&#39;]
  SimpleExpr1       ::=  Literal
                      |  Path
                      |  `_&#39;
                      |  `(&#39; [Exprs] `)&#39;
                      |  SimpleExpr `.&#39; id s
                      |  SimpleExpr TypeArgs
                      |  SimpleExpr1 ArgumentExprs
                      |  XmlExpr
  Exprs             ::=  Expr {`,&#39; Expr}
  BlockExpr         ::=  `{&#39; CaseClauses `}&#39;
                      |  `{&#39; Block `}&#39;
  Block             ::=  {BlockStat semi} [ResultExpr]
  ResultExpr        ::=  Expr1
                      |  (Bindings | ([`implicit&#39;] id | `_&#39;) `:&#39; CompoundType) `=&gt;&#39; Block
  Ascription        ::=  `:&#39; InfixType
                      |  `:&#39; Annotation {Annotation} 
                      |  `:&#39; `_&#39; `*&#39;</code></pre>
<p>Expressions are composed of operators and operands. Expression forms are discussed subsequently in decreasing order of precedence.</p>
<h2 id="expression-typing"><a href="#expression-typing"><span class="header-section-number">6.1</span> Expression Typing</a></h2>
<p>The typing of expressions is often relative to some <em>expected type</em> (which might be undefined). When we write ``expression <span class="math">\(e\)</span> is expected to conform to type <span class="math">\(T\)</span>'', we mean: (1) the expected type of <span class="math">\(e\)</span> is <span class="math">\(T\)</span>, and (2) the type of expression <span class="math">\(e\)</span> must conform to <span class="math">\(T\)</span>.</p>
<p>The following skolemization rule is applied universally for every expression: If the type of an expression would be an existential type <span class="math">\(T\)</span>, then the type of the expression is assumed instead to be a <a href="#existential-types">skolemization</a> of <span class="math">\(T\)</span>.</p>
<p>Skolemization is reversed by type packing. Assume an expression <span class="math">\(e\)</span> of type <span class="math">\(T\)</span> and let <span class="math">\(t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1 , \ldots , t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n\)</span> be all the type variables created by skolemization of some part of <span class="math">\(e\)</span> which are free in <span class="math">\(T\)</span>. Then the <em>packed type</em> of <span class="math">\(e\)</span> is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$T$ <span class="kw">forSome</span> { <span class="kw">type</span> $t_1[\mathit{tps}_1] &gt;: L_1 &lt;: U_1$; $\ldots$; <span class="kw">type</span> $t_n[\mathit{tps}_n] &gt;: L_n &lt;: U_n$ }.</code></pre>
<h2 id="literals-1"><a href="#literals-1"><span class="header-section-number">6.2</span> Literals</a></h2>
<pre class="grammar"><code>SimpleExpr    ::=  Literal</code></pre>
<p>Typing of literals is as described <a href="#literals">here</a>; their evaluation is immediate.</p>
<h2 id="the-null-value"><a href="#the-null-value"><span class="header-section-number">6.3</span> The <em>Null</em> Value</a></h2>
<p>The <code>null</code> value is of type <code>scala.Null</code>, and is thus compatible with every reference type. It denotes a reference value which refers to a special “<code>null</code>” object. This object implements methods in class <code>scala.AnyRef</code> as follows:</p>
<ul>
<li><code>eq($x\,$)</code> and <code>==($x\,$)</code> return <code>true</code> iff the argument <span class="math">\(x\)</span> is also the ``null'' object.</li>
<li><code>ne($x\,$)</code> and <code>!=($x\,$)</code> return true iff the argument x is not also the ``null'' object.</li>
<li><code>isInstanceOf[$T\,$]</code> always returns <code>false</code>.</li>
<li><code>asInstanceOf[$T\,$]</code> returns the `<code>null'' object itself if   $T$ conforms to</code>scala.AnyRef<code>, and throws a</code>NullPointerException` otherwise.</li>
</ul>
<p>A reference to any other member of the `<code>null'' object causes a</code>NullPointerException` to be thrown.</p>
<h2 id="designators"><a href="#designators"><span class="header-section-number">6.4</span> Designators</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr  ::=  Path
              |  SimpleExpr `.&#39; id</code></pre>
<p>A designator refers to a named term. It can be a <em>simple name</em> or a <em>selection</em>.</p>
<p>A simple name <span class="math">\(x\)</span> refers to a value as specified <a href="#identifiers-names-and-scopes">here</a>. If <span class="math">\(x\)</span> is bound by a definition or declaration in an enclosing class or object <span class="math">\(C\)</span>, it is taken to be equivalent to the selection <code>$C$.this.$x$</code> where <span class="math">\(C\)</span> is taken to refer to the class containing <span class="math">\(x\)</span> even if the type name <span class="math">\(C\)</span> is <a href="#identifiers-names-and-scopes">shadowed</a> at the occurrence of <span class="math">\(x\)</span>.</p>
<p>If <span class="math">\(r\)</span> is a <a href="#paths">stable identifier</a> of type <span class="math">\(T\)</span>, the selection <span class="math">\(r.x\)</span> refers statically to a term member <span class="math">\(m\)</span> of <span class="math">\(r\)</span> that is identified in <span class="math">\(T\)</span> by the name <span class="math">\(x\)</span>.</p>
<p>For other expressions <span class="math">\(e\)</span>, <span class="math">\(e.x\)</span> is typed as if it was <code>{ val $y$ = $e$; $y$.$x$ }</code>, for some fresh name <span class="math">\(y\)</span>.</p>
<p>The expected type of a designator's prefix is always undefined. The type of a designator is the type <span class="math">\(T\)</span> of the entity it refers to, with the following exception: The type of a <a href="#paths">path</a> <span class="math">\(p\)</span> which occurs in a context where a <a href="#singleton-types">stable type</a> is required is the singleton type <code>$p$.type</code>.</p>
<p>The contexts where a stable type is required are those that satisfy one of the following conditions:</p>
<ol>
<li>The path <span class="math">\(p\)</span> occurs as the prefix of a selection and it does not designate a constant, or</li>
<li>The expected type <span class="math">\(\mathit{pt}\)</span> is a stable type, or</li>
<li>The expected type <span class="math">\(\mathit{pt}\)</span> is an abstract type with a stable type as lower bound, and the type <span class="math">\(T\)</span> of the entity referred to by <span class="math">\(p\)</span> does not conform to <span class="math">\(\mathit{pt}\)</span>, or</li>
<li>The path <span class="math">\(p\)</span> designates a module.</li>
</ol>
<p>The selection <span class="math">\(e.x\)</span> is evaluated by first evaluating the qualifier expression <span class="math">\(e\)</span>, which yields an object <span class="math">\(r\)</span>, say. The selection's result is then the member of <span class="math">\(r\)</span> that is either defined by <span class="math">\(m\)</span> or defined by a definition overriding <span class="math">\(m\)</span>. If that member has a type which conforms to <code>scala.NotNull</code>, the member's value must be initialized to a value different from <code>null</code>, otherwise a <code>scala.UnitializedError</code> is thrown.</p>
<h2 id="this-and-super"><a href="#this-and-super"><span class="header-section-number">6.5</span> This and Super</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr  ::=  [id `.&#39;] `this&#39;
              |  [id &#39;.&#39;] `super&#39; [ClassQualifier] `.&#39; id</code></pre>
<p>The expression <code>this</code> can appear in the statement part of a template or compound type. It stands for the object being defined by the innermost template or compound type enclosing the reference. If this is a compound type, the type of <code>this</code> is that compound type. If it is a template of a class or object definition with simple name <span class="math">\(C\)</span>, the type of this is the same as the type of <code>$C$.this</code>.</p>
<p>The expression <code>$C$.this</code> is legal in the statement part of an enclosing class or object definition with simple name <span class="math">\(C\)</span>. It stands for the object being defined by the innermost such definition. If the expression's expected type is a stable type, or <code>$C$.this</code> occurs as the prefix of a selection, its type is <code>$C$.this.type</code>, otherwise it is the self type of class <span class="math">\(C\)</span>.</p>
<p>A reference <code>super.$m$</code> refers statically to a method or type <span class="math">\(m\)</span> in the least proper supertype of the innermost template containing the reference. It evaluates to the member <span class="math">\(m&#39;\)</span> in the actual supertype of that template which is equal to <span class="math">\(m\)</span> or which overrides <span class="math">\(m\)</span>. The statically referenced member <span class="math">\(m\)</span> must be a type or a method.</p>
<p>If it is a method, it must be concrete, or the template containing the reference must have a member <span class="math">\(m&#39;\)</span> which overrides <span class="math">\(m\)</span> and which is labeled <code>abstract override</code>.</p>
<p>A reference <code>$C$.super.$m$</code> refers statically to a method or type <span class="math">\(m\)</span> in the least proper supertype of the innermost enclosing class or object definition named <span class="math">\(C\)</span> which encloses the reference. It evaluates to the member <span class="math">\(m&#39;\)</span> in the actual supertype of that class or object which is equal to <span class="math">\(m\)</span> or which overrides <span class="math">\(m\)</span>. The statically referenced member <span class="math">\(m\)</span> must be a type or a method. If the statically referenced member <span class="math">\(m\)</span> is a method, it must be concrete, or the innermost enclosing class or object definition named <span class="math">\(C\)</span> must have a member <span class="math">\(m&#39;\)</span> which overrides <span class="math">\(m\)</span> and which is labeled <code>abstract override</code>.</p>
<p>The <code>super</code> prefix may be followed by a trait qualifier <code>[$T\,$]</code>, as in <code>$C$.super[$T\,$].$x$</code>. This is called a <em>static super reference</em>. In this case, the reference is to the type or method of <span class="math">\(x\)</span> in the parent trait of <span class="math">\(C\)</span> whose simple name is <span class="math">\(T\)</span>. That member must be uniquely defined. If it is a method, it must be concrete.</p>
<ol start="55" type="1">
<li><p>Consider the following class definitions</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Root { <span class="kw">def</span> x = <span class="st">&quot;Root&quot;</span> }
<span class="kw">class</span> A <span class="kw">extends</span> Root { <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;A&quot;</span> ; <span class="kw">def</span> superA = <span class="kw">super</span>.<span class="fu">x</span> }
<span class="kw">trait</span> B <span class="kw">extends</span> Root { <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;B&quot;</span> ; <span class="kw">def</span> superB = <span class="kw">super</span>.<span class="fu">x</span> }
<span class="kw">class</span> C <span class="kw">extends</span> Root <span class="kw">with</span> B { 
  <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;C&quot;</span> ; <span class="kw">def</span> superC = <span class="kw">super</span>.<span class="fu">x</span>
}
<span class="kw">class</span> D <span class="kw">extends</span> A <span class="kw">with</span> B {
  <span class="kw">override</span> <span class="kw">def</span> x = <span class="st">&quot;D&quot;</span> ; <span class="kw">def</span> superD = <span class="kw">super</span>.<span class="fu">x</span>
}</code></pre>
<p>The linearization of class <code>C</code> is <code>{C, B, Root}</code> and the linearization of class <code>D</code> is <code>{D, B, A, Root}</code>. Then we have:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(<span class="kw">new</span> A).<span class="fu">superA</span> == <span class="st">&quot;Root&quot;</span>, 
                          (<span class="kw">new</span> C).<span class="fu">superB</span> = <span class="st">&quot;Root&quot;</span>, (<span class="kw">new</span> C).<span class="fu">superC</span> = <span class="st">&quot;B&quot;</span>,
(<span class="kw">new</span> D).<span class="fu">superA</span> == <span class="st">&quot;Root&quot;</span>, (<span class="kw">new</span> D).<span class="fu">superB</span> = <span class="st">&quot;A&quot;</span>,    (<span class="kw">new</span> D).<span class="fu">superD</span> = <span class="st">&quot;B&quot;</span>,</code></pre>
<p>Note that the <code>superB</code> function returns different results depending on whether <code>B</code> is mixed in with class <code>Root</code> or <code>A</code>.</p></li>
</ol>
<h2 id="function-applications"><a href="#function-applications"><span class="header-section-number">6.6</span> Function Applications</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr    ::=  SimpleExpr1 ArgumentExprs
ArgumentExprs ::=  `(&#39; [Exprs] `)&#39;
                |  `(&#39; [Exprs `,&#39;] PostfixExpr `:&#39; `_&#39; `*&#39; &#39;)&#39;
                |  [nl] BlockExpr
Exprs         ::=  Expr {`,&#39; Expr}</code></pre>
<p>An application <code>$f$($e_1 , \ldots , e_m$)</code> applies the function <span class="math">\(f\)</span> to the argument expressions <span class="math">\(e_1 , \ldots , e_m\)</span>. If <span class="math">\(f\)</span> has a method type <code>($p_1$:$T_1 , \ldots , p_n$:$T_n$)$U$</code>, the type of each argument expression <span class="math">\(e_i\)</span> is typed with the corresponding parameter type <span class="math">\(T_i\)</span> as expected type. Let <span class="math">\(S_i\)</span> be type type of argument <span class="math">\(e_i\)</span> <span class="math">\((i = 1 , \ldots , m)\)</span>. If <span class="math">\(f\)</span> is a polymorphic method, <a href="#local-type-inference">local type inference</a> is used to determine type arguments for <span class="math">\(f\)</span>. If <span class="math">\(f\)</span> has some value type, the application is taken to be equivalent to <code>$f$.apply($e_1 , \ldots , e_m$)</code>, i.e. the application of an <code>apply</code> method defined by <span class="math">\(f\)</span>.</p>
<p>The function <span class="math">\(f\)</span> must be <em>applicable</em> to its arguments <span class="math">\(e_1 , \ldots , e_n\)</span> of types <span class="math">\(S_1 , \ldots , S_n\)</span>.</p>
<p>If <span class="math">\(f\)</span> has a method type <span class="math">\((p_1:T_1 , \ldots , p_n:T_n)U\)</span> we say that an argument expression <span class="math">\(e_i\)</span> is a <em>named</em> argument if it has the form <span class="math">\(x_i=e&#39;_i\)</span> and <span class="math">\(x_i\)</span> is one of the parameter names <span class="math">\(p_1 , \ldots , p_n\)</span>. The function <span class="math">\(f\)</span> is applicable if all of the follwing conditions hold:</p>
<ul>
<li>For every named argument <span class="math">\(x_i=e&#39;_i\)</span> the type <span class="math">\(S_i\)</span> is compatible with the parameter type <span class="math">\(T_j\)</span> whose name <span class="math">\(p_j\)</span> matches <span class="math">\(x_i\)</span>.</li>
<li>For every positional argument <span class="math">\(e_i\)</span> the type <span class="math">\(S_i\)</span> is compatible with <span class="math">\(T_i\)</span>.</li>
<li>If the expected type is defined, the result type <span class="math">\(U\)</span> is compatible to it.</li>
</ul>
<p>If <span class="math">\(f\)</span> is a polymorphic method it is applicable if <a href="#local-type-inference">local type inference</a> can determine type arguments so that the instantiated method is applicable. If <span class="math">\(f\)</span> has some value type it is applicable if it has a method member named <code>apply</code> which is applicable.</p>
<p>Evaluation of <code>$f$($e_1 , \ldots , e_n$)</code> usually entails evaluation of <span class="math">\(f\)</span> and <span class="math">\(e_1 , \ldots , e_n\)</span> in that order. Each argument expression is converted to the type of its corresponding formal parameter. After that, the application is rewritten to the function's right hand side, with actual arguments substituted for formal parameters. The result of evaluating the rewritten right-hand side is finally converted to the function's declared result type, if one is given.</p>
<p>The case of a formal parameter with a parameterless method type <code>=&gt;$T$</code> is treated specially. In this case, the corresponding actual argument expression <span class="math">\(e\)</span> is not evaluated before the application. Instead, every use of the formal parameter on the right-hand side of the rewrite rule entails a re-evaluation of <span class="math">\(e\)</span>. In other words, the evaluation order for <code>=&gt;</code>-parameters is <em>call-by-name</em> whereas the evaluation order for normal parameters is <em>call-by-value</em>. Furthermore, it is required that <span class="math">\(e\)</span>'s <a href="#expression-typing">packed type</a> conforms to the parameter type <span class="math">\(T\)</span>. The behavior of by-name parameters is preserved if the application is transformed into a block due to named or default arguments. In this case, the local value for that parameter has the form <code>val $y_i$ = () =&gt; $e$</code> and the argument passed to the function is <code>$y_i$()</code>.</p>
<p>The last argument in an application may be marked as a sequence argument, e.g. <code>$e$: _*</code>. Such an argument must correspond to a <a href="#repeated-parameters">repeated parameter</a> of type <code>$S$*</code> and it must be the only argument matching this parameter (i.e. the number of formal parameters and actual arguments must be the same). Furthermore, the type of <span class="math">\(e\)</span> must conform to <code>scala.Seq[$T$]</code>, for some type <span class="math">\(T\)</span> which conforms to <span class="math">\(S\)</span>. In this case, the argument list is transformed by replacing the sequence <span class="math">\(e\)</span> with its elements. When the application uses named arguments, the vararg parameter has to be specified exactly once.</p>
<p>A function application usually allocates a new frame on the program's run-time stack. However, if a local function or a final method calls itself as its last action, the call is executed using the stack-frame of the caller.</p>
<ol start="56" type="1">
<li><p>Assume the following function which computes the sum of a variable number of arguments:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">sum</span>(xs: Int*) = (<span class="dv">0</span> /: xs) ((x, y) =&gt; x + y)</code></pre>
<p>Then</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)
<span class="fu">sum</span>(List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>): _*)</code></pre>
<p>both yield <code>10</code> as result. On the other hand,</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sum</span>(List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</code></pre>
<p>would not typecheck.</p></li>
</ol>
<h3 id="named-and-default-arguments"><a href="#named-and-default-arguments"><span class="header-section-number">6.6.1</span> Named and Default Arguments</a></h3>
<p>If an application might uses named arguments <span class="math">\(p = e\)</span> or default arguments, the following conditions must hold.</p>
<ul>
<li>The named arguments form a suffix of the argument list <span class="math">\(e_1 , \ldots , e_m\)</span>, i.e. no positional argument follows a named one.</li>
<li>The names <span class="math">\(x_i\)</span> of all named arguments are pairwise distinct and no named argument defines a parameter which is already specified by a positional argument.</li>
<li>Every formal parameter <span class="math">\(p_j:T_j\)</span> which is not specified by either a positional or a named argument has a default argument.</li>
</ul>
<p>If the application uses named or default arguments the following transformation is applied to convert it into an application without named or default arguments.</p>
<p>If the function <span class="math">\(f\)</span> has the form <code>$p.m$[$\mathit{targs}$]</code> it is transformed into the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> q = $p$
  q.$m$[$\mathit{targs}$]
}</code></pre>
<p>If the function <span class="math">\(f\)</span> is itself an application expression the transformation is applied recursively on <span class="math">\(f\)</span>. The result of transforming <span class="math">\(f\)</span> is a block of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> q = $p$
  <span class="kw">val</span> $x_1$ = expr$_1$
  $\ldots$
  <span class="kw">val</span> $x_k$ = expr$_k$
  q.$m$[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
}</code></pre>
<p>where every argument in <span class="math">\((\mathit{args}_1) , \ldots , (\mathit{args}_l)\)</span> is a reference to one of the values <span class="math">\(x_1 , \ldots , x_k\)</span>. To integrate the current application into the block, first a value definition using a fresh name <span class="math">\(y_i\)</span> is created for every argument in <span class="math">\(e_1 , \ldots , e_m\)</span>, which is initialised to <span class="math">\(e_i\)</span> for positional arguments and to <span class="math">\(e&#39;_i\)</span> for named arguments of the form <code>$x_i=e'_i$</code>. Then, for every parameter which is not specified by the argument list, a value definition using a fresh name <span class="math">\(z_i\)</span> is created, which is initialized using the method computing the <a href="#function-declarations-and-definitions">default argument</a> of this parameter.</p>
<p>Let <span class="math">\(\mathit{args}\)</span> be a permutation of the generated names <span class="math">\(y_i\)</span> and <span class="math">\(z_i\)</span> such such that the position of each name matches the position of its corresponding parameter in the method type <code>($p_1:T_1 , \ldots , p_n:T_n$)$U$</code>. The final result of the transformation is a block of the form</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> q = $p$
  <span class="kw">val</span> $x_1$ = expr$_1$
  $\ldots$
  <span class="kw">val</span> $x_l$ = expr$_k$
  <span class="kw">val</span> $y_1$ = $e_1$
  $\ldots$
  <span class="kw">val</span> $y_m$ = $e_m$
  <span class="kw">val</span> $z_1$ = q.$m$\$default\$i[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
  $\ldots$
  <span class="kw">val</span> $z_d$ = q.$m$\$default\$j[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)
  q.$m$[$\mathit{targs}$]($\mathit{args}_1$)$, \ldots ,$($\mathit{args}_l$)($\mathit{args}$)
}</code></pre>
<h2 id="method-values"><a href="#method-values"><span class="header-section-number">6.7</span> Method Values</a></h2>
<pre class="grammar"><code>SimpleExpr    ::=  SimpleExpr1 `_&#39;</code></pre>
<p>The expression <sub><code>$e$ _</code></sub> is well-formed if <span class="math">\(e\)</span> is of method type or if <span class="math">\(e\)</span> is a call-by-name parameter. If <span class="math">\(e\)</span> is a method with parameters, <code>$e$ _</code>~ represents <span class="math">\(e\)</span> converted to a function type by <a href="#eta-expansion">eta expansion</a>. If <span class="math">\(e\)</span> is a parameterless method or call-by-name parameter of type <code>=&gt;$T$</code>, <code>$e$ _</code>~ represents the function of type <code>() =&gt; $T$</code>, which evaluates <span class="math">\(e\)</span> when it is applied to the empty parameterlist <code>()</code>.</p>
<ol start="57" type="1">
<li><p>The method values in the left column are each equivalent to the <a href="#anonymous-functions">anonymous functions</a> on their right.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">Math.<span class="fu">sin</span> _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; Math.<span class="fu">sin</span>(x)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">Array.<span class="fu">range</span> _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x1, x2) =&gt; Array.<span class="fu">range</span>(x1, x2)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">List.<span class="fu">map2</span> _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x1, x2) =&gt; (x3) =&gt; List.<span class="fu">map2</span>(x1, x2)(x3)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">List.<span class="fu">map2</span>(xs, ys)_</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; List.<span class="fu">map2</span>(xs, ys)(x)</code></td>
</tr>
</tbody>
</table>
<p>Note that a space is necessary between a method name and the trailing underscore because otherwise the underscore would be considered part of the name.</p></li>
</ol>
<h2 id="type-applications"><a href="#type-applications"><span class="header-section-number">6.8</span> Type Applications</a></h2>
<pre class="grammar"><code>SimpleExpr    ::=  SimpleExpr TypeArgs</code></pre>
<p>A type application <code>$e$[$T_1 , \ldots , T_n$]</code> instantiates a polymorphic value <span class="math">\(e\)</span> of type <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1, \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$S$</code> with argument types <code>$T_1 , \ldots , T_n$</code>. Every argument type <span class="math">\(T_i\)</span> must obey the corresponding bounds <span class="math">\(L_i\)</span> and <span class="math">\(U_i\)</span>. That is, for each <span class="math">\(i = 1 , \ldots , n\)</span>, we must have <span class="math">\(\sigma L_i &lt;: T_i &lt;: \sigma U_i\)</span>, where <span class="math">\(\sigma\)</span> is the substitution <span class="math">\([a_1 := T_1 , \ldots , a_n := T_n]\)</span>. The type of the application is <span class="math">\(\sigma S\)</span>.</p>
<p>If the function part <span class="math">\(e\)</span> is of some value type, the type application is taken to be equivalent to <code>$e$.apply[$T_1 , \ldots ,$ T$_n$]</code>, i.e. the application of an <code>apply</code> method defined by <span class="math">\(e\)</span>.</p>
<p>Type applications can be omitted if <a href="#local-type-inference">local type inference</a> can infer best type parameters for a polymorphic functions from the types of the actual function arguments and the expected result type.</p>
<h2 id="tuples"><a href="#tuples"><span class="header-section-number">6.9</span> Tuples</a></h2>
<pre class="grammar"><code>SimpleExpr   ::=  `(&#39; [Exprs] `)&#39;</code></pre>
<p>A tuple expression <code>($e_1 , \ldots , e_n$)</code> is an alias for the class instance creation <code>scala.Tuple$n$($e_1 , \ldots , e_n$)</code>, where <span class="math">\(n \geq 2\)</span>.<br />The empty tuple <code>()</code> is the unique value of type <code>scala.Unit</code>.</p>
<h2 id="instance-creation-expressions"><a href="#instance-creation-expressions"><span class="header-section-number">6.10</span> Instance Creation Expressions</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">SimpleExpr     ::=  `new&#39; (ClassTemplate | TemplateBody)</code></pre>
<p>A simple instance creation expression is of the form <code>new $c$</code> where <span class="math">\(c\)</span> is a <a href="#constructor-invocations">constructor invocation</a>. Let <span class="math">\(T\)</span> be the type of <span class="math">\(c\)</span>. Then <span class="math">\(T\)</span> must denote a (a type instance of) a non-abstract subclass of <code>scala.AnyRef</code>. Furthermore, the <em>concrete self type</em> of the expression must conform to the <a href="#templates">self type</a> of the class denoted by <span class="math">\(T\)</span>. The concrete self type is normally <span class="math">\(T\)</span>, except if the expression <code>new $c$</code> appears as the right hand side of a value definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> $x$: $S$ = <span class="kw">new</span> $c$</code></pre>
<p>(where the type annotation <code>: $S$</code> may be missing). In the latter case, the concrete self type of the expression is the compound type <code>$T$ with $x$.type</code>.</p>
<p>The expression is evaluated by creating a fresh object of type <span class="math">\(T\)</span> which is is initialized by evaluating <span class="math">\(c\)</span>. The type of the expression is <span class="math">\(T\)</span>.</p>
<p>A general instance creation expression is of the form <code>new $t$</code> for some <a href="#templates">class template</a> <span class="math">\(t\)</span>. Such an expression is equivalent to the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> $a$ <span class="kw">extends</span> $t$; <span class="kw">new</span> $a$ }</code></pre>
<p>where <span class="math">\(a\)</span> is a fresh name of an <em>anonymous class</em> which is inaccessible to user programs.</p>
<p>There is also a shorthand form for creating values of structural types: If <code>{$D$}</code> is a class body, then <code>new {$D$}</code> is equivalent to the general instance creation expression <code>new AnyRef{$D$}</code>.</p>
<ol start="58" type="1">
<li><p>Consider the following structural instance creation expression:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> { <span class="kw">def</span> <span class="fu">getName</span>() = <span class="st">&quot;aaron&quot;</span> }</code></pre>
<p>This is a shorthand for the general instance creation expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> AnyRef{ <span class="kw">def</span> <span class="fu">getName</span>() = <span class="st">&quot;aaron&quot;</span> }</code></pre>
<p>The latter is in turn a shorthand for the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> anon\$X <span class="kw">extends</span> AnyRef{ <span class="kw">def</span> <span class="fu">getName</span>() = <span class="st">&quot;aaron&quot;</span> }; <span class="kw">new</span> anon\$X }</code></pre>
<p>where <code>anon\$X</code> is some freshly created name.</p></li>
</ol>
<h2 id="blocks"><a href="#blocks"><span class="header-section-number">6.11</span> Blocks</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala">BlockExpr   ::=  `{&#39; Block `}&#39;
Block       ::=  {BlockStat semi} [ResultExpr]</code></pre>
<p>A block expression <code>{$s_1$; $\ldots$; $s_n$; $e\,$}</code> is constructed from a sequence of block statements <span class="math">\(s_1 , \ldots , s_n\)</span> and a final expression <span class="math">\(e\)</span>. The statement sequence may not contain two definitions or declarations that bind the same name in the same namespace. The final expression can be omitted, in which case the unit value <code>()</code> is assumed.</p>
<p>The expected type of the final expression <span class="math">\(e\)</span> is the expected type of the block. The expected type of all preceding statements is undefined.</p>
<p>The type of a block <code>$s_1$; $\ldots$; $s_n$; $e$</code> is <code>$T$ forSome {$\,Q\,$}</code>, where <span class="math">\(T\)</span> is the type of <span class="math">\(e\)</span> and <span class="math">\(Q\)</span> contains <a href="#existential-types">existential clauses</a> for every value or type name which is free in <span class="math">\(T\)</span> and which is defined locally in one of the statements <span class="math">\(s_1 , \ldots , s_n\)</span>. We say the existential clause <em>binds</em> the occurrence of the value or type name. Specifically,</p>
<ul>
<li>A locally defined type definition <code>type$\;t = T$</code> is bound by the existential clause <code>type$\;t &gt;: T &lt;: T$</code>. It is an error if <span class="math">\(t\)</span> carries type parameters.</li>
<li>A locally defined value definition~ <code>val$\;x: T = e$</code> is bound by the existential clause <code>val$\;x: T$</code>.</li>
<li>A locally defined class definition <code>class$\;c$ extends$\;t$</code> is bound by the existential clause <code>type$\;c &lt;: T$</code> where <span class="math">\(T\)</span> is the least class type or refinement type which is a proper supertype of the type <span class="math">\(c\)</span>. It is an error if <span class="math">\(c\)</span> carries type parameters.</li>
<li>A locally defined object definition <code>object$\;x\;$extends$\;t$</code> is bound by the existential clause <code>val$\;x: T$</code> where <span class="math">\(T\)</span> is the least class type or refinement type which is a proper supertype of the type <code>$x$.type</code>.</li>
</ul>
<p>Evaluation of the block entails evaluation of its statement sequence, followed by an evaluation of the final expression <span class="math">\(e\)</span>, which defines the result of the block.</p>
<ol start="59" type="1">
<li><p>Assuming a class <code>Ref[T](x: T)</code>, the block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> C <span class="kw">extends</span> B {$\ldots$} ; <span class="kw">new</span> Ref(<span class="kw">new</span> C) }</code></pre>
<p>has the type <code>Ref[_1] forSome { type _1 &lt;: B }</code>. The block</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">class</span> C <span class="kw">extends</span> B {$\ldots$} ; <span class="kw">new</span> C }</code></pre>
<p>simply has type <code>B</code>, because with the rules <a href="#simplification-rules">here</a> the existentially quantified type <code>_1 forSome { type _1 &lt;: B }</code> can be simplified to <code>B</code>.</p></li>
</ol>
<h2 id="prefix-infix-and-postfix-operations"><a href="#prefix-infix-and-postfix-operations"><span class="header-section-number">6.12</span> Prefix, Infix, and Postfix Operations</a></h2>
<pre class="grammar"><code>PostfixExpr     ::=  InfixExpr [id [nl]]
InfixExpr       ::=  PrefixExpr
                  |  InfixExpr id [nl] InfixExpr
PrefixExpr      ::=  [`-&#39; | `+&#39; | `!&#39; | `~&#39;] SimpleExpr </code></pre>
<p>Expressions can be constructed from operands and operators.</p>
<h3 id="prefix-operations"><a href="#prefix-operations"><span class="header-section-number">6.12.1</span> Prefix Operations</a></h3>
<p>A prefix operation <span class="math">\(\mathit{op};e\)</span> consists of a prefix operator <span class="math">\(\mathit{op}\)</span>, which must be one of the identifiers ‘<code>+</code>’, ‘<code>-</code>’, ‘<code>!</code>’ or ‘<code>~</code>’. The expression <span class="math">\(\mathit{op};e\)</span> is equivalent to the postfix method application <code>e.unary_$\mathit{op}$</code>.</p>
<!-- TODO: Generalize to arbitrary operators -->

<p>Prefix operators are different from normal function applications in that their operand expression need not be atomic. For instance, the input sequence <code>-sin(x)</code> is read as <code>-(sin(x))</code>, whereas the function application <code>negate sin(x)</code> would be parsed as the application of the infix operator <code>sin</code> to the operands <code>negate</code> and <code>(x)</code>.</p>
<h3 id="postfix-operations"><a href="#postfix-operations"><span class="header-section-number">6.12.2</span> Postfix Operations</a></h3>
<p>A postfix operator can be an arbitrary identifier. The postfix operation <span class="math">\(e;\mathit{op}\)</span> is interpreted as <span class="math">\(e.\mathit{op}\)</span>.</p>
<h3 id="infix-operations"><a href="#infix-operations"><span class="header-section-number">6.12.3</span> Infix Operations</a></h3>
<p>An infix operator can be an arbitrary identifier. Infix operators have precedence and associativity defined as follows:</p>
<p>The <em>precedence</em> of an infix operator is determined by the operator's first character. Characters are listed below in increasing order of precedence, with characters on the same line having the same precedence.</p>
<pre><code>$\mbox{\rm\sl(all letters)}$
|
^
&amp;
&lt; &gt;
= !
:
+ -
* / %
$\mbox{\rm\sl(all other special characters)}$</code></pre>
<p>That is, operators starting with a letter have lowest precedence, followed by operators starting with `<code>|</code>', etc.</p>
<p>There's one exception to this rule, which concerns <a href="#assignment-operators"><em>assignment operators</em></a>. The precedence of an assigment operator is the same as the one of simple assignment <code>(=)</code>. That is, it is lower than the precedence of any other operator.</p>
<p>The <em>associativity</em> of an operator is determined by the operator's last character. Operators ending in a colon `<code>:</code>' are right-associative. All other operators are left-associative.</p>
<p>Precedence and associativity of operators determine the grouping of parts of an expression as follows.</p>
<ul>
<li>If there are several infix operations in an expression, then operators with higher precedence bind more closely than operators with lower precedence.</li>
<li>If there are consecutive infix operations <span class="math">\(e_0; \mathit{op}_1; e_1; \mathit{op}_2 \ldots \mathit{op}_n; e_n\)</span> with operators <span class="math">\(\mathit{op}_1 , \ldots , \mathit{op}_n\)</span> of the same precedence, then all these operators must have the same associativity. If all operators are left-associative, the sequence is interpreted as <span class="math">\((\ldots(e_0;\mathit{op}_1;e_1);\mathit{op}_2\ldots);\mathit{op}_n;e_n\)</span>. Otherwise, if all operators are right-associative, the sequence is interpreted as <span class="math">\(e_0;\mathit{op}_1;(e_1;\mathit{op}_2;(\ldots \mathit{op}_n;e_n)\ldots)\)</span>.</li>
<li>Postfix operators always have lower precedence than infix operators. E.g. <span class="math">\(e_1;\mathit{op}_1;e_2;\mathit{op}_2\)</span> is always equivalent to <span class="math">\((e_1;\mathit{op}_1;e_2);\mathit{op}_2\)</span>.</li>
</ul>
<p>The right-hand operand of a left-associative operator may consist of several arguments enclosed in parentheses, e.g. <span class="math">\(e;\mathit{op};(e_1,\ldots,e_n)\)</span>. This expression is then interpreted as <span class="math">\(e.\mathit{op}(e_1,\ldots,e_n)\)</span>.</p>
<p>A left-associative binary operation <span class="math">\(e_1;\mathit{op};e_2\)</span> is interpreted as <span class="math">\(e_1.\mathit{op}(e_2)\)</span>. If <span class="math">\(\mathit{op}\)</span> is right-associative, the same operation is interpreted as <code>{ val $x$=$e_1$; $e_2$.$\mathit{op}$($x\,$) }</code>, where <span class="math">\(x\)</span> is a fresh name.</p>
<h3 id="assignment-operators"><a href="#assignment-operators"><span class="header-section-number">6.12.4</span> Assignment Operators</a></h3>
<p>An assignment operator is an operator symbol (syntax category <code>op</code> in <a href="#identifiers">Identifiers</a>) that ends in an equals character “<code>=</code>”, with the exception of operators for which one of the following conditions holds:</p>
<ol>
<li>the operator also starts with an equals character, or</li>
<li>the operator is one of <code>(&lt;=)</code>, <code>(&gt;=)</code>, <code>(!=)</code>.</li>
</ol>
<p>Assignment operators are treated specially in that they can be expanded to assignments if no other interpretation is valid.</p>
<p>Let's consider an assignment operator such as <code>+=</code> in an infix operation <code>$l$ += $r$</code>, where <span class="math">\(l\)</span>, <span class="math">\(r\)</span> are expressions.<br />This operation can be re-interpreted as an operation which corresponds to the assignment</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$l$ = $l$ + $r$</code></pre>
<p>except that the operation's left-hand-side <span class="math">\(l\)</span> is evaluated only once.</p>
<p>The re-interpretation occurs if the following two conditions are fulfilled.</p>
<ol>
<li>The left-hand-side <span class="math">\(l\)</span> does not have a member named <code>+=</code>, and also cannot be converted by an <a href="#implicit-conversions">implicit conversion</a> to a value with a member named <code>+=</code>.</li>
<li>The assignment <code>$l$ = $l$ + $r$</code> is type-correct. In particular this implies that <span class="math">\(l\)</span> refers to a variable or object that can be assigned to, and that is convertible to a value with a member named <code>+</code>.</li>
</ol>
<h2 id="typed-expressions"><a href="#typed-expressions"><span class="header-section-number">6.13</span> Typed Expressions</a></h2>
<pre class="grammar"><code>Expr1              ::=  PostfixExpr `:&#39; CompoundType</code></pre>
<p>The typed expression <span class="math">\(e: T\)</span> has type <span class="math">\(T\)</span>. The type of expression <span class="math">\(e\)</span> is expected to conform to <span class="math">\(T\)</span>. The result of the expression is the value of <span class="math">\(e\)</span> converted to type <span class="math">\(T\)</span>.</p>
<ol start="60" type="1">
<li><p>Here are examples of well-typed and illegally typed expressions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="dv">1</span>: Int               <span class="co">// legal, of type Int</span>
<span class="dv">1</span>: Long              <span class="co">// legal, of type Long</span>
<span class="co">// 1: string         // ***** illegal</span></code></pre></li>
</ol>
<h2 id="annotated-expressions"><a href="#annotated-expressions"><span class="header-section-number">6.14</span> Annotated Expressions</a></h2>
<pre class="grammar"><code>Expr1              ::=  PostfixExpr `:&#39; Annotation {Annotation} </code></pre>
<p>An annotated expression <code>$e$: @$a_1$ $\ldots$ @$a_n$</code> attaches <a href="#user-defined-annotations">annotations</a> <span class="math">\(a_1 , \ldots , a_n\)</span> to the expression <span class="math">\(e\)</span>.</p>
<h2 id="assignments"><a href="#assignments"><span class="header-section-number">6.15</span> Assignments</a></h2>
<pre class="grammar"><code>Expr1        ::=  [SimpleExpr `.&#39;] id `=&#39; Expr
               |  SimpleExpr1 ArgumentExprs `=&#39; Expr</code></pre>
<p>The interpretation of an assignment to a simple variable <code>$x$ = $e$</code> depends on the definition of <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> denotes a mutable variable, then the assignment changes the current value of <span class="math">\(x\)</span> to be the result of evaluating the expression <span class="math">\(e\)</span>. The type of <span class="math">\(e\)</span> is expected to conform to the type of <span class="math">\(x\)</span>. If <span class="math">\(x\)</span> is a parameterless function defined in some template, and the same template contains a setter function <code>$x$_=</code> as member, then the assignment <code>$x$ = $e$</code> is interpreted as the invocation <code>$x$_=($e\,$)</code> of that setter function. Analogously, an assignment <code>$f.x$ = $e$</code> to a parameterless function <span class="math">\(x\)</span> is interpreted as the invocation <code>$f.x$_=($e\,$)</code>.</p>
<p>An assignment <code>$f$($\mathit{args}\,$) = $e$</code> with a function application to the left of the ‘<code>=</code>’ operator is interpreted as <code>$f.$update($\mathit{args}$, $e\,$)</code>, i.e.<br />the invocation of an <code>update</code> function defined by <span class="math">\(f\)</span>.</p>
<ol start="61" type="1">
<li><p>Here are some assignment expressions and their equivalent expansions.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span> = e</code></td>
<td style="text-align: left;">x.f_=(e)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span>() = e</code></td>
<td style="text-align: left;">x.f.update(e)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span>(i) = e</code></td>
<td style="text-align: left;">x.f.update(i, e)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">x.<span class="fu">f</span>(i, j) = e</code></td>
<td style="text-align: left;">x.f.update(i, j, e)</td>
</tr>
</tbody>
</table></li>
<li><p>Here is the usual imperative code for matrix multiplication.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">matmul</span>(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="kw">val</span> zss: Array[Array[Double]] = <span class="kw">new</span> Array(xss.<span class="fu">length</span>, <span class="fu">yss</span>(<span class="dv">0</span>).<span class="fu">length</span>) 
  <span class="kw">var</span> i = <span class="dv">0</span> 
  <span class="kw">while</span> (i &lt; xss.<span class="fu">length</span>) {
    <span class="kw">var</span> j = <span class="dv">0</span> 
    <span class="kw">while</span> (j &lt; <span class="fu">yss</span>(<span class="dv">0</span>).<span class="fu">length</span>) {
      <span class="kw">var</span> acc = <span class="fl">0.0</span> 
      <span class="kw">var</span> k = <span class="dv">0</span> 
      <span class="kw">while</span> (k &lt; yss.<span class="fu">length</span>) {
        acc = acc + <span class="fu">xss</span>(i)(k) * <span class="fu">yss</span>(k)(j) 
        k += <span class="dv">1</span>
      }
      <span class="fu">zss</span>(i)(j) = acc 
      j += <span class="dv">1</span>
    }
    i += <span class="dv">1</span>
  }
  zss
}</code></pre>
<p>Desugaring the array accesses and assignments yields the following expanded version:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">matmul</span>(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="kw">val</span> zss: Array[Array[Double]] = <span class="kw">new</span> Array(xss.<span class="fu">length</span>, yss.<span class="fu">apply</span>(<span class="dv">0</span>).<span class="fu">length</span>) 
  <span class="kw">var</span> i = <span class="dv">0</span> 
  <span class="kw">while</span> (i &lt; xss.<span class="fu">length</span>) {
    <span class="kw">var</span> j = <span class="dv">0</span> 
    <span class="kw">while</span> (j &lt; yss.<span class="fu">apply</span>(<span class="dv">0</span>).<span class="fu">length</span>) {
      <span class="kw">var</span> acc = <span class="fl">0.0</span> 
      <span class="kw">var</span> k = <span class="dv">0</span> 
      <span class="kw">while</span> (k &lt; yss.<span class="fu">length</span>) {
        acc = acc + xss.<span class="fu">apply</span>(i).<span class="fu">apply</span>(k) * yss.<span class="fu">apply</span>(k).<span class="fu">apply</span>(j) 
        k += <span class="dv">1</span>
      }
      zss.<span class="fu">apply</span>(i).<span class="fu">update</span>(j, acc) 
      j += <span class="dv">1</span>
    }
    i += <span class="dv">1</span>
  }
  zss
}</code></pre></li>
</ol>
<h2 id="conditional-expressions"><a href="#conditional-expressions"><span class="header-section-number">6.16</span> Conditional Expressions</a></h2>
<pre class="grammar"><code>Expr1          ::=  `if&#39; `(&#39; Expr `)&#39; {nl} Expr [[semi] `else&#39; Expr]</code></pre>
<p>The conditional expression <code>if ($e_1$) $e_2$ else $e_3$</code> chooses one of the values of <span class="math">\(e_2\)</span> and <span class="math">\(e_3\)</span>, depending on the value of <span class="math">\(e_1\)</span>. The condition <span class="math">\(e_1\)</span> is expected to conform to type <code>Boolean</code>. The then-part <span class="math">\(e_2\)</span> and the else-part <span class="math">\(e_3\)</span> are both expected to conform to the expected type of the conditional expression. The type of the conditional expression is the <a href="#weak-conformance">weak least upper bound</a> of the types of <span class="math">\(e_2\)</span> and <span class="math">\(e_3\)</span>. A semicolon preceding the <code>else</code> symbol of a conditional expression is ignored.</p>
<p>The conditional expression is evaluated by evaluating first <span class="math">\(e_1\)</span>. If this evaluates to <code>true</code>, the result of evaluating <span class="math">\(e_2\)</span> is returned, otherwise the result of evaluating <span class="math">\(e_3\)</span> is returned.</p>
<p>A short form of the conditional expression eliminates the else-part. The conditional expression <code>if ($e_1$) $e_2$</code> is evaluated as if it was <code>if ($e_1$) $e_2$ else ()</code>.</p>
<h2 id="while-loop-expressions"><a href="#while-loop-expressions"><span class="header-section-number">6.17</span> While Loop Expressions</a></h2>
<pre class="grammar"><code>Expr1          ::=  `while&#39; `(&#39; Expr &#39;)&#39; {nl} Expr</code></pre>
<p>The while loop expression <code>while ($e_1$) $e_2$</code> is typed and evaluated as if it was an application of <code>whileLoop ($e_1$) ($e_2$)</code> where the hypothetical function <code>whileLoop</code> is defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">whileLoop</span>(cond: =&gt; Boolean)(body: =&gt; Unit): Unit  =
  <span class="kw">if</span> (cond) { body ; <span class="fu">whileLoop</span>(cond)(body) } <span class="kw">else</span> {}</code></pre>
<h2 id="do-loop-expressions"><a href="#do-loop-expressions"><span class="header-section-number">6.18</span> Do Loop Expressions</a></h2>
<pre class="grammar"><code>Expr1          ::=  `do&#39; Expr [semi] `while&#39; `(&#39; Expr &#39;)&#39;</code></pre>
<p>The do loop expression <code>do $e_1$ while ($e_2$)</code> is typed and evaluated as if it was the expression <code>($e_1$ ; while ($e_2$) $e_1$)</code>. A semicolon preceding the <code>while</code> symbol of a do loop expression is ignored.</p>
<h2 id="for-comprehensions-and-for-loops"><a href="#for-comprehensions-and-for-loops"><span class="header-section-number">6.19</span> For Comprehensions and For Loops</a></h2>
<pre class="grammar"><code>Expr1          ::=  `for&#39; (`(&#39; Enumerators `)&#39; | `{&#39; Enumerators `}&#39;) 
                       {nl} [`yield&#39;] Expr
Enumerators    ::=  Generator {semi Enumerator}
Enumerator     ::=  Generator 
                 |  Guard
                 |  `val&#39; Pattern1 `=&#39; Expr
Generator      ::=  Pattern1 `&lt;-&#39; Expr [Guard]
Guard          ::=  `if&#39; PostfixExpr</code></pre>
<p>A for loop <code>for ($\mathit{enums}\,$) $e$</code> executes expression <span class="math">\(e\)</span> for each binding generated by the enumerators <span class="math">\(\mathit{enums}\)</span>. A for comprehension <code>for ($\mathit{enums}\,$) yield $e$</code> evaluates expression <span class="math">\(e\)</span> for each binding generated by the enumerators <span class="math">\(\mathit{enums}\)</span> and collects the results. An enumerator sequence always starts with a generator; this can be followed by further generators, value definitions, or guards. A <em>generator</em> <code>$p$ &lt;- $e$</code> produces bindings from an expression <span class="math">\(e\)</span> which is matched in some way against pattern <span class="math">\(p\)</span>. A <em>value definition</em> <code>$p$ = $e$</code> binds the value name <span class="math">\(p\)</span> (or several names in a pattern <span class="math">\(p\)</span>) to the result of evaluating the expression <span class="math">\(e\)</span>. A <em>guard</em> <code>if $e$</code> contains a boolean expression which restricts enumerated bindings. The precise meaning of generators and guards is defined by translation to invocations of four methods: <code>map</code>, <code>withFilter</code>, <code>flatMap</code>, and <code>foreach</code>. These methods can be implemented in different ways for different carrier types.</p>
<p>The translation scheme is as follows. In a first step, every generator <code>$p$ &lt;- $e$</code>, where <span class="math">\(p\)</span> is not <a href="#patterns">irrefutable</a> for the type of <span class="math">\(e\)</span> is replaced by</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$p$ &lt;- $e$.<span class="fu">withFilter</span> { <span class="kw">case</span> $p$ =&gt; <span class="kw">true</span>; <span class="kw">case</span> _ =&gt; <span class="kw">false</span> }</code></pre>
<p>Then, the following rules are applied repeatedly until all comprehensions have been eliminated.</p>
<ul>
<li>A for comprehension <code>for ($p$ &lt;- $e\,$) yield $e'$</code> is translated to <code>$e$.map { case $p$ =&gt; $e'$ }</code>.</li>
<li>A for loop <code>for ($p$ &lt;- $e\,$) $e'$</code> is translated to <code>$e$.foreach { case $p$ =&gt; $e'$ }</code>.</li>
<li><p>A for comprehension</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> ($p$ &lt;- $e$; $p&#39;$ &lt;- $e&#39;; \ldots$) <span class="kw">yield</span> $e&#39;&#39;$</code></pre>
<p>where <code>$\ldots$</code> is a (possibly empty) sequence of generators, definitions, or guards, is translated to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">flatMap</span> { <span class="kw">case</span> $p$ =&gt; <span class="kw">for</span> ($p&#39;$ &lt;- $e&#39;; \ldots$) <span class="kw">yield</span> $e&#39;&#39;$ }</code></pre></li>
<li><p>A for loop</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> ($p$ &lt;- $e$; $p&#39;$ &lt;- $e&#39;; \ldots$) $e&#39;&#39;$</code></pre>
<p>where <code>$\ldots$</code> is a (possibly empty) sequence of generators, definitions, or guards, is translated to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">foreach</span> { <span class="kw">case</span> $p$ =&gt; <span class="kw">for</span> ($p&#39;$ &lt;- $e&#39;; \ldots$) $e&#39;&#39;$ }</code></pre></li>
<li><p>A generator <code>$p$ &lt;- $e$</code> followed by a guard <code>if $g$</code> is translated to a single generator <code>$p$ &lt;- $e$.withFilter(($x_1 , \ldots , x_n$) =&gt; $g\,$)</code> where <span class="math">\(x_1 , \ldots , x_n\)</span> are the free variables of <span class="math">\(p\)</span>.</p></li>
<li><p>A generator <code>$p$ &lt;- $e$</code> followed by a value definition <code>$p'$ = $e'$</code> is translated to the following generator of pairs of values, where <span class="math">\(x\)</span> and <span class="math">\(x&#39;\)</span> are fresh names:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">($p$, $p&#39;$) &lt;- <span class="kw">for</span> ($x @ p$ &lt;- $e$) <span class="kw">yield</span> { <span class="kw">val</span> $x&#39; @ p&#39;$ = $e&#39;$; ($x$, $x&#39;$) }</code></pre></li>
</ul>
<ol start="63" type="1">
<li><p>The following code produces all pairs of numbers between <span class="math">\(1\)</span> and <span class="math">\(n-1\)</span> whose sums are prime.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span>  { i &lt;- <span class="dv">1</span> until n 
       j &lt;- <span class="dv">1</span> until i 
       <span class="kw">if</span> <span class="fu">isPrime</span>(i+j)
} <span class="kw">yield</span> (i, j)</code></pre>
<p>The for comprehension is translated to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(<span class="dv">1</span> until n)
  .<span class="fu">flatMap</span> {
     <span class="kw">case</span> i =&gt; (<span class="dv">1</span> until i)
       .<span class="fu">withFilter</span> { j =&gt; <span class="fu">isPrime</span>(i+j) }
       .<span class="fu">map</span> { <span class="kw">case</span> j =&gt; (i, j) } }</code></pre></li>
<li><p>For comprehensions can be used to express vector and matrix algorithms concisely. For instance, here is a function to compute the transpose of a given matrix:</p>
<!-- see test/files/run/t0421.scala -->

<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> transpose[A](xss: Array[Array[A]]) = {
  <span class="kw">for</span> (i &lt;- Array.<span class="fu">range</span>(<span class="dv">0</span>, <span class="fu">xss</span>(<span class="dv">0</span>).<span class="fu">length</span>)) <span class="kw">yield</span>
    <span class="kw">for</span> (xs &lt;- xss) <span class="kw">yield</span> <span class="fu">xs</span>(i)
}</code></pre>
<p>Here is a function to compute the scalar product of two vectors:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">scalprod</span>(xs: Array[Double], ys: Array[Double]) = {
  <span class="kw">var</span> acc = <span class="fl">0.0</span> 
  <span class="kw">for</span> ((x, y) &lt;- xs zip ys) acc = acc + x * y  
  acc
}</code></pre>
<p>Finally, here is a function to compute the product of two matrices. Compare with the imperative version of .</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">matmul</span>(xss: Array[Array[Double]], yss: Array[Array[Double]]) = {
  <span class="kw">val</span> ysst = <span class="fu">transpose</span>(yss) 
  <span class="kw">for</span> (xs &lt;- xss) <span class="kw">yield</span>
    <span class="kw">for</span> (yst &lt;- ysst) <span class="kw">yield</span> 
      <span class="fu">scalprod</span>(xs, yst)
}</code></pre>
<p>The code above makes use of the fact that <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, and <code>foreach</code> are defined for instances of class <code>scala.Array</code>.</p></li>
</ol>
<h2 id="return-expressions"><a href="#return-expressions"><span class="header-section-number">6.20</span> Return Expressions</a></h2>
<pre class="grammar"><code>Expr1      ::=  `return&#39; [Expr]</code></pre>
<p>A return expression <code>return $e$</code> must occur inside the body of some enclosing named method or function. The innermost enclosing named method or function in a source program, <span class="math">\(f\)</span>, must have an explicitly declared result type, and the type of <span class="math">\(e\)</span> must conform to it.<br />The return expression evaluates the expression <span class="math">\(e\)</span> and returns its value as the result of <span class="math">\(f\)</span>. The evaluation of any statements or expressions following the return expression is omitted. The type of a return expression is <code>scala.Nothing</code>.</p>
<p>The expression <span class="math">\(e\)</span> may be omitted. The return expression <code>return</code> is type-checked and evaluated as if it was <code>return ()</code>.</p>
<p>An <code>apply</code> method which is generated by the compiler as an expansion of an anonymous function does not count as a named function in the source program, and therefore is never the target of a return expression.</p>
<p>Returning from a nested anonymous function is implemented by throwing and catching a <code>scala.runtime.NonLocalReturnException</code>. Any exception catches between the point of return and the enclosing methods might see the exception. A key comparison makes sure that these exceptions are only caught by the method instance which is terminated by the return.</p>
<p>If the return expression is itself part of an anonymous function, it is possible that the enclosing instance of <span class="math">\(f\)</span> has already returned before the return expression is executed. In that case, the thrown <code>scala.runtime.NonLocalReturnException</code> will not be caught, and will propagate up the call stack.</p>
<h2 id="throw-expressions"><a href="#throw-expressions"><span class="header-section-number">6.21</span> Throw Expressions</a></h2>
<pre class="grammar"><code>Expr1      ::=  `throw&#39; Expr</code></pre>
<p>A throw expression <code>throw $e$</code> evaluates the expression <span class="math">\(e\)</span>. The type of this expression must conform to <code>Throwable</code>. If <span class="math">\(e\)</span> evaluates to an exception reference, evaluation is aborted with the thrown exception. If <span class="math">\(e\)</span> evaluates to <code>null</code>, evaluation is instead aborted with a <code>NullPointerException</code>. If there is an active <a href="#try-expressions"><code>try</code> expression</a> which handles the thrown exception, evaluation resumes with the handler; otherwise the thread executing the <code>throw</code> is aborted. The type of a throw expression is <code>scala.Nothing</code>.</p>
<h2 id="try-expressions"><a href="#try-expressions"><span class="header-section-number">6.22</span> Try Expressions</a></h2>
<pre class="grammar"><code>Expr1 ::=  `try&#39; `{&#39; Block `}&#39; [`catch&#39; `{&#39; CaseClauses `}&#39;] 
           [`finally&#39; Expr]</code></pre>
<p>A try expression is of the form <code>try { $b$ } catch $h$</code> where the handler <span class="math">\(h\)</span> is a <a href="#pattern-matching-anonymous-functions">pattern matching anonymous function</a></p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ }</code></pre>
<p>This expression is evaluated by evaluating the block <span class="math">\(b\)</span>. If evaluation of <span class="math">\(b\)</span> does not cause an exception to be thrown, the result of <span class="math">\(b\)</span> is returned. Otherwise the handler <span class="math">\(h\)</span> is applied to the thrown exception.<br />If the handler contains a case matching the thrown exception, the first such case is invoked. If the handler contains no case matching the thrown exception, the exception is re-thrown.</p>
<p>Let <span class="math">\(\mathit{pt}\)</span> be the expected type of the try expression. The block <span class="math">\(b\)</span> is expected to conform to <span class="math">\(\mathit{pt}\)</span>. The handler <span class="math">\(h\)</span> is expected conform to type <code>scala.PartialFunction[scala.Throwable, $\mathit{pt}\,$]</code>. The type of the try expression is the <a href="#weak-conformance">weak least upper bound</a> of the type of <span class="math">\(b\)</span> and the result type of <span class="math">\(h\)</span>.</p>
<p>A try expression <code>try { $b$ } finally $e$</code> evaluates the block <span class="math">\(b\)</span>. If evaluation of <span class="math">\(b\)</span> does not cause an exception to be thrown, the expression <span class="math">\(e\)</span> is evaluated. If an exception is thrown during evaluation of <span class="math">\(e\)</span>, the evaluation of the try expression is aborted with the thrown exception. If no exception is thrown during evaluation of <span class="math">\(e\)</span>, the result of <span class="math">\(b\)</span> is returned as the result of the try expression.</p>
<p>If an exception is thrown during evaluation of <span class="math">\(b\)</span>, the finally block <span class="math">\(e\)</span> is also evaluated. If another exception <span class="math">\(e\)</span> is thrown during evaluation of <span class="math">\(e\)</span>, evaluation of the try expression is aborted with the thrown exception. If no exception is thrown during evaluation of <span class="math">\(e\)</span>, the original exception thrown in <span class="math">\(b\)</span> is re-thrown once evaluation of <span class="math">\(e\)</span> has completed. The block <span class="math">\(b\)</span> is expected to conform to the expected type of the try expression. The finally expression <span class="math">\(e\)</span> is expected to conform to type <code>Unit</code>.</p>
<p>A try expression <code>try { $b$ } catch $e_1$ finally $e_2$</code> is a shorthand for <code>try { try { $b$ } catch $e_1$ } finally $e_2$</code>.</p>
<h2 id="anonymous-functions"><a href="#anonymous-functions"><span class="header-section-number">6.23</span> Anonymous Functions</a></h2>
<pre class="grammar"><code>Expr            ::=  (Bindings | [`implicit&#39;] id | `_&#39;) `=&gt;&#39; Expr
ResultExpr      ::=  (Bindings | ([`implicit&#39;] id | `_&#39;) `:&#39; CompoundType) `=&gt;&#39; Block
Bindings        ::=  `(&#39; Binding {`,&#39; Binding} `)&#39;
Binding         ::=  (id | `_&#39;) [`:&#39; Type]</code></pre>
<p>The anonymous function <code>($x_1$: $T_1 , \ldots , x_n$: $T_n$) =&gt; e</code> maps parameters <span class="math">\(x_i\)</span> of types <span class="math">\(T_i\)</span> to a result given by expression <span class="math">\(e\)</span>. The scope of each formal parameter <span class="math">\(x_i\)</span> is <span class="math">\(e\)</span>. Formal parameters must have pairwise distinct names.</p>
<p>If the expected type of the anonymous function is of the form <code>scala.Function$n$[$S_1 , \ldots , S_n$, $R\,$]</code>, the expected type of <span class="math">\(e\)</span> is <span class="math">\(R\)</span> and the type <span class="math">\(T_i\)</span> of any of the parameters <span class="math">\(x_i\)</span> can be omitted, in which case<code>$T_i$ = $S_i$</code> is assumed. If the expected type of the anonymous function is some other type, all formal parameter types must be explicitly given, and the expected type of <span class="math">\(e\)</span> is undefined. The type of the anonymous function is<code>scala.Function$n$[$S_1 , \ldots , S_n$, $T\,$]</code>, where <span class="math">\(T\)</span> is the <a href="#expression-typing">packed type</a> of <span class="math">\(e\)</span>. <span class="math">\(T\)</span> must be equivalent to a type which does not refer to any of the formal parameters <span class="math">\(x_i\)</span>.</p>
<p>The anonymous function is evaluated as the instance creation expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> scala.<span class="fu">Function</span>$n$[$T_1 , \ldots , T_n$, $T$] {
  <span class="kw">def</span> <span class="fu">apply</span>($x_1$: $T_1 , \ldots , x_n$: $T_n$): $T$ = $e$
}</code></pre>
<p>In the case of a single untyped formal parameter, <code>($x\,$) =&gt; $e$</code> can be abbreviated to <code>$x$ =&gt; $e$</code>. If an anonymous function <code>($x$: $T\,$) =&gt; $e$</code> with a single typed parameter appears as the result expression of a block, it can be abbreviated to <code>$x$: $T$ =&gt; e</code>.</p>
<p>A formal parameter may also be a wildcard represented by an underscore <code>_</code>. In that case, a fresh name for the parameter is chosen arbitrarily.</p>
<p>A named parameter of an anonymous function may be optionally preceded by an <code>implicit</code> modifier. In that case the parameter is labeled <a href="#implicit-parameters-and-views"><code>implicit</code></a>; however the parameter section itself does not count as an implicit parameter section in the sense defined <a href="#implicit-parameters">here</a>. Hence, arguments to anonymous functions always have to be given explicitly.</p>
<ol start="65" type="1">
<li><p>Examples of anonymous functions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">x =&gt; x                             <span class="co">// The identity function</span>

f =&gt; g =&gt; x =&gt; <span class="fu">f</span>(<span class="fu">g</span>(x))             <span class="co">// Curried function composition</span>

(x: Int,y: Int) =&gt; x + y           <span class="co">// A summation function</span>

() =&gt; { count += <span class="dv">1</span>; count }        <span class="co">// The function which takes an</span>
                                   <span class="co">// empty parameter list $()$, </span>
                                   <span class="co">// increments a non-local variable </span>
                                   <span class="co">// `count&#39; and returns the new value.</span>

_ =&gt; <span class="dv">5</span>                             <span class="co">// The function that ignores its argument</span>
                                   <span class="co">// and always returns 5.</span></code></pre></li>
</ol>
<h3 id="placeholder-syntax-for-anonymous-functions"><a href="#placeholder-syntax-for-anonymous-functions"><span class="header-section-number">6.23.1</span> Placeholder Syntax for Anonymous Functions</a></h3>
<pre class="grammar"><code>SimpleExpr1  ::=  `_&#39;</code></pre>
<p>An expression (of syntactic category <code>Expr</code>) may contain embedded underscore symbols <code>_</code> at places where identifiers are legal. Such an expression represents an anonymous function where subsequent occurrences of underscores denote successive parameters.</p>
<p>Define an <em>underscore section</em> to be an expression of the form <code>_:$T$</code> where <span class="math">\(T\)</span> is a type, or else of the form <code>_</code>, provided the underscore does not appear as the expression part of a type ascription <code>_:$T$</code>.</p>
<p>An expression <span class="math">\(e\)</span> of syntactic category <code>Expr</code> <em>binds</em> an underscore section <span class="math">\(u\)</span>, if the following two conditions hold: (1) <span class="math">\(e\)</span> properly contains <span class="math">\(u\)</span>, and (2) there is no other expression of syntactic category <code>Expr</code> which is properly contained in <span class="math">\(e\)</span> and which itself properly contains <span class="math">\(u\)</span>.</p>
<p>If an expression <span class="math">\(e\)</span> binds underscore sections <span class="math">\(u_1 , \ldots , u_n\)</span>, in this order, it is equivalent to the anonymous function <code>($u'_1$, ... $u'_n$) =&gt; $e'$</code> where each <span class="math">\(u_i&#39;\)</span> results from <span class="math">\(u_i\)</span> by replacing the underscore with a fresh identifier and <span class="math">\(e&#39;\)</span> results from <span class="math">\(e\)</span> by replacing each underscore section <span class="math">\(u_i\)</span> by <span class="math">\(u_i&#39;\)</span>.</p>
<ol start="66" type="1">
<li><p>The anonymous functions in the left column use placeholder syntax. Each of these is equivalent to the anonymous function on its right.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">_ + <span class="dv">1</span></code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; x + <span class="dv">1</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">_ * _</code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x1, x2) =&gt; x1 * x2</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">(_: Int) * <span class="dv">2</span></code></td>
<td style="text-align: left;"><code class="sourceCode scala">(x: Int) =&gt; (x: Int) * <span class="dv">2</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala"><span class="kw">if</span> (_) x <span class="kw">else</span> y</code></td>
<td style="text-align: left;"><code class="sourceCode scala">z =&gt; <span class="kw">if</span> (z) x <span class="kw">else</span> y</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode scala">_.<span class="fu">map</span>(f)</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; x.<span class="fu">map</span>(f)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode scala">_.<span class="fu">map</span>(_ + <span class="dv">1</span>)</code></td>
<td style="text-align: left;"><code class="sourceCode scala">x =&gt; x.<span class="fu">map</span>(y =&gt; y + <span class="dv">1</span>)</code></td>
</tr>
</tbody>
</table></li>
</ol>
<h2 id="constant-expressions"><a href="#constant-expressions"><span class="header-section-number">6.24</span> Constant Expressions</a></h2>
<p>Constant expressions are expressions that the Scala compiler can evaluate to a constant. The definition of ``constant expression'' depends on the platform, but they include at least the expressions of the following forms:</p>
<ul>
<li>A literal of a value class, such as an integer</li>
<li>A string literal</li>
<li>A class constructed with <a href="#the-predef-object"><code>Predef.classOf</code></a></li>
<li>An element of an enumeration from the underlying platform</li>
<li>A literal array, of the form <code>Array$(c_1 , \ldots , c_n)$</code>, where all of the <span class="math">\(c_i\)</span>'s are themselves constant expressions</li>
<li>An identifier defined by a <a href="#value-declarations-and-definitions">constant value definition</a>.</li>
</ul>
<h2 id="statements"><a href="#statements"><span class="header-section-number">6.25</span> Statements</a></h2>
<pre class="grammar"><code>BlockStat    ::=  Import
               |  {Annotation} [`implicit&#39;] Def
               |  {Annotation} {LocalModifier} TmplDef
               |  Expr1
               | 
TemplateStat ::=  Import
               |  {Annotation} {Modifier} Def
               |  {Annotation} {Modifier} Dcl
               |  Expr
               | </code></pre>
<p>Statements occur as parts of blocks and templates. A statement can be an import, a definition or an expression, or it can be empty. Statements used in the template of a class definition can also be declarations. An expression that is used as a statement can have an arbitrary value type. An expression statement <span class="math">\(e\)</span> is evaluated by evaluating <span class="math">\(e\)</span> and discarding the result of the evaluation.</p>
<!-- Generalize to implicit coercion? -->

<p>Block statements may be definitions which bind local names in the block. The only modifier allowed in all block-local definitions is <code>implicit</code>. When prefixing a class or object definition, modifiers <code>abstract</code>, <code>final</code>, and <code>sealed</code> are also permitted.</p>
<p>Evaluation of a statement sequence entails evaluation of the statements in the order they are written.</p>
<h2 id="implicit-conversions"><a href="#implicit-conversions"><span class="header-section-number">6.26</span> Implicit Conversions</a></h2>
<p>Implicit conversions can be applied to expressions whose type does not match their expected type, to qualifiers in selections, and to unapplied methods. The available implicit conversions are given in the next two sub-sections.</p>
<p>We say, a type <span class="math">\(T\)</span> is <em>compatible</em> to a type <span class="math">\(U\)</span> if <span class="math">\(T\)</span> conforms to <span class="math">\(U\)</span> after applying <a href="#eta-expansion">eta-expansion</a> and <a href="#views">view applications</a>.</p>
<h3 id="value-conversions"><a href="#value-conversions"><span class="header-section-number">6.26.1</span> Value Conversions</a></h3>
<p>The following five implicit conversions can be applied to an expression <span class="math">\(e\)</span> which has some value type <span class="math">\(T\)</span> and which is type-checked with some expected type <span class="math">\(\mathit{pt}\)</span>.</p>
<p><em>Overloading Resolution</em><br />If an expression denotes several possible members of a class, <a href="#overloading-resolution">overloading resolution</a> is applied to pick a unique member.</p>
<p><em>Type Instantiation</em><br />An expression <span class="math">\(e\)</span> of polymorphic type</p>
<pre class="sourceCode scala"><code class="sourceCode scala">[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code></pre>
<p>which does not appear as the function part of a type application is converted to a type instance of <span class="math">\(T\)</span> by determining with <a href="#local-type-inference">local type inference</a> instance types <code>$T_1 , \ldots , T_n$</code> for the type variables <code>$a_1 , \ldots , a_n$</code> and implicitly embedding <span class="math">\(e\)</span> in the <a href="#type-applications">type application</a> <code>$e$[$T_1 , \ldots , T_n$]</code>.</p>
<p><em>Numeric Widening</em><br />If <span class="math">\(e\)</span> has a primitive number type which <a href="#weak-conformance">weakly conforms</a> to the expected type, it is widened to the expected type using one of the numeric conversion methods <code>toShort</code>, <code>toChar</code>, <code>toInt</code>, <code>toLong</code>, <code>toFloat</code>, <code>toDouble</code> defined <a href="#numeric-value-types">here</a>.</p>
<p><em>Numeric Literal Narrowing</em><br />If the expected type is <code>Byte</code>, <code>Short</code> or <code>Char</code>, and the expression <span class="math">\(e\)</span> is an integer literal fitting in the range of that type, it is converted to the same literal in that type.</p>
<p><em>Value Discarding</em><br />If <span class="math">\(e\)</span> has some value type and the expected type is <code>Unit</code>, <span class="math">\(e\)</span> is converted to the expected type by embedding it in the term <code>{ $e$; () }</code>.</p>
<p><em>View Application</em><br />If none of the previous conversions applies, and <span class="math">\(e\)</span>'s type does not conform to the expected type <span class="math">\(\mathit{pt}\)</span>, it is attempted to convert <span class="math">\(e\)</span> to the expected type with a <a href="#views">view</a>.</p>
<p><em>Dynamic Member Selection</em><br />If none of the previous conversions applies, and <span class="math">\(e\)</span> is a prefix of a selection <span class="math">\(e.x\)</span>, and <span class="math">\(e\)</span>'s type conforms to class <code>scala.Dynamic</code>, then the selection is rewritten according to the rules for <a href="#dynamic-member-selection">dynamic member selection</a>.</p>
<h3 id="method-conversions"><a href="#method-conversions"><span class="header-section-number">6.26.2</span> Method Conversions</a></h3>
<p>The following four implicit conversions can be applied to methods which are not applied to some argument list.</p>
<p><em>Evaluation</em><br />A parameterless method <span class="math">\(m\)</span> of type <code>=&gt; $T$</code> is always converted to type <span class="math">\(T\)</span> by evaluating the expression to which <span class="math">\(m\)</span> is bound.</p>
<p><em>Implicit Application</em><br /> If the method takes only implicit parameters, implicit arguments are passed following the rules <a href="#implicit-parameters">here</a>.</p>
<p><em>Eta Expansion</em><br /> Otherwise, if the method is not a constructor, and the expected type <span class="math">\(\mathit{pt}\)</span> is a function type <span class="math">\((\mathit{Ts}&#39;) \Rightarrow T&#39;\)</span>, <a href="#eta-expansion">eta-expansion</a> is performed on the expression <span class="math">\(e\)</span>.</p>
<p><em>Empty Application</em><br /> Otherwise, if <span class="math">\(e\)</span> has method type <span class="math">\(()T\)</span>, it is implicitly applied to the empty argument list, yielding <span class="math">\(e()\)</span>.</p>
<h3 id="overloading-resolution"><a href="#overloading-resolution"><span class="header-section-number">6.26.3</span> Overloading Resolution</a></h3>
<p>If an identifier or selection <span class="math">\(e\)</span> references several members of a class, the context of the reference is used to identify a unique member. The way this is done depends on whether or not <span class="math">\(e\)</span> is used as a function. Let <span class="math">\(\mathscr{A}\)</span> be the set of members referenced by <span class="math">\(e\)</span>.</p>
<p>Assume first that <span class="math">\(e\)</span> appears as a function in an application, as in <code>$e$($e_1 , \ldots , e_m$)</code>.</p>
<p>One first determines the set of functions that is potentially applicable based on the <em>shape</em> of the arguments.</p>
<p>The shape of an argument expression <span class="math">\(e\)</span>, written <span class="math">\(\mathit{shape}(e)\)</span>, is a type that is defined as follows:</p>
<ul>
<li>For a function expression <code>($p_1$: $T_1 , \ldots , p_n$: $T_n$) =&gt; $b$</code>: <code>(Any $, \ldots ,$ Any) =&gt; $\mathit{shape}(b)$</code>, where <code>Any</code> occurs <span class="math">\(n\)</span> times in the argument type.</li>
<li>For a named argument <code>$n$ = $e$</code>: <span class="math">\(\mathit{shape}(e)\)</span>.</li>
<li>For all other expressions: <code>Nothing</code>.</li>
</ul>
<p>Let <span class="math">\(\mathscr{B}\)</span> be the set of alternatives in <span class="math">\(\mathscr{A}\)</span> that are <a href="#function-applications"><em>applicable</em></a> to expressions <span class="math">\((e_1 , \ldots , e_n)\)</span> of types <span class="math">\((\mathit{shape}(e_1) , \ldots , \mathit{shape}(e_n))\)</span>. If there is precisely one alternative in <span class="math">\(\mathscr{B}\)</span>, that alternative is chosen.</p>
<p>Otherwise, let <span class="math">\(S_1 , \ldots , S_m\)</span> be the vector of types obtained by typing each argument with an undefined expected type. For every member <span class="math">\(m\)</span> in <span class="math">\(\mathscr{B}\)</span> one determines whether it is applicable to expressions (<span class="math">\(e_1 , \ldots , e_m\)</span>) of types <span class="math">\(S_1 , \ldots , S_m\)</span>. It is an error if none of the members in <span class="math">\(\mathscr{B}\)</span> is applicable. If there is one single applicable alternative, that alternative is chosen. Otherwise, let <span class="math">\(\mathscr{CC}\)</span> be the set of applicable alternatives which don't employ any default argument in the application to <span class="math">\(e_1 , \ldots , e_m\)</span>. It is again an error if <span class="math">\(\mathscr{CC}\)</span> is empty. Otherwise, one chooses the <em>most specific</em> alternative among the alternatives in <span class="math">\(\mathscr{CC}\)</span>, according to the following definition of being <code>as specific as'', and</code>more specific than'':</p>
<ul>
<li>A parameterized method <span class="math">\(m\)</span> of type <code>($p_1:T_1, \ldots , p_n:T_n$)$U$</code> is <em>as specific as</em> some other member <span class="math">\(m&#39;\)</span> of type <span class="math">\(S\)</span> if <span class="math">\(m&#39;\)</span> is applicable to arguments <code>($p_1 , \ldots , p_n\,$)</code> of types <span class="math">\(T_1 , \ldots , T_n\)</span>.</li>
<li>A polymorphic method of type <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code> is as specific as some other member of type <span class="math">\(S\)</span> if <span class="math">\(T\)</span> is as specific as <span class="math">\(S\)</span> under the assumption that for <span class="math">\(i = 1 , \ldots , n\)</span> each <span class="math">\(a_i\)</span> is an abstract type name bounded from below by <span class="math">\(L_i\)</span> and from above by <span class="math">\(U_i\)</span>.</li>
<li>A member of any other type is always as specific as a parameterized method or a polymorphic method.</li>
<li>Given two members of types <span class="math">\(T\)</span> and <span class="math">\(U\)</span> which are neither parameterized nor polymorphic method types, the member of type <span class="math">\(T\)</span> is as specific as the member of type <span class="math">\(U\)</span> if the existential dual of <span class="math">\(T\)</span> conforms to the existential dual of <span class="math">\(U\)</span>. Here, the existential dual of a polymorphic type <code>[$a_1$ &gt;: $L_1$ &lt;: $U_1 , \ldots , a_n$ &gt;: $L_n$ &lt;: $U_n$]$T$</code> is <code>$T$ forSome { type $a_1$ &gt;: $L_1$ &lt;: $U_1$ $, \ldots ,$ type $a_n$ &gt;: $L_n$ &lt;: $U_n$}</code>. The existential dual of every other type is the type itself.</li>
</ul>
<p>The <em>relative weight</em> of an alternative <span class="math">\(A\)</span> over an alternative <span class="math">\(B\)</span> is a number from 0 to 2, defined as the sum of</p>
<ul>
<li>1 if <span class="math">\(A\)</span> is as specific as <span class="math">\(B\)</span>, 0 otherwise, and</li>
<li>1 if <span class="math">\(A\)</span> is defined in a class or object which is derived from the class or object defining <span class="math">\(B\)</span>, 0 otherwise.</li>
</ul>
<p>A class or object <span class="math">\(C\)</span> is <em>derived</em> from a class or object <span class="math">\(D\)</span> if one of the following holds:</p>
<ul>
<li><span class="math">\(C\)</span> is a subclass of <span class="math">\(D\)</span>, or</li>
<li><span class="math">\(C\)</span> is a companion object of a class derived from <span class="math">\(D\)</span>, or</li>
<li><span class="math">\(D\)</span> is a companion object of a class from which <span class="math">\(C\)</span> is derived.</li>
</ul>
<p>An alternative <span class="math">\(A\)</span> is <em>more specific</em> than an alternative <span class="math">\(B\)</span> if the relative weight of <span class="math">\(A\)</span> over <span class="math">\(B\)</span> is greater than the relative weight of <span class="math">\(B\)</span> over <span class="math">\(A\)</span>.</p>
<p>It is an error if there is no alternative in <span class="math">\(\mathscr{CC}\)</span> which is more specific than all other alternatives in <span class="math">\(\mathscr{CC}\)</span>.</p>
<p>Assume next that <span class="math">\(e\)</span> appears as a function in a type application, as in <code>$e$[$\mathit{targs}\,$]</code>. Then all alternatives in <span class="math">\(\mathscr{A}\)</span> which take the same number of type parameters as there are type arguments in <span class="math">\(\mathit{targs}\)</span> are chosen. It is an error if no such alternative exists. If there are several such alternatives, overloading resolution is applied again to the whole expression <code>$e$[$\mathit{targs}\,$]</code>.</p>
<p>Assume finally that <span class="math">\(e\)</span> does not appear as a function in either an application or a type application. If an expected type is given, let <span class="math">\(\mathscr{B}\)</span> be the set of those alternatives in <span class="math">\(\mathscr{A}\)</span> which are <a href="#implicit-conversions">compatible</a> to it. Otherwise, let <span class="math">\(\mathscr{B}\)</span> be the same as <span class="math">\(\mathscr{A}\)</span>. We choose in this case the most specific alternative among all alternatives in <span class="math">\(\mathscr{B}\)</span>. It is an error if there is no alternative in <span class="math">\(\mathscr{B}\)</span> which is more specific than all other alternatives in <span class="math">\(\mathscr{B}\)</span>.</p>
<ol start="67" type="1">
<li><p>Consider the following definitions:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> A <span class="kw">extends</span> B {}
<span class="kw">def</span> <span class="fu">f</span>(x: B, y: B) = $\ldots$
<span class="kw">def</span> <span class="fu">f</span>(x: A, y: B) = $\ldots$
<span class="kw">val</span> a: A 
<span class="kw">val</span> b: B</code></pre>
<p>Then the application <code>f(b, b)</code> refers to the first definition of <span class="math">\(f\)</span> whereas the application <code>f(a, a)</code> refers to the second. Assume now we add a third overloaded definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: B, y: A) = $\ldots$</code></pre>
<p>Then the application <code>f(a, a)</code> is rejected for being ambiguous, since no most specific applicable signature exists.</p></li>
</ol>
<h3 id="local-type-inference"><a href="#local-type-inference"><span class="header-section-number">6.26.4</span> Local Type Inference</a></h3>
<p>Local type inference infers type arguments to be passed to expressions of polymorphic type. Say <span class="math">\(e\)</span> is of type [<span class="math">\(a_1\)</span> &gt;: <span class="math">\(L_1\)</span> &lt;: <span class="math">\(U_1 , \ldots , a_n\)</span> &gt;: <span class="math">\(L_n\)</span> &lt;: <span class="math">\(U_n\)</span>]<span class="math">\(T\)</span> and no explicit type parameters are given.</p>
<p>Local type inference converts this expression to a type application <code>$e$[$T_1 , \ldots , T_n$]</code>. The choice of the type arguments <span class="math">\(T_1 , \ldots , T_n\)</span> depends on the context in which the expression appears and on the expected type <span class="math">\(\mathit{pt}\)</span>. There are three cases.</p>
<p><em>Case 1: Selections</em><br />If the expression appears as the prefix of a selection with a name <span class="math">\(x\)</span>, then type inference is <em>deferred</em> to the whole expression <span class="math">\(e.x\)</span>. That is, if <span class="math">\(e.x\)</span> has type <span class="math">\(S\)</span>, it is now treated as having type [<span class="math">\(a_1\)</span> &gt;: <span class="math">\(L_1\)</span> &lt;: <span class="math">\(U_1 , \ldots , a_n\)</span> &gt;: <span class="math">\(L_n\)</span> &lt;: <span class="math">\(U_n\)</span>]<span class="math">\(S\)</span>, and local type inference is applied in turn to infer type arguments for <span class="math">\(a_1 , \ldots , a_n\)</span>, using the context in which <span class="math">\(e.x\)</span> appears.</p>
<p><em>Case 2: Values</em><br />If the expression <span class="math">\(e\)</span> appears as a value without being applied to value arguments, the type arguments are inferred by solving a constraint system which relates the expression's type <span class="math">\(T\)</span> with the expected type <span class="math">\(\mathit{pt}\)</span>. Without loss of generality we can assume that <span class="math">\(T\)</span> is a value type; if it is a method type we apply <a href="#eta-expansion">eta-expansion</a> to convert it to a function type. Solving means finding a substitution <span class="math">\(\sigma\)</span> of types <span class="math">\(T_i\)</span> for the type parameters <span class="math">\(a_i\)</span> such that</p>
<ul>
<li>None of inferred types <span class="math">\(T_i\)</span> is a <a href="#singleton-types">singleton type</a></li>
<li>All type parameter bounds are respected, i.e.  <span class="math">\(\sigma L_i &lt;: \sigma a_i\)</span> and <span class="math">\(\sigma a_i &lt;: \sigma U_i\)</span> for <span class="math">\(i = 1 , \ldots , n\)</span>.</li>
<li>The expression's type conforms to the expected type, i.e.  <span class="math">\(\sigma T &lt;: \sigma \mathit{pt}\)</span>.</li>
</ul>
<p>It is a compile time error if no such substitution exists.<br />If several substitutions exist, local-type inference will choose for each type variable <span class="math">\(a_i\)</span> a minimal or maximal type <span class="math">\(T_i\)</span> of the solution space. A <em>maximal</em> type <span class="math">\(T_i\)</span> will be chosen if the type parameter <span class="math">\(a_i\)</span> appears <a href="#variance-annotations">contravariantly</a> in the type <span class="math">\(T\)</span> of the expression. A <em>minimal</em> type <span class="math">\(T_i\)</span> will be chosen in all other situations, i.e. if the variable appears covariantly, non-variantly or not at all in the type <span class="math">\(T\)</span>. We call such a substitution an <em>optimal solution</em> of the given constraint system for the type <span class="math">\(T\)</span>.</p>
<p><em>Case 3: Methods</em><br />The last case applies if the expression <span class="math">\(e\)</span> appears in an application <span class="math">\(e(d_1 , \ldots , d_m)\)</span>. In that case <span class="math">\(T\)</span> is a method type <span class="math">\((p_1:R_1 , \ldots , p_m:R_m)T&#39;\)</span>. Without loss of generality we can assume that the result type <span class="math">\(T&#39;\)</span> is a value type; if it is a method type we apply <a href="#eta-expansion">eta-expansion</a> to convert it to a function type. One computes first the types <span class="math">\(S_j\)</span> of the argument expressions <span class="math">\(d_j\)</span>, using two alternative schemes. Each argument expression <span class="math">\(d_j\)</span> is typed first with the expected type <span class="math">\(R_j\)</span>, in which the type parameters <span class="math">\(a_1 , \ldots , a_n\)</span> are taken as type constants. If this fails, the argument <span class="math">\(d_j\)</span> is typed instead with an expected type <span class="math">\(R_j&#39;\)</span> which results from <span class="math">\(R_j\)</span> by replacing every type parameter in <span class="math">\(a_1 , \ldots , a_n\)</span> with {}.</p>
<p>In a second step, type arguments are inferred by solving a constraint system which relates the method's type with the expected type <span class="math">\(\mathit{pt}\)</span> and the argument types <span class="math">\(S_1 , \ldots , S_m\)</span>. Solving the constraint system means finding a substitution <span class="math">\(\sigma\)</span> of types <span class="math">\(T_i\)</span> for the type parameters <span class="math">\(a_i\)</span> such that</p>
<ul>
<li>None of inferred types <span class="math">\(T_i\)</span> is a <a href="#singleton-types">singleton type</a></li>
<li>All type parameter bounds are respected, i.e.  <span class="math">\(\sigma L_i &lt;: \sigma a_i\)</span> and <span class="math">\(\sigma a_i &lt;: \sigma U_i\)</span> for <span class="math">\(i = 1 , \ldots , n\)</span>.</li>
<li>The method's result type <span class="math">\(T&#39;\)</span> conforms to the expected type, i.e.  <span class="math">\(\sigma T&#39; &lt;: \sigma \mathit{pt}\)</span>.</li>
<li>Each argument type <a href="#weak-conformance">weakly conforms</a> to the corresponding formal parameter type, i.e.  <span class="math">\(\sigma S_j &lt;:_w \sigma R_j\)</span> for <span class="math">\(j = 1 , \ldots , m\)</span>.</li>
</ul>
<p>It is a compile time error if no such substitution exists. If several solutions exist, an optimal one for the type <span class="math">\(T&#39;\)</span> is chosen.</p>
<p>All or parts of an expected type <span class="math">\(\mathit{pt}\)</span> may be undefined. The rules for <a href="#conformance">conformance</a> are extended to this case by adding the rule that for any type <span class="math">\(T\)</span> the following two statements are always true: <span class="math">\(\mathit{undefined} &lt;: T\)</span> and <span class="math">\(T &lt;: \mathit{undefined}\)</span></p>
<p>It is possible that no minimal or maximal solution for a type variable exists, in which case a compile-time error results. Because <span class="math">\(&lt;:\)</span> is a pre-order, it is also possible that a solution set has several optimal solutions for a type. In that case, a Scala compiler is free to pick any one of them.</p>
<ol start="68" type="1">
<li><p>Consider the two methods:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> cons[A](x: A, xs: List[A]): List[A] = x :: xs
<span class="kw">def</span> nil[B]: List[B] = Nil</code></pre>
<p>and the definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = <span class="fu">cons</span>(<span class="dv">1</span>, nil)</code></pre>
<p>The application of <code>cons</code> is typed with an undefined expected type. This application is completed by local type inference to <code>cons[Int](1, nil)</code>. Here, one uses the following reasoning to infer the type argument <code>Int</code> for the type parameter <code>a</code>:</p>
<p>First, the argument expressions are typed. The first argument <code>1</code> has type <code>Int</code> whereas the second argument <code>nil</code> is itself polymorphic. One tries to type-check <code>nil</code> with an expected type <code>List[a]</code>. This leads to the constraint system</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[b?] &lt;: List[a]</code></pre>
<p>where we have labeled <code>b?</code> with a question mark to indicate that it is a variable in the constraint system. Because class <code>List</code> is covariant, the optimal solution of this constraint is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">b = scala.<span class="fu">Nothing</span></code></pre>
<p>In a second step, one solves the following constraint system for the type parameter <code>a</code> of <code>cons</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">Int &lt;: a?
List[scala.<span class="fu">Nothing</span>] &lt;: List[a?]
List[a?] &lt;: $\mbox{\sl undefined}$</code></pre>
<p>The optimal solution of this constraint system is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a = Int</code></pre>
<p>so <code>Int</code> is the type inferred for <code>a</code>.</p></li>
<li><p>Consider now the definition</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> ys = <span class="fu">cons</span>(<span class="st">&quot;abc&quot;</span>, xs)</code></pre>
<p>where <code>xs</code> is defined of type <code>List[Int]</code> as before. In this case local type inference proceeds as follows.</p>
<p>First, the argument expressions are typed. The first argument <code>&quot;abc&quot;</code> has type <code>String</code>. The second argument <code>xs</code> is first tried to be typed with expected type <code>List[a]</code>. This fails, as <code>List[Int]</code> is not a subtype of <code>List[a]</code>. Therefore, the second strategy is tried; <code>xs</code> is now typed with expected type <code>List[$\mbox{\sl undefined}$]</code>. This succeeds and yields the argument type <code>List[Int]</code>.</p>
<p>In a second step, one solves the following constraint system for the type parameter <code>a</code> of <code>cons</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">String &lt;: a?
List[Int] &lt;: List[a?]
List[a?] &lt;: $\mbox{\sl undefined}$</code></pre>
<p>The optimal solution of this constraint system is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a = scala.<span class="fu">Any</span> </code></pre>
<p>so <code>scala.Any</code> is the type inferred for <code>a</code>.</p></li>
</ol>
<h3 id="eta-expansion"><a href="#eta-expansion"><span class="header-section-number">6.26.5</span> Eta Expansion</a></h3>
<p><em>Eta-expansion</em> converts an expression of method type to an equivalent expression of function type. It proceeds in two steps.</p>
<p>First, one identifes the maximal sub-expressions of <span class="math">\(e\)</span>; let's say these are <span class="math">\(e_1 , \ldots , e_m\)</span>. For each of these, one creates a fresh name <span class="math">\(x_i\)</span>. Let <span class="math">\(e&#39;\)</span> be the expression resulting from replacing every maximal subexpression <span class="math">\(e_i\)</span> in <span class="math">\(e\)</span> by the corresponding fresh name <span class="math">\(x_i\)</span>. Second, one creates a fresh name <span class="math">\(y_i\)</span> for every argument type <span class="math">\(T_i\)</span> of the method (<span class="math">\(i = 1 , \ldots , n\)</span>). The result of eta-conversion is then:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">val</span> $x_1$ = $e_1$; 
  $\ldots$ 
  <span class="kw">val</span> $x_m$ = $e_m$; 
  ($y_1: T_1 , \ldots , y_n: T_n$) =&gt; $e&#39;$($y_1 , \ldots , y_n$) 
}</code></pre>
<h3 id="dynamic-member-selection"><a href="#dynamic-member-selection"><span class="header-section-number">6.26.6</span> Dynamic Member Selection</a></h3>
<p>The standard Scala library defines a trait <code>scala.Dynamic</code> which defines a member @invokeDynamic@ as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">trait</span> Dynamic {
  <span class="kw">def</span> <span class="fu">applyDynamic</span> (name: String, args: Any*): Any
  ...
}</code></pre>
<p>Assume a selection of the form <span class="math">\(e.x\)</span> where the type of <span class="math">\(e\)</span> conforms to <code>scala.Dynamic</code>. Further assuming the selection is not followed by any function arguments, such an expression can be rewitten under the conditions given <a href="#implicit-conversions">here</a> to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">applyDynamic</span>(<span class="st">&quot;$x$&quot;</span>)</code></pre>
<p>If the selection is followed by some arguments, e.g. <span class="math">\(e.x(\mathit{args})\)</span>, then that expression is rewritten to</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$e$.<span class="fu">applyDynamic</span>(<span class="st">&quot;$x$&quot;</span>, $\mathit{args}$)</code></pre>
<h1 id="implicit-parameters-and-views"><a href="#implicit-parameters-and-views"><span class="header-section-number">7</span> Implicit Parameters and Views</a></h1>
<h2 id="the-implicit-modifier"><a href="#the-implicit-modifier"><span class="header-section-number">7.1</span> The Implicit Modifier</a></h2>
<pre class="grammar"><code>LocalModifier  ::= ‘implicit’
ParamClauses   ::= {ParamClause} [nl] ‘(’ ‘implicit’ Params ‘)’</code></pre>
<p>Template members and parameters labeled with an <code>implicit</code> modifier can be passed to <a href="#implicit-parameters">implicit parameters</a> and can be used as implicit conversions called <a href="#views">views</a>. The <code class="sourceCode scala"><span class="kw">implicit</span></code> modifier is illegal for all type members, as well as for <a href="#packagings">top-level objects</a>.</p>
<ol start="70" type="1">
<li><p>The following code defines an abstract class of monoids and two concrete implementations, <code>StringMonoid</code> and <code>IntMonoid</code>. The two implementations are marked implicit.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Monoid[A] <span class="kw">extends</span> SemiGroup[A] {
  <span class="kw">def</span> <span class="dt">unit</span>: A
  <span class="kw">def</span> <span class="fu">add</span>(x: A, y: A): A
}
<span class="kw">object</span> Monoids {
  <span class="kw">implicit</span> <span class="kw">object</span> stringMonoid <span class="kw">extends</span> Monoid[String] {
    <span class="kw">def</span> <span class="fu">add</span>(x: String, y: String): String = x.<span class="fu">concat</span>(y)
    <span class="kw">def</span> <span class="dt">unit</span>: String = <span class="st">&quot;&quot;</span>
  }
  <span class="kw">implicit</span> <span class="kw">object</span> intMonoid <span class="kw">extends</span> Monoid[Int] {
    <span class="kw">def</span> <span class="fu">add</span>(x: Int, y: Int): Int = x + y
    <span class="kw">def</span> <span class="dt">unit</span>: Int = <span class="dv">0</span>
  }
}</code></pre></li>
</ol>
<h2 id="implicit-parameters"><a href="#implicit-parameters"><span class="header-section-number">7.2</span> Implicit Parameters</a></h2>
<p>An implicit parameter list <code class="sourceCode scala">(<span class="kw">implicit</span> $p_1$,$\ldots$,$p_n$)</code> of a method marks the parameters <span class="math">\(p_1 , \ldots , p_n\)</span> as implicit. A method or constructor can have only one implicit parameter list, and it must be the last parameter list given.</p>
<p>A method with implicit parameters can be applied to arguments just like a normal method. In this case the <code>implicit</code> label has no effect. However, if such a method misses arguments for its implicit parameters, such arguments will be automatically provided.</p>
<p>The actual arguments that are eligible to be passed to an implicit parameter of type <span class="math">\(T\)</span> fall into two categories. First, eligible are all identifiers <span class="math">\(x\)</span> that can be accessed at the point of the method call without a prefix and that denote an <a href="#the-implicit-modifier">implicit definition</a> or an implicit parameter. An eligible identifier may thus be a local name, or a member of an enclosing template, or it may be have been made accessible without a prefix through an <a href="#import-clauses">import clause</a>. If there are no eligible identifiers under this rule, then, second, eligible are also all <code class="sourceCode scala"><span class="kw">implicit</span></code> members of some object that belongs to the implicit scope of the implicit parameter's type, <span class="math">\(T\)</span>.</p>
<p>The <em>implicit scope</em> of a type <span class="math">\(T\)</span> consists of all <a href="#object-definitions">companion modules</a> of classes that are associated with the implicit parameter's type. Here, we say a class <span class="math">\(C\)</span> is <em>associated</em> with a type <span class="math">\(T\)</span>, if it is a <a href="#class-linearization">base class</a> of some part of <span class="math">\(T\)</span>. The <em>parts</em> of a type <span class="math">\(T\)</span> are:</p>
<ul>
<li>if <span class="math">\(T\)</span> is a compound type <code class="sourceCode scala">$T_1$ <span class="kw">with</span> $\ldots$ <span class="kw">with</span> $T_n$</code>, the union of the parts of <span class="math">\(T_1 , \ldots , T_n\)</span>, as well as <span class="math">\(T\)</span> itself,</li>
<li>if <span class="math">\(T\)</span> is a parameterized type <code>$S$[$T_1 , \ldots , T_n$]</code>, the union of the parts of <span class="math">\(S\)</span> and <span class="math">\(T_1 , \ldots , T_n\)</span>,</li>
<li>if <span class="math">\(T\)</span> is a singleton type <code class="sourceCode scala">$p$.<span class="fu">type</span></code>, the parts of the type of <span class="math">\(p\)</span>,</li>
<li>if <span class="math">\(T\)</span> is a type projection <code class="sourceCode scala">$S$#$U$</code>, the parts of <span class="math">\(S\)</span> as well as <span class="math">\(T\)</span> itself,</li>
<li>in all other cases, just <span class="math">\(T\)</span> itself.</li>
</ul>
<p>If there are several eligible arguments which match the implicit parameter's type, a most specific one will be chosen using the rules of static <a href="#overloading-resolution">overloading resolution</a>. If the parameter has a default argument and no implicit argument can be found the default argument is used.</p>
<ol start="71" type="1">
<li><p>Assuming the classes from , here is a method which computes the sum of a list of elements using the monoid's <code>add</code> and <code>unit</code> operations.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sum[A](xs: List[A])(<span class="kw">implicit</span> m: Monoid[A]): A = 
  <span class="kw">if</span> (xs.<span class="fu">isEmpty</span>) m.<span class="fu">unit</span>
  <span class="kw">else</span> m.<span class="fu">add</span>(xs.<span class="fu">head</span>, <span class="fu">sum</span>(xs.<span class="fu">tail</span>))</code></pre>
<p>The monoid in question is marked as an implicit parameter, and can therefore be inferred based on the type of the list. Consider for instance the call <code class="sourceCode scala"><span class="fu">sum</span>(List(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))</code> in a context where <code>stringMonoid</code> and <code>intMonoid</code> are visible. We know that the formal type parameter <code>a</code> of <code>sum</code> needs to be instantiated to <code>Int</code>. The only eligible object which matches the implicit formal parameter type <code>Monoid[Int]</code> is <code>intMonoid</code> so this object will be passed as implicit parameter.</p></li>
</ol>
<p>This discussion also shows that implicit parameters are inferred after any type arguments are <a href="#local-type-inference">inferred</a>.</p>
<p>Implicit methods can themselves have implicit parameters. An example is the following method from module <code>scala.List</code>, which injects lists into the <code class="sourceCode scala">scala.<span class="fu">Ordered</span></code> class, provided the element type of the list is also convertible to this type.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> list2ordered[A](x: List[A])
  (<span class="kw">implicit</span> elem2ordered: A =&gt; Ordered[A]): Ordered[List[A]] = 
  ...</code></pre>
<p>Assume in addition a method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> <span class="fu">int2ordered</span>(x: Int): Ordered[Int]</code></pre>
<p>that injects integers into the <code>Ordered</code> class. We can now define a <code>sort</code> method over ordered lists:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sort[A](xs: List[A])(<span class="kw">implicit</span> a2ordered: A =&gt; Ordered[A]) = ...</code></pre>
<p>We can apply <code>sort</code> to a list of lists of integers <code class="sourceCode scala">yss: List[List[Int]]</code> as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sort</span>(yss)</code></pre>
<p>The call above will be completed by passing two nested implicit arguments:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sort</span>(yss)(xs: List[Int] =&gt; list2ordered[Int](xs)(int2ordered)) .</code></pre>
<p>The possibility of passing implicit arguments to implicit arguments raises the possibility of an infinite recursion. For instance, one might try to define the following method, which injects <em>every</em> type into the <code>Ordered</code> class:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> magic[A](x: A)(<span class="kw">implicit</span> a2ordered: A =&gt; Ordered[A]): Ordered[A] = 
  <span class="fu">a2ordered</span>(x)</code></pre>
<p>Now, if one tried to apply <code>sort</code> to an argument <code>arg</code> of a type that did not have another injection into the <code>Ordered</code> class, one would obtain an infinite expansion:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sort</span>(arg)(x =&gt; <span class="fu">magic</span>(x)(x =&gt; <span class="fu">magic</span>(x)(x =&gt; ... )))</code></pre>
<p>To prevent such infinite expansions, the compiler keeps track of a stack of “open implicit types” for which implicit arguments are currently being searched. Whenever an implicit argument for type <span class="math">\(T\)</span> is searched, the “core type” of <span class="math">\(T\)</span> is added to the stack. Here, the <em>core type</em> of <span class="math">\(T\)</span> is <span class="math">\(T\)</span> with aliases expanded, top-level type <a href="#user-defined-annotations">annotations</a> and <a href="#compound-types">refinements</a> removed, and occurrences of top-level existentially bound variables replaced by their upper bounds. The core type is removed from the stack once the search for the implicit argument either definitely fails or succeeds. Everytime a core type is added to the stack, it is checked that this type does not dominate any of the other types in the set.</p>
<p>Here, a core type <span class="math">\(T\)</span> <em>dominates</em> a type <span class="math">\(U\)</span> if <span class="math">\(T\)</span> is <a href="#type-equivalence">equivalent</a> to <span class="math">\(U\)</span>, or if the top-level type constructors of <span class="math">\(T\)</span> and <span class="math">\(U\)</span> have a common element and <span class="math">\(T\)</span> is more complex than <span class="math">\(U\)</span>.</p>
<p>The set of <em>top-level type constructors</em> <span class="math">\(\mathit{ttcs}(T)\)</span> of a type <span class="math">\(T\)</span> depends on the form of the type:</p>
<blockquote>
<p>For a type designator,<br /><span class="math">\(\mathit{ttcs}(p.c) ~=~ \{c\}\)</span>;<br />For a parameterized type,<br /><span class="math">\(\mathit{ttcs}(p.c[\mathit{targs}]) ~=~ \{c\}\)</span>;<br />For a singleton type,<br /><span class="math">\(\mathit{ttcs}(p.type) ~=~ \mathit{ttcs}(T)\)</span>, provided <span class="math">\(p\)</span> has type <span class="math">\(T\)</span>;<br />For a compound type,<br /><code>$\mathit{ttcs}(T_1$ with $\ldots$ with $T_n)$</code> <span class="math">\(~=~ \mathit{ttcs}(T_1) \cup \ldots \cup \mathit{ttcs}(T_n)\)</span>.</p>
</blockquote>
<p>The <em>complexity</em> <span class="math">\(\mathit{complexity}(T)\)</span> of a core type is an integer which also depends on the form of the type:</p>
<blockquote>
<p>For a type designator,<br /><span class="math">\(\mathit{complexity}(p.c) ~=~ 1 + \mathit{complexity}(p)\)</span><br />For a parameterized type,<br /><span class="math">\(\mathit{complexity}(p.c[\mathit{targs}]) ~=~ 1 + \Sigma \mathit{complexity}(\mathit{targs})\)</span><br />For a singleton type denoting a package <span class="math">\(p\)</span>,<br /><span class="math">\(\mathit{complexity}(p.type) ~=~ 0\)</span><br />For any other singleton type,<br /><span class="math">\(\mathit{complexity}(p.type) ~=~ 1 + \mathit{complexity}(T)\)</span>, provided <span class="math">\(p\)</span> has type <span class="math">\(T\)</span>;<br />For a compound type,<br /><code>$\mathit{complexity}(T_1$ with $\ldots$ with $T_n)$</code> <span class="math">\(= \Sigma\mathit{complexity}(T_i)\)</span></p>
</blockquote>
<ol start="72" type="1">
<li><p>When typing <code>sort(xs)</code> for some list <code>xs</code> of type <code>List[List[List[Int]]]</code>, the sequence of types for which implicit arguments are searched is</p>
<pre class="sourceCode scala"><code class="sourceCode scala">List[List[Int]] =&gt; Ordered[List[List[Int]]], 
List[Int] =&gt; Ordered[List[Int]]
Int =&gt; Ordered[Int]</code></pre>
<p>All types share the common type constructor <code>scala.Function1</code>, but the complexity of the each new type is lower than the complexity of the previous types. Hence, the code typechecks.</p></li>
<li><p>Let <code>ys</code> be a list of some type which cannot be converted to <code>Ordered</code>. For instance:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> ys = List(<span class="kw">new</span> IllegalArgumentException, <span class="kw">new</span> ClassCastException, <span class="kw">new</span> Error)</code></pre>
<p>Assume that the definition of <code>magic</code> above is in scope. Then the sequence of types for which implicit arguments are searched is</p>
<pre><code>Throwable =&gt; Ordered[Throwable],
Throwable =&gt; Ordered[Throwable],
...</code></pre>
<p>Since the second type in the sequence is equal to the first, the compiler will issue an error signalling a divergent implicit expansion.</p></li>
</ol>
<h2 id="views"><a href="#views"><span class="header-section-number">7.3</span> Views</a></h2>
<p>Implicit parameters and methods can also define implicit conversions called views. A <em>view</em> from type <span class="math">\(S\)</span> to type <span class="math">\(T\)</span> is defined by an implicit value which has function type <code>$S$=&gt;$T$</code> or <code>(=&gt;$S$)=&gt;$T$</code> or by a method convertible to a value of that type.</p>
<p>Views are applied in three situations.</p>
<ol>
<li>If an expression <span class="math">\(e\)</span> is of type <span class="math">\(T\)</span>, and <span class="math">\(T\)</span> does not conform to the expression's expected type <span class="math">\(\mathit{pt}\)</span>. In this case an implicit <span class="math">\(v\)</span> is searched which is applicable to <span class="math">\(e\)</span> and whose result type conforms to <span class="math">\(\mathit{pt}\)</span>. The search proceeds as in the case of implicit parameters, where the implicit scope is the one of <code>$T$ =&gt; $\mathit{pt}$</code>. If such a view is found, the expression <span class="math">\(e\)</span> is converted to <code>$v$($e$)</code>.</li>
<li>In a selection <span class="math">\(e.m\)</span> with <span class="math">\(e\)</span> of type <span class="math">\(T\)</span>, if the selector <span class="math">\(m\)</span> does not denote a member of <span class="math">\(T\)</span>. In this case, a view <span class="math">\(v\)</span> is searched which is applicable to <span class="math">\(e\)</span> and whose result contains a member named <span class="math">\(m\)</span>. The search proceeds as in the case of implicit parameters, where the implicit scope is the one of <span class="math">\(T\)</span>. If such a view is found, the selection <span class="math">\(e.m\)</span> is converted to <code>$v$($e$).$m$</code>.</li>
<li>In a selection <span class="math">\(e.m(\mathit{args})\)</span> with <span class="math">\(e\)</span> of type <span class="math">\(T\)</span>, if the selector <span class="math">\(m\)</span> denotes some member(s) of <span class="math">\(T\)</span>, but none of these members is applicable to the arguments <span class="math">\(\mathit{args}\)</span>. In this case a view <span class="math">\(v\)</span> is searched which is applicable to <span class="math">\(e\)</span> and whose result contains a method <span class="math">\(m\)</span> which is applicable to <span class="math">\(\mathit{args}\)</span>. The search proceeds as in the case of implicit parameters, where the implicit scope is the one of <span class="math">\(T\)</span>. If such a view is found, the selection <span class="math">\(e.m\)</span> is converted to <code>$v$($e$).$m(\mathit{args})$</code>.</li>
</ol>
<p>The implicit view, if it is found, can accept is argument <span class="math">\(e\)</span> as a call-by-value or as a call-by-name parameter. However, call-by-value implicits take precedence over call-by-name implicits.</p>
<p>As for implicit parameters, overloading resolution is applied if there are several possible candidates (of either the call-by-value or the call-by-name category).</p>
<ol start="74" type="1">
<li><p>Class <code>scala.Ordered[A]</code> contains a method</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> &lt;= [B &gt;: A](that: B)(<span class="kw">implicit</span> b2ordered: B =&gt; Ordered[B]): Boolean .</code></pre>
<p>Assume two lists <code>xs</code> and <code>ys</code> of type <code>List[Int]</code> and assume that the <code>list2ordered</code> and <code>int2ordered</code> methods defined <a href="#implicit-parameters">here</a> are in scope. Then the operation</p>
<pre><code>  xs &lt;= ys</code></pre>
<p>is legal, and is expanded to:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="fu">list2ordered</span>(xs)(int2ordered).&lt;=
    (ys)
    (xs =&gt; <span class="fu">list2ordered</span>(xs)(int2ordered))</code></pre>
<p>The first application of <code>list2ordered</code> converts the list <code>xs</code> to an instance of class <code>Ordered</code>, whereas the second occurrence is part of an implicit parameter passed to the <code>&lt;=</code> method.</p></li>
</ol>
<h2 id="context-bounds-and-view-bounds"><a href="#context-bounds-and-view-bounds"><span class="header-section-number">7.4</span> Context Bounds and View Bounds</a></h2>
<pre class="grammar"><code>  TypeParam ::= (id | ‘_’) [TypeParamClause] [‘&gt;:’ Type] [‘&lt;:’ Type] 
                {‘&lt;%’ Type} {‘:’ Type}</code></pre>
<p>A type parameter <span class="math">\(A\)</span> of a method or non-trait class may have one or more view bounds <code>$A$ &lt;% $T$</code>. In this case the type parameter may be instantiated to any type <span class="math">\(S\)</span> which is convertible by application of a view to the bound <span class="math">\(T\)</span>.</p>
<p>A type parameter <span class="math">\(A\)</span> of a method or non-trait class may also have one or more context bounds <code>$A$ : $T$</code>. In this case the type parameter may be instantiated to any type <span class="math">\(S\)</span> for which <em>evidence</em> exists at the instantiation point that <span class="math">\(S\)</span> satisfies the bound <span class="math">\(T\)</span>. Such evidence consists of an implicit value with type <span class="math">\(T[S]\)</span>.</p>
<p>A method or class containing type parameters with view or context bounds is treated as being equivalent to a method with implicit parameters. Consider first the case of a single parameter with view and/or context bounds such as:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> $f$[$A$ &lt;% $T_1$ ... &lt;% $T_m$ : $U_1$ : $U_n$]($\mathit{ps}$): $R$ = ...</code></pre>
<p>Then the method definition above is expanded to</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> $f$[$A$]($\mathit{ps}$)(<span class="kw">implicit</span> $v_1$: $A$ =&gt; $T_1$, ..., $v_m$: $A$ =&gt; $T_m$,
                       $w_1$: $U_1$[$A$], ..., $w_n$: $U_n$[$A$]): $R$ = ...</code></pre>
<p>where the <span class="math">\(v_i\)</span> and <span class="math">\(w_j\)</span> are fresh names for the newly introduced implicit parameters. These parameters are called <em>evidence parameters</em>.</p>
<p>If a class or method has several view- or context-bounded type parameters, each such type parameter is expanded into evidence parameters in the order they appear and all the resulting evidence parameters are concatenated in one implicit parameter section. Since traits do not take constructor parameters, this translation does not work for them. Consequently, type-parameters in traits may not be view- or context-bounded. Also, a method or class with view- or context bounds may not define any additional implicit parameters.</p>
<ol start="75" type="1">
<li><p>The <code>&lt;=</code> method mentioned in  can be declared more concisely as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> &lt;= [B &gt;: A &lt;% Ordered[B]](that: B): Boolean</code></pre></li>
</ol>
<h2 id="manifests"><a href="#manifests"><span class="header-section-number">7.5</span> Manifests</a></h2>
<p>Manifests are type descriptors that can be automatically generated by the Scala compiler as arguments to implicit parameters. The Scala standard library contains a hierarchy of four manifest classes, with <code>OptManifest</code> at the top. Their signatures follow the outline below.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> OptManifest[+T]
<span class="kw">object</span> NoManifest <span class="kw">extends</span> OptManifest[Nothing]
<span class="kw">trait</span> ClassManifest[T] <span class="kw">extends</span> OptManifest[T]
<span class="kw">trait</span> Manifest[T] <span class="kw">extends</span> ClassManifest[T]</code></pre>
<p>If an implicit parameter of a method or constructor is of a subtype <span class="math">\(M[T]\)</span> of class <code>OptManifest[T]</code>, <em>a manifest is determined for <span class="math">\(M[S]\)</span></em>, according to the following rules.</p>
<p>First if there is already an implicit argument that matches <span class="math">\(M[T]\)</span>, this argument is selected.</p>
<p>Otherwise, let <span class="math">\(\mathit{Mobj}\)</span> be the companion object <code>scala.reflect.Manifest</code> if <span class="math">\(M\)</span> is trait <code>Manifest</code>, or be the companion object <code>scala.reflect.ClassManifest</code> otherwise. Let <span class="math">\(M&#39;\)</span> be the trait <code>Manifest</code> if <span class="math">\(M\)</span> is trait <code>Manifest</code>, or be the trait <code>OptManifest</code> otherwise.<br />Then the following rules apply.</p>
<ol>
<li>If <span class="math">\(T\)</span> is a value class or one of the classes <code>Any</code>, <code>AnyVal</code>, <code>Object</code>, <code>Null</code>, or <code>Nothing</code>, a manifest for it is generated by selecting the corresponding manifest value <code>Manifest.$T$</code>, which exists in the <code>Manifest</code> module.</li>
<li>If <span class="math">\(T\)</span> is an instance of <code>Array[$S$]</code>, a manifest is generated with the invocation <code>$\mathit{Mobj}$.arrayType[S](m)</code>, where <span class="math">\(m\)</span> is the manifest determined for <span class="math">\(M[S]\)</span>.</li>
<li>If <span class="math">\(T\)</span> is some other class type <span class="math">\(S\#C[U_1 , \ldots , U_n]\)</span> where the prefix type <span class="math">\(S\)</span> cannot be statically determined from the class <span class="math">\(C\)</span>, a manifest is generated with the invocation <code>$\mathit{Mobj}$.classType[T]($m_0$, classOf[T], $ms$)</code> where <span class="math">\(m_0\)</span> is the manifest determined for <span class="math">\(M&#39;[S]\)</span> and <span class="math">\(ms\)</span> are the manifests determined for <span class="math">\(M&#39;[U_1] , \ldots , M&#39;[U_n]\)</span>.</li>
<li>If <span class="math">\(T\)</span> is some other class type with type arguments <span class="math">\(U_1 , \ldots , U_n\)</span>, a manifest is generated with the invocation <code>$\mathit{Mobj}$.classType[T](classOf[T], $ms$)</code> where <span class="math">\(ms\)</span> are the manifests determined for <span class="math">\(M&#39;[U_1] , \ldots , M&#39;[U_n]\)</span>.</li>
<li>If <span class="math">\(T\)</span> is a singleton type <code>$p$.type</code>, a manifest is generated with the invocation <code>$\mathit{Mobj}$.singleType[T]($p$)</code></li>
<li>If <span class="math">\(T\)</span> is a refined type <span class="math">\(T&#39; \{ R \}\)</span>, a manifest is generated for <span class="math">\(T&#39;\)</span>. (That is, refinements are never reflected in manifests).</li>
<li>If <span class="math">\(T\)</span> is an intersection type <code>$T_1$ with $, \ldots ,$ with $T_n$</code> where <span class="math">\(n &gt; 1\)</span>, the result depends on whether a full manifest is to be determined or not. If <span class="math">\(M\)</span> is trait <code>Manifest</code>, then a manifest is generated with the invocation <code>Manifest.intersectionType[T]($ms$)</code> where <span class="math">\(ms\)</span> are the manifests determined for <span class="math">\(M[T_1] , \ldots , M[T_n]\)</span>. Otherwise, if <span class="math">\(M\)</span> is trait <code>ClassManifest</code>, then a manifest is generated for the <a href="#type-erasure">intersection dominator</a> of the types <span class="math">\(T_1 , \ldots , T_n\)</span>.</li>
<li>If <span class="math">\(T\)</span> is some other type, then if <span class="math">\(M\)</span> is trait <code>OptManifest</code>, a manifest is generated from the designator <code>scala.reflect.NoManifest</code>. If <span class="math">\(M\)</span> is a type different from <code>OptManifest</code>, a static error results.</li>
</ol>
<h1 id="pattern-matching"><a href="#pattern-matching"><span class="header-section-number">8</span> Pattern Matching</a></h1>
<h2 id="patterns"><a href="#patterns"><span class="header-section-number">8.1</span> Patterns</a></h2>
<pre class="grammar"><code>  Pattern         ::=  Pattern1 { ‘|’ Pattern1 }
  Pattern1        ::=  varid ‘:’ TypePat
                    |  ‘_’ ‘:’ TypePat
                    |  Pattern2
  Pattern2        ::=  varid [‘@’ Pattern3]
                    |  Pattern3
  Pattern3        ::=  SimplePattern 
                    |  SimplePattern {id [nl] SimplePattern}
  SimplePattern   ::=  ‘_’
                    |  varid
                    |  Literal
                    |  StableId
                    |  StableId ‘(’ [Patterns] ‘)’
                    |  StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’
                    |  ‘(’ [Patterns] ‘)’
                    |  XmlPattern
  Patterns        ::=  Pattern {‘,’ Patterns}</code></pre>
<p>A pattern is built from constants, constructors, variables and type tests. Pattern matching tests whether a given value (or sequence of values) has the shape defined by a pattern, and, if it does, binds the variables in the pattern to the corresponding components of the value (or sequence of values). The same variable name may not be bound more than once in a pattern.</p>
<ol start="76" type="1">
<li><p>Some examples of patterns are:</p>
<ol>
<li>The pattern <code>ex: IOException</code> matches all instances of class <code>IOException</code>, binding variable  to the instance.</li>
<li>The pattern <code>Some(x)</code> matches values of the form <code>Some($v$)</code>, binding <code>x</code> to the argument value <span class="math">\(v\)</span> of the <code>Some</code> constructor.</li>
<li>The pattern <code>(x, _)</code> matches pairs of values, binding <code>x</code> to the first component of the pair. The second component is matched with a wildcard pattern.</li>
<li>The pattern <code class="sourceCode scala">x :: y :: xs</code> matches lists of length <span class="math">\(\geq 2\)</span>, binding <code>x</code> to the list's first element, <code>y</code> to the list's second element, and <code>xs</code> to the remainder.</li>
<li>The pattern <code>1 | 2 | 3</code> matches the integers between 1 and 3.</li>
</ol>
<p>Pattern matching is always done in a context which supplies an expected type of the pattern. We distinguish the following kinds of patterns.</p></li>
</ol>
<h3 id="variable-patterns"><a href="#variable-patterns"><span class="header-section-number">8.1.1</span> Variable Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  `_&#39;
                    |  varid</code></pre>
<p>A variable pattern <span class="math">\(x\)</span> is a simple identifier which starts with a lower case letter. It matches any value, and binds the variable name to that value. The type of <span class="math">\(x\)</span> is the expected type of the pattern as given from outside. A special case is the wild-card pattern <span class="math">\(\_\)</span> which is treated as if it was a fresh variable on each occurrence.</p>
<h3 id="typed-patterns"><a href="#typed-patterns"><span class="header-section-number">8.1.2</span> Typed Patterns</a></h3>
<pre class="grammar"><code>  Pattern1        ::=  varid `:&#39; TypePat
                    |  `_&#39; `:&#39; TypePat</code></pre>
<p>A typed pattern <span class="math">\(x: T\)</span> consists of a pattern variable <span class="math">\(x\)</span> and a type pattern <span class="math">\(T\)</span>. The type of <span class="math">\(x\)</span> is the type pattern <span class="math">\(T\)</span>, where each type variable and wildcard is replaced by a fresh, unknown type. This pattern matches any value matched by the <a href="#type-patterns">type pattern</a> <span class="math">\(T\)</span>; it binds the variable name to that value.</p>
<h3 id="pattern-binders"><a href="#pattern-binders"><span class="header-section-number">8.1.3</span> Pattern Binders</a></h3>
<pre class="grammar"><code>  Pattern2        ::=  varid `@&#39; Pattern3</code></pre>
<p>A pattern binder <code>$x$@$p$</code> consists of a pattern variable <span class="math">\(x\)</span> and a pattern <span class="math">\(p\)</span>. The type of the variable <span class="math">\(x\)</span> is the static type <span class="math">\(T\)</span> of the pattern <span class="math">\(p\)</span>. This pattern matches any value <span class="math">\(v\)</span> matched by the pattern <span class="math">\(p\)</span>, provided the run-time type of <span class="math">\(v\)</span> is also an instance of <span class="math">\(T\)</span>, and it binds the variable name to that value.</p>
<h3 id="literal-patterns"><a href="#literal-patterns"><span class="header-section-number">8.1.4</span> Literal Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  Literal</code></pre>
<p>A literal pattern <span class="math">\(L\)</span> matches any value that is equal (in terms of <span class="math">\(==\)</span>) to the literal <span class="math">\(L\)</span>. The type of <span class="math">\(L\)</span> must conform to the expected type of the pattern.</p>
<h3 id="stable-identifier-patterns"><a href="#stable-identifier-patterns"><span class="header-section-number">8.1.5</span> Stable Identifier Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  StableId</code></pre>
<p>A stable identifier pattern is a <a href="#paths">stable identifier</a> <span class="math">\(r\)</span>. The type of <span class="math">\(r\)</span> must conform to the expected type of the pattern. The pattern matches any value <span class="math">\(v\)</span> such that <code>$r$ == $v$</code> (see <a href="#root-classes">here</a>).</p>
<p>To resolve the syntactic overlap with a variable pattern, a stable identifier pattern may not be a simple name starting with a lower-case letter. However, it is possible to enclose a such a variable name in backquotes; then it is treated as a stable identifier pattern.</p>
<ol start="77" type="1">
<li><p>Consider the following function definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: Int, y: Int) = x <span class="kw">match</span> {
  <span class="kw">case</span> y =&gt; ...
}</code></pre>
<p>Here, <code>y</code> is a variable pattern, which matches any value. If we wanted to turn the pattern into a stable identifier pattern, this can be achieved as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: Int, y: Int) = x <span class="kw">match</span> {
  <span class="kw">case</span> `y` =&gt; ...
}</code></pre>
<p>Now, the pattern matches the <code>y</code> parameter of the enclosing function <code>f</code>. That is, the match succeeds only if the <code>x</code> argument and the <code>y</code> argument of <code>f</code> are equal.</p></li>
</ol>
<h3 id="constructor-patterns"><a href="#constructor-patterns"><span class="header-section-number">8.1.6</span> Constructor Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  StableId `(&#39; [Patterns] `)</code></pre>
<p>A constructor pattern is of the form <span class="math">\(c(p_1 , \ldots , p_n)\)</span> where <span class="math">\(n \geq 0\)</span>. It consists of a stable identifier <span class="math">\(c\)</span>, followed by element patterns <span class="math">\(p_1 , \ldots , p_n\)</span>. The constructor <span class="math">\(c\)</span> is a simple or qualified name which denotes a <a href="#case-classes">case class</a>. If the case class is monomorphic, then it must conform to the expected type of the pattern, and the formal parameter types of <span class="math">\(x\)</span>'s <a href="#class-definitions">primary constructor</a> are taken as the expected types of the element patterns <span class="math">\(p_1, \ldots , p_n\)</span>. If the case class is polymorphic, then its type parameters are instantiated so that the instantiation of <span class="math">\(c\)</span> conforms to the expected type of the pattern. The instantiated formal parameter types of <span class="math">\(c\)</span>'s primary constructor are then taken as the expected types of the component patterns <span class="math">\(p_1, \ldots , p_n\)</span>. The pattern matches all objects created from constructor invocations <span class="math">\(c(v_1 , \ldots , v_n)\)</span> where each element pattern <span class="math">\(p_i\)</span> matches the corresponding value <span class="math">\(v_i\)</span>.</p>
<p>A special case arises when <span class="math">\(c\)</span>'s formal parameter types end in a repeated parameter. This is further discussed <a href="#pattern-sequences">here</a>.</p>
<h3 id="tuple-patterns"><a href="#tuple-patterns"><span class="header-section-number">8.1.7</span> Tuple Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  `(&#39; [Patterns] `)&#39;</code></pre>
<p>A tuple pattern <code>($p_1 , \ldots , p_n$)</code> is an alias for the constructor pattern <code>scala.Tuple$n$($p_1 , \ldots , p_n$)</code>, where <span class="math">\(n \geq 2\)</span>. The empty tuple <code class="sourceCode scala">()</code> is the unique value of type <code class="sourceCode scala">scala.<span class="fu">Unit</span></code>.</p>
<h3 id="extractor-patterns"><a href="#extractor-patterns"><span class="header-section-number">8.1.8</span> Extractor Patterns</a></h3>
<pre class="grammar"><code>  SimplePattern   ::=  StableId `(&#39; [Patterns] `)&#39;</code></pre>
<p>An extractor pattern <span class="math">\(x(p_1 , \ldots , p_n)\)</span> where <span class="math">\(n \geq 0\)</span> is of the same syntactic form as a constructor pattern. However, instead of a case class, the stable identifier <span class="math">\(x\)</span> denotes an object which has a member method named <code>unapply</code> or <code>unapplySeq</code> that matches the pattern.</p>
<p>An <code>unapply</code> method in an object <span class="math">\(x\)</span> <em>matches</em> the pattern <span class="math">\(x(p_1 , \ldots , p_n)\)</span> if it takes exactly one argument and one of the following applies:</p>
<ul>
<li><span class="math">\(n=0\)</span> and <code>unapply</code>'s result type is <code>Boolean</code>. In this case the extractor pattern matches all values <span class="math">\(v\)</span> for which <code>$x$.unapply($v$)</code> yields <code>true</code>.</li>
<li><span class="math">\(n=1\)</span> and <code>unapply</code>'s result type is <code>Option[$T$]</code>, for some type <span class="math">\(T\)</span>. In this case, the (only) argument pattern <span class="math">\(p_1\)</span> is typed in turn with expected type <span class="math">\(T\)</span>. The extractor pattern matches then all values <span class="math">\(v\)</span> for which <code>$x$.unapply($v$)</code> yields a value of form <code>Some($v_1$)</code>, and <span class="math">\(p_1\)</span> matches <span class="math">\(v_1\)</span>.</li>
<li><span class="math">\(n&gt;1\)</span> and <code>unapply</code>'s result type is <code>Option[($T_1 , \ldots , T_n$)]</code>, for some types <span class="math">\(T_1 , \ldots , T_n\)</span>. In this case, the argument patterns <span class="math">\(p_1   , \ldots , p_n\)</span> are typed in turn with expected types <span class="math">\(T_1 , \ldots ,   T_n\)</span>. The extractor pattern matches then all values <span class="math">\(v\)</span> for which <code>$x$.unapply($v$)</code> yields a value of form <code>Some(($v_1 , \ldots , v_n$))</code>, and each pattern <span class="math">\(p_i\)</span> matches the corresponding value <span class="math">\(v_i\)</span>.</li>
</ul>
<p>An <code>unapplySeq</code> method in an object <span class="math">\(x\)</span> matches the pattern <span class="math">\(x(p_1 , \ldots , p_n)\)</span> if it takes exactly one argument and its result type is of the form <code>Option[$S$]</code>, where <span class="math">\(S\)</span> is a subtype of <code>Seq[$T$]</code> for some element type <span class="math">\(T\)</span>. This case is further discussed <a href="#pattern-seqs">here</a>.</p>
<ol start="78" type="1">
<li><p>The <code>Predef</code> object contains a definition of an extractor object <code>Pair</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Pair {
  <span class="kw">def</span> apply[A, B](x: A, y: B) = <span class="fu">Tuple2</span>(x, y)
  <span class="kw">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}</code></pre>
<p>This means that the name <code>Pair</code> can be used in place of <code>Tuple2</code> for tuple formation as well as for deconstruction of tuples in patterns. Hence, the following is possible:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x = (<span class="dv">1</span>, <span class="dv">2</span>)
<span class="kw">val</span> y = x <span class="kw">match</span> {
  <span class="kw">case</span> Pair(i, s) =&gt; Pair(s + i, i * i)
}</code></pre></li>
</ol>
<h3 id="pattern-sequences"><a href="#pattern-sequences"><span class="header-section-number">8.1.9</span> Pattern Sequences</a></h3>
<pre class="grammar"><code>  SimplePattern ::= StableId `(&#39; [Patterns `,&#39;] [varid `@&#39;] `_&#39; `*&#39; `)&#39;</code></pre>
<p>A pattern sequence <span class="math">\(p_1 , \ldots , p_n\)</span> appears in two contexts. First, in a constructor pattern <span class="math">\(c(q_1 , \ldots , q_m, p_1 , \ldots , p_n\)</span>), where <span class="math">\(c\)</span> is a case class which has <span class="math">\(m+1\)</span> primary constructor parameters, ending in a <a href="#repeated-parameters">repeated parameter</a> of type <span class="math">\(S*\)</span>. Second, in an extractor pattern <span class="math">\(x(p_1 , \ldots , p_n)\)</span> if the extractor object <span class="math">\(x\)</span> has an <code>unapplySeq</code> method with a result type conforming to <code>Seq[$S$]</code>, but does not have an <code>unapply</code> method that matches <span class="math">\(p_1 , \ldots , p_n\)</span>. The expected type for the pattern sequence is in each case the type <span class="math">\(S\)</span>.</p>
<p>The last pattern in a pattern sequence may be a <em>sequence wildcard</em> <code>_*</code>. Each element pattern <span class="math">\(p_i\)</span> is type-checked with <span class="math">\(S\)</span> as expected type, unless it is a sequence wildcard. If a final sequence wildcard is present, the pattern matches all values <span class="math">\(v\)</span> that are sequences which start with elements matching patterns <span class="math">\(p_1 , \ldots , p_{n-1}\)</span>. If no final sequence wildcard is given, the pattern matches all values <span class="math">\(v\)</span> that are sequences of length <span class="math">\(n\)</span> which consist of elements matching patterns <span class="math">\(p_1 , \ldots , p_n\)</span>.</p>
<h3 id="infix-operation-patterns"><a href="#infix-operation-patterns"><span class="header-section-number">8.1.10</span> Infix Operation Patterns</a></h3>
<pre class="grammar"><code>  Pattern3  ::=  SimplePattern {id [nl] SimplePattern}</code></pre>
<p>An infix operation pattern <span class="math">\(p;\mathit{op};q\)</span> is a shorthand for the constructor or extractor pattern <span class="math">\(\mathit{op}(p, q)\)</span>. The precedence and associativity of operators in patterns is the same as in <a href="#prefix-infix-and-postfix-operations">expressions</a>.</p>
<p>An infix operation pattern <span class="math">\(p;\mathit{op};(q_1 , \ldots , q_n)\)</span> is a shorthand for the constructor or extractor pattern <span class="math">\(\mathit{op}(p, q_1 , \ldots , q_n)\)</span>.</p>
<h3 id="pattern-alternatives"><a href="#pattern-alternatives"><span class="header-section-number">8.1.11</span> Pattern Alternatives</a></h3>
<pre class="grammar"><code>  Pattern   ::=  Pattern1 { `|&#39; Pattern1 }</code></pre>
<p>A pattern alternative <code>$p_1$ | $\ldots$ | $p_n$</code> consists of a number of alternative patterns <span class="math">\(p_i\)</span>. All alternative patterns are type checked with the expected type of the pattern. They may no bind variables other than wildcards. The alternative pattern matches a value <span class="math">\(v\)</span> if at least one its alternatives matches <span class="math">\(v\)</span>.</p>
<h3 id="xml-patterns"><a href="#xml-patterns"><span class="header-section-number">8.1.12</span> XML Patterns</a></h3>
<p>XML patterns are treated <a href="#xml-patterns">here</a>.</p>
<h3 id="regular-expression-patterns"><a href="#regular-expression-patterns"><span class="header-section-number">8.1.13</span> Regular Expression Patterns</a></h3>
<p>Regular expression patterns have been discontinued in Scala from version 2.0.</p>
<p>Later version of Scala provide a much simplified version of regular expression patterns that cover most scenarios of non-text sequence processing. A <em>sequence pattern</em> is a pattern that stands in a position where either (1) a pattern of a type <code>T</code> which is conforming to <code>Seq[A]</code> for some <code>A</code> is expected, or (2) a case class constructor that has an iterated formal parameter <code>A*</code>. A wildcard star pattern <code>_*</code> in the rightmost position stands for arbitrary long sequences. It can be bound to variables using <code>@</code>, as usual, in which case the variable will have the type <code>Seq[A]</code>.</p>
<h3 id="irrefutable-patterns"><a href="#irrefutable-patterns"><span class="header-section-number">8.1.14</span> Irrefutable Patterns</a></h3>
<p>A pattern <span class="math">\(p\)</span> is <em>irrefutable</em> for a type <span class="math">\(T\)</span>, if one of the following applies:</p>
<ol>
<li><span class="math">\(p\)</span> is a variable pattern,</li>
<li><span class="math">\(p\)</span> is a typed pattern <span class="math">\(x: T&#39;\)</span>, and <span class="math">\(T &lt;: T&#39;\)</span>,</li>
<li><span class="math">\(p\)</span> is a constructor pattern <span class="math">\(c(p_1 , \ldots , p_n)\)</span>, the type <span class="math">\(T\)</span> is an instance of class <span class="math">\(c\)</span>, the <a href="#class-definitions">primary constructor</a> of type <span class="math">\(T\)</span> has argument types <span class="math">\(T_1 , \ldots , T_n\)</span>, and each <span class="math">\(p_i\)</span> is irrefutable for <span class="math">\(T_i\)</span>.</li>
</ol>
<h2 id="type-patterns"><a href="#type-patterns"><span class="header-section-number">8.2</span> Type Patterns</a></h2>
<pre class="grammar"><code>  TypePat           ::=  Type</code></pre>
<p>Type patterns consist of types, type variables, and wildcards. A type pattern <span class="math">\(T\)</span> is of one of the following forms:</p>
<ul>
<li>A reference to a class <span class="math">\(C\)</span>, <span class="math">\(p.C\)</span>, or <code>$T$#$C$</code>. This type pattern matches any non-null instance of the given class. Note that the prefix of the class, if it is given, is relevant for determining class instances. For instance, the pattern <span class="math">\(p.C\)</span> matches only instances of classes <span class="math">\(C\)</span> which were created with the path <span class="math">\(p\)</span> as prefix.</li>
</ul>
<p>The bottom types <code>scala.Nothing</code> and <code>scala.Null</code> cannot be used as type patterns, because they would match nothing in any case.</p>
<ul>
<li>A singleton type <code>$p$.type</code>. This type pattern matches only the value denoted by the path <span class="math">\(p\)</span> (that is, a pattern match involved a comparison of the matched value with <span class="math">\(p\)</span> using method <code>eq</code> in class <code>AnyRef</code>).</li>
<li><p>A compound type pattern <code>$T_1$ with $\ldots$ with $T_n$</code> where each <span class="math">\(T_i\)</span> is a type pattern. This type pattern matches all values that are matched by each of the type patterns <span class="math">\(T_i\)</span>.</p></li>
<li><p>A parameterized type pattern <span class="math">\(T[a_1 , \ldots , a_n]\)</span>, where the <span class="math">\(a_i\)</span> are type variable patterns or wildcards <span class="math">\(\_\)</span>. This type pattern matches all values which match <span class="math">\(T\)</span> for some arbitrary instantiation of the type variables and wildcards. The bounds or alias type of these type variable are determined as described <a href="#type-parameter-inference-in-patterns">here</a>.</p></li>
<li><p>A parameterized type pattern <code>scala.Array$[T_1]$</code>, where <span class="math">\(T_1\)</span> is a type pattern. This type pattern matches any non-null instance of type <code>scala.Array$[U_1]$</code>, where <span class="math">\(U_1\)</span> is a type matched by <span class="math">\(T_1\)</span>.</p></li>
</ul>
<p>Types which are not of one of the forms described above are also accepted as type patterns. However, such type patterns will be translated to their <a href="#type-erasure">erasure</a>. The Scala compiler will issue an ``unchecked'' warning for these patterns to flag the possible loss of type-safety.</p>
<p>A <em>type variable pattern</em> is a simple identifier which starts with a lower case letter. However, the predefined primitive type aliases <code>unit</code>, <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code> are not classified as type variable patterns.</p>
<h2 id="type-parameter-inference-in-patterns"><a href="#type-parameter-inference-in-patterns"><span class="header-section-number">8.3</span> Type Parameter Inference in Patterns</a></h2>
<p>Type parameter inference is the process of finding bounds for the bound type variables in a typed pattern or constructor pattern. Inference takes into account the expected type of the pattern.</p>
<p>Type parameter inference for typed patterns.<br /> Assume a typed pattern <span class="math">\(p: T&#39;\)</span>. Let <span class="math">\(T\)</span> result from <span class="math">\(T&#39;\)</span> where all wildcards in <span class="math">\(T&#39;\)</span> are renamed to fresh variable names. Let <span class="math">\(a_1 , \ldots , a_n\)</span> be the type variables in <span class="math">\(T\)</span>. These type variables are considered bound in the pattern. Let the expected type of the pattern be <span class="math">\(\mathit{pt}\)</span>.</p>
<p>Type parameter inference constructs first a set of subtype constraints over the type variables <span class="math">\(a_i\)</span>. The initial constraints set <span class="math">\(\mathcal{C}_0\)</span> reflects just the bounds of these type variables. That is, assuming <span class="math">\(T\)</span> has bound type variables <span class="math">\(a_1 , \ldots , a_n\)</span> which correspond to class type parameters <span class="math">\(a&#39;_1 , \ldots , a&#39;_n\)</span> with lower bounds <span class="math">\(L_1 , \ldots , L_n\)</span> and upper bounds <span class="math">\(U_1 , \ldots , U_n\)</span>, <span class="math">\(\mathcal{C}_0\)</span> contains the constraints</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math">\(a_i\)</span></td>
<td style="text-align: left;"><span class="math">\(&lt;:\)</span></td>
<td style="text-align: left;"><span class="math">\(\sigma U_i\)</span></td>
<td style="text-align: left;"><span class="math">\((i = 1, \ldots , n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math">\(\sigma L_i\)</span></td>
<td style="text-align: left;"><span class="math">\(&lt;:\)</span></td>
<td style="text-align: left;"><span class="math">\(a_i\)</span></td>
<td style="text-align: left;"><span class="math">\((i = 1 , \ldots , n)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math">\(\sigma\)</span> is the substitution <span class="math">\([a&#39;_1 := a_1 , \ldots , a&#39;_n := a_n]\)</span>.</p>
<p>The set <span class="math">\(\mathcal{C}_0\)</span> is then augmented by further subtype constraints. There are two cases.</p>
<p>Case 1:<br />If there exists a substitution <span class="math">\(\sigma\)</span> over the type variables <span class="math">\(a_i , \ldots , a_n\)</span> such that <span class="math">\(\sigma T\)</span> conforms to <span class="math">\(\mathit{pt}\)</span>, one determines the weakest subtype constraints <span class="math">\(\mathcal{C}_1\)</span> over the type variables <span class="math">\(a_1 , \ldots , a_n\)</span> such that <span class="math">\(\mathcal{C}_0 \wedge \mathcal{C}_1\)</span> implies that <span class="math">\(T\)</span> conforms to <span class="math">\(\mathit{pt}\)</span>.</p>
<p>Case 2:<br />Otherwise, if <span class="math">\(T\)</span> can not be made to conform to <span class="math">\(\mathit{pt}\)</span> by instantiating its type variables, one determines all type variables in <span class="math">\(\mathit{pt}\)</span> which are defined as type parameters of a method enclosing the pattern. Let the set of such type parameters be <span class="math">\(b_1 , \ldots , b_m\)</span>. Let <span class="math">\(\mathcal{C}&#39;_0\)</span> be the subtype constraints reflecting the bounds of the type variables <span class="math">\(b_i\)</span>. If <span class="math">\(T\)</span> denotes an instance type of a final class, let <span class="math">\(\mathcal{C}_2\)</span> be the weakest set of subtype constraints over the type variables <span class="math">\(a_1 , \ldots , a_n\)</span> and <span class="math">\(b_1 , \ldots , b_m\)</span> such that <span class="math">\(\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2\)</span> implies that <span class="math">\(T\)</span> conforms to <span class="math">\(\mathit{pt}\)</span>. If <span class="math">\(T\)</span> does not denote an instance type of a final class, let <span class="math">\(\mathcal{C}_2\)</span> be the weakest set of subtype constraints over the type variables <span class="math">\(a_1 , \ldots , a_n\)</span> and <span class="math">\(b_1 , \ldots , b_m\)</span> such that <span class="math">\(\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2\)</span> implies that it is possible to construct a type <span class="math">\(T&#39;\)</span> which conforms to both <span class="math">\(T\)</span> and <span class="math">\(\mathit{pt}\)</span>. It is a static error if there is no satisfiable set of constraints <span class="math">\(\mathcal{C}_2\)</span> with this property.</p>
<p>The final step consists in choosing type bounds for the type variables which imply the established constraint system. The process is different for the two cases above.</p>
<p>Case 1:<br />We take <span class="math">\(a_i &gt;: L_i &lt;: U_i\)</span> where each <span class="math">\(L_i\)</span> is minimal and each <span class="math">\(U_i\)</span> is maximal wrt <span class="math">\(&lt;:\)</span> such that <span class="math">\(a_i &gt;: L_i &lt;: U_i\)</span> for <span class="math">\(i = 1 , \ldots , n\)</span> implies <span class="math">\(\mathcal{C}_0 \wedge \mathcal{C}_1\)</span>.</p>
<p>Case 2:<br />We take <span class="math">\(a_i &gt;: L_i &lt;: U_i\)</span> and <span class="math">\(b_i &gt;: L&#39;_i &lt;: U&#39;_i\)</span> where each <span class="math">\(L_i\)</span> and <span class="math">\(L&#39;_j\)</span> is minimal and each <span class="math">\(U_i\)</span> and <span class="math">\(U&#39;_j\)</span> is maximal such that <span class="math">\(a_i &gt;: L_i &lt;: U_i\)</span> for <span class="math">\(i = 1 , \ldots , n\)</span> and <span class="math">\(b_j &gt;: L&#39;_j &lt;: U&#39;_j\)</span> for <span class="math">\(j = 1 , \ldots , m\)</span> implies <span class="math">\(\mathcal{C}_0 \wedge \mathcal{C}&#39;_0 \wedge \mathcal{C}_2\)</span>.</p>
<p>In both cases, local type inference is permitted to limit the complexity of inferred bounds. Minimality and maximality of types have to be understood relative to the set of types of acceptable complexity.</p>
<p>Type parameter inference for constructor patterns.<br />Assume a constructor pattern <span class="math">\(C(p_1 , \ldots , p_n)\)</span> where class <span class="math">\(C\)</span> has type type parameters <span class="math">\(a_1 , \ldots , a_n\)</span>. These type parameters are inferred in the same way as for the typed pattern <code>(_: $C[a_1 , \ldots , a_n]$)</code>.</p>
<ol start="79" type="1">
<li><p>Consider the program fragment:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: Any
x <span class="kw">match</span> {
  <span class="kw">case</span> y: List[a] =&gt; ...
}</code></pre>
<p>Here, the type pattern <code>List[a]</code> is matched against the expected type <code>Any</code>. The pattern binds the type variable <code>a</code>. Since <code>List[a]</code> conforms to <code>Any</code> for every type argument, there are no constraints on <code>a</code>. Hence, <code>a</code> is introduced as an abstract type with no bounds. The scope of <code>a</code> is right-hand side of its case clause.</p>
<p>On the other hand, if <code>x</code> is declared as</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: List[List[String]],</code></pre>
<p>this generates the constraint <code>List[a] &lt;: List[List[String]]</code>, which simplifies to <code>a &lt;: List[String]</code>, because <code>List</code> is covariant. Hence, <code>a</code> is introduced with upper bound <code>List[String]</code>.</p></li>
<li><p>Consider the program fragment:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x: Any
x <span class="kw">match</span> {
  <span class="kw">case</span> y: List[String] =&gt; ...
}</code></pre>
<p>Scala does not maintain information about type arguments at run-time, so there is no way to check that <code>x</code> is a list of strings. Instead, the Scala compiler will <a href="#type-erasure">erase</a> the pattern to <code>List[_]</code>; that is, it will only test whether the top-level runtime-class of the value <code>x</code> conforms to <code>List</code>, and the pattern match will succeed if it does. This might lead to a class cast exception later on, in the case where the list <code>x</code> contains elements other than strings. The Scala compiler will flag this potential loss of type-safety with an ``unchecked'' warning message.</p></li>
<li><p>Consider the program fragment</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Term[A]
<span class="kw">class</span> Number(<span class="kw">val</span> n: Int) <span class="kw">extends</span> Term[Int]
<span class="kw">def</span> f[B](t: Term[B]): B = t <span class="kw">match</span> {
  <span class="kw">case</span> y: Number =&gt; y.<span class="fu">n</span>
}</code></pre>
<p>The expected type of the pattern <code>y: Number</code> is <code>Term[B]</code>. The type <code>Number</code> does not conform to <code>Term[B]</code>; hence Case 2 of the rules above applies. This means that <code>b</code> is treated as another type variable for which subtype constraints are inferred. In our case the applicable constraint is <code>Number &lt;: Term[B]</code>, which entails <code>B = Int</code>. Hence, <code>B</code> is treated in the case clause as an abstract type with lower and upper bound <code>Int</code>. Therefore, the right hand side of the case clause, <code>y.n</code>, of type <code>Int</code>, is found to conform to the function's declared result type, <code>Number</code>.</p></li>
</ol>
<h2 id="pattern-matching-expressions"><a href="#pattern-matching-expressions"><span class="header-section-number">8.4</span> Pattern Matching Expressions</a></h2>
<pre class="grammar"><code>  Expr            ::=  PostfixExpr `match&#39; `{&#39; CaseClauses `}&#39;
  CaseClauses     ::=  CaseClause {CaseClause}
  CaseClause      ::=  `case&#39; Pattern [Guard] `=&gt;&#39; Block</code></pre>
<p>A pattern matching expression</p>
<pre class="sourceCode scala"><code class="sourceCode scala">e <span class="kw">match</span> { <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ }</code></pre>
<p>consists of a selector expression <span class="math">\(e\)</span> and a number <span class="math">\(n &gt; 0\)</span> of cases. Each case consists of a (possibly guarded) pattern <span class="math">\(p_i\)</span> and a block <span class="math">\(b_i\)</span>. Each <span class="math">\(p_i\)</span> might be complemented by a guard <code>if $e$</code> where <span class="math">\(e\)</span> is a boolean expression. The scope of the pattern variables in <span class="math">\(p_i\)</span> comprises the pattern's guard and the corresponding block <span class="math">\(b_i\)</span>.</p>
<p>Let <span class="math">\(T\)</span> be the type of the selector expression <span class="math">\(e\)</span> and let <span class="math">\(a_1 , \ldots , a_m\)</span> be the type parameters of all methods enclosing the pattern matching expression. For every <span class="math">\(a_i\)</span>, let <span class="math">\(L_i\)</span> be its lower bound and <span class="math">\(U_i\)</span> be its higher bound. Every pattern <span class="math">\(p \in \{p_1, , \ldots , p_n\}\)</span> can be typed in two ways. First, it is attempted to type <span class="math">\(p\)</span> with <span class="math">\(T\)</span> as its expected type. If this fails, <span class="math">\(p\)</span> is instead typed with a modified expected type <span class="math">\(T&#39;\)</span> which results from <span class="math">\(T\)</span> by replacing every occurrence of a type parameter <span class="math">\(a_i\)</span> by . If this second step fails also, a compile-time error results. If the second step succeeds, let <span class="math">\(T_p\)</span> be the type of pattern <span class="math">\(p\)</span> seen as an expression. One then determines minimal bounds <span class="math">\(L&#39;_1 , \ldots , L&#39;_m\)</span> and maximal bounds <span class="math">\(U&#39;_1 , \ldots , U&#39;_m\)</span> such that for all <span class="math">\(i\)</span>, <span class="math">\(L_i &lt;: L&#39;_i\)</span> and <span class="math">\(U&#39;_i &lt;: U_i\)</span> and the following constraint system is satisfied:</p>
<p><span class="math">\[L_1 &lt;: a_1 &lt;: U_1\;\wedge\;\ldots\;\wedge\;L_m &lt;: a_m &lt;: U_m \ \Rightarrow\ T_p &lt;: T\]</span></p>
<p>If no such bounds can be found, a compile time error results. If such bounds are found, the pattern matching clause starting with <span class="math">\(p\)</span> is then typed under the assumption that each <span class="math">\(a_i\)</span> has lower bound <span class="math">\(L&#39;_i\)</span> instead of <span class="math">\(L_i\)</span> and has upper bound <span class="math">\(U&#39;_i\)</span> instead of <span class="math">\(U_i\)</span>.</p>
<p>The expected type of every block <span class="math">\(b_i\)</span> is the expected type of the whole pattern matching expression. The type of the pattern matching expression is then the <a href="#weak-conformance">weak least upper bound</a> of the types of all blocks <span class="math">\(b_i\)</span>.</p>
<p>When applying a pattern matching expression to a selector value, patterns are tried in sequence until one is found which matches the <a href="#patterns">selector value</a>. Say this case is <span class="math">\(\mathbf{case} p_i \Rightarrow b_i\)</span>. The result of the whole expression is then the result of evaluating <span class="math">\(b_i\)</span>, where all pattern variables of <span class="math">\(p_i\)</span> are bound to the corresponding parts of the selector value. If no matching pattern is found, a <code>scala.MatchError</code> exception is thrown.</p>
<p>The pattern in a case may also be followed by a guard suffix<br /><code>if e</code> with a boolean expression <span class="math">\(e\)</span>. The guard expression is evaluated if the preceding pattern in the case matches. If the guard expression evaluates to <code>true</code>, the pattern match succeeds as normal. If the guard expression evaluates to <code>false</code>, the pattern in the case is considered not to match and the search for a matching pattern continues.</p>
<p>In the interest of efficiency the evaluation of a pattern matching expression may try patterns in some other order than textual sequence. This might affect evaluation through side effects in guards. However, it is guaranteed that a guard expression is evaluated only if the pattern it guards matches.</p>
<p>If the selector of a pattern match is an instance of a <a href="#modifiers"><code>sealed</code> class</a>, the compilation of pattern matching can emit warnings which diagnose that a given set of patterns is not exhaustive, i.e. that there is a possibility of a <code>MatchError</code> being raised at run-time.</p>
<ol start="82" type="1">
<li><p>Consider the following definitions of arithmetic terms:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> Term[T]
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Lit</span>(x: Int) <span class="kw">extends</span> Term[Int]
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Succ</span>(t: Term[Int]) <span class="kw">extends</span> Term[Int]
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">IsZero</span>(t: Term[Int]) <span class="kw">extends</span> Term[Boolean]
<span class="kw">case</span> <span class="kw">class</span> If[T](c: Term[Boolean],
                 t1: Term[T],
                 t2: Term[T]) <span class="kw">extends</span> Term[T]</code></pre>
<p>There are terms to represent numeric literals, incrementation, a zero test, and a conditional. Every term carries as a type parameter the type of the expression it representes (either <code>Int</code> or <code>Boolean</code>).</p>
<p>A type-safe evaluator for such terms can be written as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> eval[T](t: Term[T]): T = t <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">Lit</span>(n)        =&gt; n
  <span class="kw">case</span> <span class="fu">Succ</span>(u)       =&gt; <span class="fu">eval</span>(u) + <span class="dv">1</span>
  <span class="kw">case</span> <span class="fu">IsZero</span>(u)     =&gt; <span class="fu">eval</span>(u) == <span class="dv">0</span>
  <span class="kw">case</span> <span class="fu">If</span>(c, u1, u2) =&gt; <span class="fu">eval</span>(<span class="kw">if</span> (<span class="fu">eval</span>(c)) u1 <span class="kw">else</span> u2)
}</code></pre>
<p>Note that the evaluator makes crucial use of the fact that type parameters of enclosing methods can acquire new bounds through pattern matching.</p>
<p>For instance, the type of the pattern in the second case, <code>Succ(u)</code>, is <code>Int</code>. It conforms to the selector type <code>T</code> only if we assume an upper and lower bound of <code>Int</code> for <code>T</code>. Under the assumption <code>Int &lt;: T &lt;: Int</code> we can also verify that the type right hand side of the second case, <code>Int</code> conforms to its expected type, <code>T</code>.</p></li>
</ol>
<h2 id="pattern-matching-anonymous-functions"><a href="#pattern-matching-anonymous-functions"><span class="header-section-number">8.5</span> Pattern Matching Anonymous Functions</a></h2>
<pre class="grammar"><code>  BlockExpr ::= `{&#39; CaseClauses `}&#39;</code></pre>
<p>An anonymous function can be defined by a sequence of cases</p>
<pre class="sourceCode scala"><code class="sourceCode scala">{ <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ }</code></pre>
<p>which appear as an expression without a prior <code>match</code>. The expected type of such an expression must in part be defined. It must be either <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code> for some <span class="math">\(k &gt; 0\)</span>, or <code>scala.PartialFunction[$S_1$, $R$]</code>, where the argument type(s) <span class="math">\(S_1 , \ldots , S_k\)</span> must be fully determined, but the result type <span class="math">\(R\)</span> may be undetermined.</p>
<p>If the expected type is <code>scala.Function$k$[$S_1 , \ldots , S_k$, $R$]</code>, the expression is taken to be equivalent to the anonymous function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">($x_1: S_1 , \ldots , x_k: S_k$) =&gt; ($x_1 , \ldots , x_k$) <span class="kw">match</span> { 
  <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$ 
}</code></pre>
<p>Here, each <span class="math">\(x_i\)</span> is a fresh name. As was shown <a href="#anonymous-functions">here</a>, this anonymous function is in turn equivalent to the following instance creation expression, where <span class="math">\(T\)</span> is the weak least upper bound of the types of all <span class="math">\(b_i\)</span>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> scala.<span class="fu">Function</span>$k$[$S_1 , \ldots , S_k$, $T$] {
  <span class="kw">def</span> <span class="fu">apply</span>($x_1: S_1 , \ldots , x_k: S_k$): $T$ = ($x_1 , \ldots , x_k$) <span class="kw">match</span> {
    <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$
  }
}</code></pre>
<p>If the expected type is <code>scala.PartialFunction[$S$, $R$]</code>, the expression is taken to be equivalent to the following instance creation expression:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">new</span> scala.<span class="fu">PartialFunction</span>[$S$, $T$] {
  <span class="kw">def</span> <span class="fu">apply</span>($x$: $S$): $T$ = x <span class="kw">match</span> {
    <span class="kw">case</span> $p_1$ =&gt; $b_1$ $\ldots$ <span class="kw">case</span> $p_n$ =&gt; $b_n$
  }
  <span class="kw">def</span> <span class="fu">isDefinedAt</span>($x$: $S$): Boolean = {
    <span class="kw">case</span> $p_1$ =&gt; <span class="kw">true</span> $\ldots$ <span class="kw">case</span> $p_n$ =&gt; <span class="kw">true</span>
    <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
  }
}</code></pre>
<p>Here, <span class="math">\(x\)</span> is a fresh name and <span class="math">\(T\)</span> is the weak least upper bound of the types of all <span class="math">\(b_i\)</span>. The final default case in the <code>isDefinedAt</code> method is omitted if one of the patterns <span class="math">\(p_1 , \ldots , p_n\)</span> is already a variable or wildcard pattern.</p>
<ol start="83" type="1">
<li><p>Here is a method which uses a fold-left operation <code>/:</code> to compute the scalar product of two vectors:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">scalarProduct</span>(xs: Array[Double], ys: Array[Double]) = 
  (<span class="fl">0.0</span> /: (xs zip ys)) {
    <span class="kw">case</span> (a, (b, c)) =&gt; a + b * c
  }</code></pre>
<p>The case clauses in this code are equivalent to the following anonymous function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  (x, y) =&gt; (x, y) <span class="kw">match</span> {
    <span class="kw">case</span> (a, (b, c)) =&gt; a + b * c
  }</code></pre></li>
</ol>
<h1 id="top-level-definitions"><a href="#top-level-definitions"><span class="header-section-number">9</span> Top-Level Definitions</a></h1>
<h2 id="compilation-units"><a href="#compilation-units"><span class="header-section-number">9.1</span> Compilation Units</a></h2>
<pre class="grammar"><code>CompilationUnit  ::=  {‘package’ QualId semi} TopStatSeq
TopStatSeq       ::=  TopStat {semi TopStat}
TopStat          ::=  {Annotation} {Modifier} TmplDef
                   |  Import
                   |  Packaging
                   |  PackageObject
                   |
QualId           ::=  id {‘.’ id}</code></pre>
<p>A compilation unit consists of a sequence of packagings, import clauses, and class and object definitions, which may be preceded by a package clause.</p>
<p>A compilation unit</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> $p_1$;
$\ldots$
<span class="kw">package</span> $p_n$;
$\mathit{stats}$</code></pre>
<p>starting with one or more package clauses is equivalent to a compilation unit consisting of the packaging</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> $p_1$ { $\ldots$
  <span class="kw">package</span> $p_n$ {
    $\mathit{stats}$
  } $\ldots$
}</code></pre>
<p>Implicitly imported into every compilation unit are, in that order : the package <code>java.lang</code>, the package <code>scala</code>, and the object <a href="#the-predef-object"><code>scala.Predef</code></a>. Members of a later import in that order hide members of an earlier import.</p>
<h2 id="packagings"><a href="#packagings"><span class="header-section-number">9.2</span> Packagings</a></h2>
<pre class="grammar"><code>Packaging       ::=  ‘package’ QualId [nl] ‘{’ TopStatSeq ‘}’</code></pre>
<p>A package is a special object which defines a set of member classes, objects and packages. Unlike other objects, packages are not introduced by a definition. Instead, the set of members of a package is determined by packagings.</p>
<p>A packaging <code class="sourceCode scala"><span class="kw">package</span> $p$ { $\mathit{ds}$ }</code> injects all definitions in <span class="math">\(\mathit{ds}\)</span> as members into the package whose qualified name is <span class="math">\(p\)</span>. Members of a package are called <em>top-level</em> definitions. If a definition in <span class="math">\(\mathit{ds}\)</span> is labeled <code class="sourceCode scala"><span class="kw">private</span></code>, it is visible only for other members in the package.</p>
<p>Inside the packaging, all members of package <span class="math">\(p\)</span> are visible under their simple names. However this rule does not extend to members of enclosing packages of <span class="math">\(p\)</span> that are designated by a prefix of the path <span class="math">\(p\)</span>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> org.<span class="fu">net</span>.<span class="fu">prj</span> {
  ...
}</code></pre>
<p>all members of package <code>org.net.prj</code> are visible under their simple names, but members of packages <code>org</code> or <code>org.net</code> require explicit qualification or imports.</p>
<p>Selections <span class="math">\(p\)</span>.<span class="math">\(m\)</span> from <span class="math">\(p\)</span> as well as imports from <span class="math">\(p\)</span> work as for objects. However, unlike other objects, packages may not be used as values. It is illegal to have a package with the same fully qualified name as a module or a class.</p>
<p>Top-level definitions outside a packaging are assumed to be injected into a special empty package. That package cannot be named and therefore cannot be imported. However, members of the empty package are visible to each other without qualification.</p>
<h2 id="package-objects"><a href="#package-objects"><span class="header-section-number">9.3</span> Package Objects</a></h2>
<pre class="grammar"><code>PackageObject   ::=  ‘package’ ‘object’ ObjectDef</code></pre>
<p>A package object <code>package object $p$ extends $t$</code> adds the members of template <span class="math">\(t\)</span> to the package <span class="math">\(p\)</span>. There can be only one package object per package. The standard naming convention is to place the definition above in a file named <code>package.scala</code> that's located in the directory corresponding to package <span class="math">\(p\)</span>.</p>
<p>The package object should not define a member with the same name as one of the top-level objects or classes defined in package <span class="math">\(p\)</span>. If there is a name conflict, the behavior of the program is currently undefined. It is expected that this restriction will be lifted in a future version of Scala.</p>
<h2 id="package-references"><a href="#package-references"><span class="header-section-number">9.4</span> Package References</a></h2>
<pre class="grammar"><code>QualId           ::=  id {‘.’ id}</code></pre>
<p>A reference to a package takes the form of a qualified identifier. Like all other references, package references are relative. That is, a package reference starting in a name <span class="math">\(p\)</span> will be looked up in the closest enclosing scope that defines a member named <span class="math">\(p\)</span>.</p>
<p>The special predefined name <code>_root_</code> refers to the outermost root package which contains all top-level packages.</p>
<ol start="84" type="1">
<li><p>Consider the following program:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> b {
  <span class="kw">class</span> B 
}

<span class="kw">package</span> a.<span class="fu">b</span> {
  <span class="kw">class</span> A {
    <span class="kw">val</span> x = <span class="kw">new</span> _root_.<span class="fu">b</span>.<span class="fu">B</span>
  }
}</code></pre>
<p>Here, the reference <code>_root_.b.B</code> refers to class <code>B</code> in the toplevel package <code>b</code>. If the <code>_root_</code> prefix had been omitted, the name <code>b</code> would instead resolve to the package <code>a.b</code>, and, provided that package does not also contain a class <code>B</code>, a compiler-time error would result.</p></li>
</ol>
<h2 id="programs"><a href="#programs"><span class="header-section-number">9.5</span> Programs</a></h2>
<p>A <em>program</em> is a top-level object that has a member method <em>main</em> of type <code>(Array[String])Unit</code>. Programs can be executed from a command shell. The program's command arguments are are passed to the <code>main</code> method as a parameter of type <code>Array[String]</code>.</p>
<p>The <code>main</code> method of a program can be directly defined in the object, or it can be inherited. The scala library defines a class <code>scala.Application</code> that defines an empty inherited <code>main</code> method. An objects <span class="math">\(m\)</span> inheriting from this class is thus a program, which executes the initializaton code of the object <span class="math">\(m\)</span>.</p>
<ol start="85" type="1">
<li><p>The following example will create a hello world program by defining a method <code>main</code> in module <code>test.HelloWorld</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> test
<span class="kw">object</span> HelloWord {
  <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) { <span class="fu">println</span>(<span class="st">&quot;hello world&quot;</span>) }
}</code></pre>
<p>This program can be started by the command ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scala test.HelloWorld ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>In a Java environment, the command</p>
<pre><code>java test.HelloWorld</code></pre>
<p>would work as well.</p>
<p><code>HelloWorld</code> can also be defined without a <code>main</code> method by inheriting from <code>Application</code> instead:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> test 
<span class="kw">object</span> HelloWord <span class="kw">extends</span> Application {
  <span class="fu">println</span>(<span class="st">&quot;hello world&quot;</span>)
}</code></pre></li>
</ol>
<h1 id="xml-expressions-and-patterns"><a href="#xml-expressions-and-patterns"><span class="header-section-number">10</span> XML Expressions and Patterns</a></h1>
<p><strong>By Burak Emir</strong><br /> This chapter describes the syntactic structure of XML expressions and patterns. It follows as closely as possible the XML 1.0 specification , changes being mandated by the possibility of embedding Scala code fragments.</p>
<h2 id="xml-expressions"><a href="#xml-expressions"><span class="header-section-number">10.1</span> XML expressions</a></h2>
<p>XML expressions are expressions generated by the following production, where the opening bracket `&lt;' of the first element must be in a position to start the lexical <a href="#xml-mode">XML mode</a>.</p>
<pre class="grammar"><code>XmlExpr ::= XmlContent {Element}</code></pre>
<p>Well-formedness constraints of the XML specification apply, which means for instance that start tags and end tags must match, and attributes may only be defined once, with the exception of constraints related to entity resolution.</p>
<p>The following productions describe Scala's extensible markup language, designed as close as possible to the W3C extensible markup language standard. Only the productions for attribute values and character data are changed. Scala does not support declarations, CDATA sections or processing instructions. Entity references are not resolved at runtime.</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.grammar} Element ::= EmptyElemTag | STag Content ETag</p>
<p>EmptyElemTag ::= ‘&lt;’ Name {S Attribute} [S] ‘/&gt;’</p>
<p>STag ::= ‘&lt;’ Name {S Attribute} [S] ‘&gt;’<br />ETag ::= ‘<!--’ Name [S] ‘-->'{CharNoRef} ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>XML expressions may contain Scala expressions as attribute values or within nodes. In the latter case, these are embedded using a single opening brace ‘{’ and ended by a closing brace ‘}’. To express a single opening braces within XML text as generated by CharData, it must be doubled. Thus, ‘{{’ represents the XML text ‘{’ and does not introduce an embedded Scala expression.</p>
<pre class="grammar"><code>BaseChar, Char, Comment, CombiningChar, Ideographic, NameChar, S, Reference
              ::=  $\mbox{\rm\em “as in W3C XML”}$

Char1         ::=  Char $\mbox{\rm\em without}$ ‘&lt;’ | ‘&amp;’
CharQ         ::=  Char1 $\mbox{\rm\em without}$ ‘&quot;’
CharA         ::=  Char1 $\mbox{\rm\em without}$ ‘&#39;’
CharB         ::=  Char1 $\mbox{\rm\em without}$ ‘{’

Name          ::=  XNameStart {NameChar}

XNameStart    ::= ‘_’ | BaseChar | Ideographic 
                 $\mbox{\rm\em (as in W3C XML, but without }$ ‘:’
</code></pre>
<h2 id="xml-patterns-1"><a href="#xml-patterns-1"><span class="header-section-number">10.2</span> XML patterns</a></h2>
<p>XML patterns are patterns generated by the following production, where the opening bracket ‘&lt;’ of the element patterns must be in a position to start the lexical <a href="#xml-mode">XML mode</a>.</p>
<pre class="grammar"><code>XmlPattern  ::= ElementPattern </code></pre>
<p>Well-formedness constraints of the XML specification apply.</p>
<p>An XML pattern has to be a single element pattern. It matches exactly those runtime representations of an XML tree that have the same structure as described by the pattern. XML patterns may contain <a href="#pattern-matching-expressions">Scala patterns</a>.</p>
<p>Whitespace is treated the same way as in XML expressions. Patterns that are entity references, CDATA sections, processing instructions and comments match runtime representations which are the the same.</p>
<p>By default, beginning and trailing whitespace in element content is removed, and consecutive occurrences of whitespace are replaced by a single space character \u0020. This behavior can be changed to preserve all whitespace with a compiler option.</p>
<pre class="grammar"><code>ElemPattern   ::=    EmptyElemTagP
                |    STagP ContentP ETagP                                    

EmptyElemTagP ::=    ‘&lt;’  Name [S] ‘/&gt;’
STagP         ::=    ‘&lt;’  Name [S] ‘&gt;’                          
ETagP         ::=    ‘&lt;/’ Name [S] ‘&gt;’                                        
ContentP      ::=    [CharData] {(ElemPattern|ScalaPatterns) [CharData]}
ContentP1     ::=    ElemPattern
                |    Reference
                |    CDSect
                |    PI
                |    Comment
                |    ScalaPatterns
ScalaPatterns ::=    ‘{’ Patterns ‘}’</code></pre>
<h1 id="user-defined-annotations"><a href="#user-defined-annotations"><span class="header-section-number">11</span> User-Defined Annotations</a></h1>
<pre class="grammar"><code>  Annotation       ::=  ‘@’ SimpleType {ArgumentExprs}
  ConstrAnnotation ::=  ‘@’ SimpleType ArgumentExprs</code></pre>
<p>User-defined annotations associate meta-information with definitions. A simple annotation has the form <code>@$c$</code> or <code>@$c(a_1 , \ldots , a_n)$</code>. Here, <span class="math">\(c\)</span> is a constructor of a class <span class="math">\(C\)</span>, which must conform to the class <code>scala.Annotation</code>.</p>
<p>Annotations may apply to definitions or declarations, types, or expressions. An annotation of a definition or declaration appears in front of that definition. An annotation of a type appears after that type. An annotation of an expression <span class="math">\(e\)</span> appears after the expression <span class="math">\(e\)</span>, separated by a colon. More than one annotation clause may apply to an entity. The order in which these annotations are given does not matter.</p>
<p>Examples:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">@serializable <span class="kw">class</span> C { ... }         <span class="co">// A class annotation.</span>
@transient @volatile <span class="kw">var</span> m: Int       <span class="co">// A variable annotation</span>
String @local                         <span class="co">// A type annotation</span>
(e: @unchecked) <span class="kw">match</span> { ... }         <span class="co">// An expression annotation</span></code></pre>
<p>The meaning of annotation clauses is implementation-dependent. On the Java platform, the following annotations have a standard meaning.</p>
<ul>
<li><p><code>@transient</code><br /> Marks a field to be non-persistent; this is equivalent to the <code>transient</code> modifier in Java.</p></li>
<li><p><code>@volatile</code><br /> Marks a field which can change its value outside the control of the program; this is equivalent to the <code>volatile</code> modifier in Java.</p></li>
<li><p><code>@serializable</code><br /> Marks a class to be serializable; this is equivalent to inheriting from the <code>java.io.Serializable</code> interface in Java.</p></li>
<li><p><code>@SerialVersionUID(&lt;longlit&gt;)</code><br /> Attaches a serial version identifier (a <code>long</code> constant) to a class. This is equivalent to a the following field definition in Java:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">private</span> <span class="kw">final</span> static SerialVersionUID = &lt;longlit&gt; </code></pre></li>
<li><p><code>@throws(&lt;classlit&gt;)</code><br /> A Java compiler checks that a program contains handlers for checked exceptions by analyzing which checked exceptions can result from execution of a method or constructor. For each checked exception which is a possible result, the <code>throws</code> clause for the method or constructor must mention the class of that exception or one of the superclasses of the class of that exception.</p></li>
<li><p><code>@deprecated(&lt;stringlit&gt;)</code><br /> Marks a definition as deprecated. Accesses to the defined entity will then cause a deprecated warning mentioning the message <code>&lt;stringlit&gt;</code> to be issued from the compiler. Deprecated warnings are suppressed in code that belongs itself to a definition that is labeled deprecated.</p></li>
<li><p><code>@scala.reflect.BeanProperty</code><br /> When prefixed to a definition of some variable <code>X</code>, this annotation causes getter and setter methods <code>getX</code>, <code>setX</code> in the Java bean style to be added in the class containing the variable. The first letter of the variable appears capitalized after the <code>get</code> or <code>set</code>. When the annotation is added to the definition of an immutable value definition <code>X</code>, only a getter is generated. The construction of these methods is part of code-generation; therefore, these methods become visible only once a classfile for the containing class is generated.</p></li>
<li><p><code>@scala.reflect.BooleanBeanProperty</code><br /> This annotation is equivalent to <code>scala.reflect.BeanProperty</code>, but the generated getter method is named <code>isX</code> instead of <code>getX</code>.</p></li>
<li><p><code>@unchecked</code><br /> When applied to the selector of a <code>match</code> expression, this attribute suppresses any warnings about non-exhaustive pattern matches which would otherwise be emitted. For instance, no warnings would be produced for the method definition below.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">f</span>(x: Option[Int]) = (x: @unchecked) <span class="kw">match</span> {
  <span class="kw">case</span> Some(y) =&gt; y
}</code></pre>
<p>Without the <code>@unchecked</code> annotation, a Scala compiler could infer that the pattern match is non-exhaustive, and could produce a warning because <code>Option</code> is a <code>sealed</code> class.</p></li>
<li><p><code>@uncheckedStable</code><br /> When applied a value declaration or definition, it allows the defined value to appear in a path, even if its type is <a href="#volatile-types">volatile</a>. For instance, the following member definitions are legal:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> A { <span class="kw">type</span> T }
<span class="kw">type</span> B 
@uncheckedStable <span class="kw">val</span> x: A <span class="kw">with</span> B <span class="co">// volatile type </span>
<span class="kw">val</span> y: x.<span class="fu">T</span>                       <span class="co">// OK since `x&#39; is still a path</span></code></pre>
<p>Without the <code>@uncheckedStable</code> annotation, the designator <code>x</code> would not be a path since its type <code>A with B</code> is volatile. Hence, the reference <code>x.T</code> would be malformed.</p>
<p>When applied to value declarations or definitions that have non-volatile types, the annotation has no effect.</p></li>
<li><p><code>@specialized</code><br /> When applied to the definition of a type parameter, this annotation causes the compiler to generate specialized definitions for primitive types. An optional list of primitive types may be given, in which case specialization takes into account only those types. For instance, the following code would generate specialized traits for <code>Unit</code>, <code>Int</code> and <code>Double</code></p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Function0[@<span class="fu">specialized</span>(Unit, Int, Double) T] {
  <span class="kw">def</span> apply: T
}</code></pre>
<p>Whenever the static type of an expression matches a specialized variant of a definition, the compiler will instead use the specialized version. See  for more details of the implementation.</p></li>
</ul>
<p>Other annotations may be interpreted by platform- or application-dependent tools. Class <code>scala.Annotation</code> has two sub-traits which are used to indicate how these annotations are retained. Instances of an annotation class inheriting from trait <code>scala.ClassfileAnnotation</code> will be stored in the generated class files. Instances of an annotation class inheriting from trait <code>scala.StaticAnnotation</code> will be visible to the Scala type-checker in every compilation unit where the annotated symbol is accessed. An annotation class can inherit from both <code>scala.ClassfileAnnotation</code> and <code>scala.StaticAnnotation</code>. If an annotation class inherits from neither <code>scala.ClassfileAnnotation</code> nor <code>scala.StaticAnnotation</code>, its instances are visible only locally during the compilation run that analyzes them.</p>
<p>Classes inheriting from <code>scala.ClassfileAnnotation</code> may be subject to further restrictions in order to assure that they can be mapped to the host environment. In particular, on both the Java and the .NET platforms, such classes must be toplevel; i.e. they may not be contained in another class or object. Additionally, on both Java and .NET, all constructor arguments must be constant expressions.</p>
<h1 id="the-scala-standard-library"><a href="#the-scala-standard-library"><span class="header-section-number">12</span> The Scala Standard Library</a></h1>
<p>The Scala standard library consists of the package <code>scala</code> with a number of classes and modules. Some of these classes are described in the following.</p>
<figure>
<embed src="resources/classhierarchy.pdf" /><figcaption>Class hierarchy of Scala</figcaption>
</figure>
<h2 id="root-classes"><a href="#root-classes"><span class="header-section-number">12.1</span> Root Classes</a></h2>
<p>Figure~ illustrates Scala's class hierarchy. The root of this hierarchy is formed by class <code>Any</code>. Every class in a Scala execution environment inherits directly or indirectly from this class. Class <code>Any</code> has two direct subclasses: <code>AnyRef</code> and AnyVal`.</p>
<p>The subclass <code>AnyRef</code> represents all values which are represented as objects in the underlying host system. Every user-defined Scala class inherits directly or indirectly from this class. Furthermore, every user-defined Scala class also inherits the trait <code>scala.ScalaObject</code>. Classes written in other languages still inherit from <code>scala.AnyRef</code>, but not from <code>scala.ScalaObject</code>.</p>
<p>The class <code>AnyVal</code> has a fixed number of subclasses, which describe values which are not implemented as objects in the underlying host system.</p>
<p>Classes <code>AnyRef</code> and <code>AnyVal</code> are required to provide only the members declared in class <code>Any</code>, but implementations may add host-specific methods to these classes (for instance, an implementation may identify class <code>AnyRef</code> with its own root class for objects).</p>
<p>The signatures of these root classes are described by the following definitions.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="co">/** The universal root class */</span>
<span class="kw">abstract</span> <span class="kw">class</span> Any {

  <span class="co">/** Defined equality; abstract here */</span>
  <span class="kw">def</span> <span class="fu">equals</span>(that: Any): Boolean 

  <span class="co">/** Semantic equality between values */</span>
  <span class="kw">final</span> <span class="kw">def</span> == (that: Any): Boolean  =  
    <span class="kw">if</span> (<span class="kw">null</span> eq <span class="kw">this</span>) <span class="kw">null</span> eq that <span class="kw">else</span> <span class="kw">this</span> equals that

  <span class="co">/** Semantic inequality between values */</span>
  <span class="kw">final</span> <span class="kw">def</span> != (that: Any): Boolean  =  !(<span class="kw">this</span> == that)

  <span class="co">/** Hash code; abstract here */</span>
  <span class="kw">def</span> hashCode: Int = $\ldots$

  <span class="co">/** Textual representation; abstract here */</span>
  <span class="kw">def</span> toString: String = $\ldots$

  <span class="co">/** Type test; needs to be inlined to work as given */</span>
  <span class="kw">def</span> isInstanceOf[a]: Boolean

  <span class="co">/** Type cast; needs to be inlined to work as given */</span> */
  <span class="kw">def</span> asInstanceOf[A]: A = <span class="kw">this</span> <span class="kw">match</span> {
    <span class="kw">case</span> x: A =&gt; x
    <span class="kw">case</span> _ =&gt; <span class="kw">if</span> (<span class="kw">this</span> eq <span class="kw">null</span>) <span class="kw">this</span>
              <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> ClassCastException()
  }
}

<span class="co">/** The root class of all value types */</span>
<span class="kw">final</span> <span class="kw">class</span> AnyVal <span class="kw">extends</span> Any 

<span class="co">/** The root class of all reference types */</span>
<span class="kw">class</span> AnyRef <span class="kw">extends</span> Any {
  <span class="kw">def</span> <span class="fu">equals</span>(that: Any): Boolean      = <span class="kw">this</span> eq that 
  <span class="kw">final</span> <span class="kw">def</span> <span class="fu">eq</span>(that: AnyRef): Boolean = $\ldots$ <span class="co">// reference equality</span>
  <span class="kw">final</span> <span class="kw">def</span> <span class="fu">ne</span>(that: AnyRef): Boolean = !(<span class="kw">this</span> eq that)

  <span class="kw">def</span> hashCode: Int = $\ldots$     <span class="co">// hashCode computed from allocation address</span>
  <span class="kw">def</span> toString: String  = $\ldots$ <span class="co">// toString computed from hashCode and class name</span>

  <span class="kw">def</span> synchronized[T](body: =&gt; T): T <span class="co">// execute `body` in while locking `this`.</span>
}                           

<span class="co">/** A mixin class for every user-defined Scala class */</span>
<span class="kw">trait</span> ScalaObject <span class="kw">extends</span> AnyRef </code></pre>
<p>The type test <code>$x$.isInstanceOf[$T$]</code> is equivalent to a typed pattern match</p>
<pre class="sourceCode scala"><code class="sourceCode scala">$x$ <span class="kw">match</span> {
  <span class="kw">case</span> _: $T&#39;$ =&gt; <span class="kw">true</span>
  <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
}</code></pre>
<p>where the type <span class="math">\(T&#39;\)</span> is the same as <span class="math">\(T\)</span> except if <span class="math">\(T\)</span> is of the form <span class="math">\(D\)</span> or <span class="math">\(D[\mathit{tps}]\)</span> where <span class="math">\(D\)</span> is a type member of some outer class <span class="math">\(C\)</span>. In this case <span class="math">\(T&#39;\)</span> is <code>$C$#$D$</code> (or <code>$C$#$D[tps]$</code>, respectively), whereas <span class="math">\(T\)</span> itself would expand to <code>$C$.this.$D[tps]$</code>. In other words, an <code>isInstanceOf</code> test does not check for the</p>
<p>The test <code>$x$.asInstanceOf[$T$]</code> is treated specially if <span class="math">\(T\)</span> is a <a href="#value-classes">numeric value type</a>. In this case the cast will be translated to an application of a <a href="#numeric-value-types">conversion method</a> <code>x.to$T$</code>. For non-numeric values <span class="math">\(x\)</span> the operation will raise a <code>ClassCastException</code>.</p>
<h2 id="value-classes"><a href="#value-classes"><span class="header-section-number">12.2</span> Value Classes</a></h2>
<p>Value classes are classes whose instances are not represented as objects by the underlying host system. All value classes inherit from class <code>AnyVal</code>. Scala implementations need to provide the value classes <code>Unit</code>, <code>Boolean</code>, <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Int</code>, <code>Char</code>, <code>Short</code>, and <code>Byte</code> (but are free to provide others as well). The signatures of these classes are defined in the following.</p>
<h3 id="numeric-value-types"><a href="#numeric-value-types"><span class="header-section-number">12.2.1</span> Numeric Value Types</a></h3>
<p>Classes <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Int</code>, <code>Char</code>, <code>Short</code>, and <code>Byte</code> are together called <em>numeric value types</em>. Classes <code>Byte</code>, <code>Short</code>, or <code>Char</code> are called <em>subrange types</em>. Subrange types, as well as <code>Int</code> and <code>Long</code> are called <em>integer types</em>, whereas <code>Float</code> and <code>Double</code> are called <em>floating point types</em>.</p>
<p>Numeric value types are ranked in the following partial order:</p>
<pre><code>Byte - Short 
             \
               Int - Long - Float - Double
             / 
        Char </code></pre>
<p><code>Byte</code> and <code>Short</code> are the lowest-ranked types in this order, whereas <code>Double</code> is the highest-ranked. Ranking does <em>not</em> imply a <a href="#conformance">conformance relationship</a>; for instance <code>Int</code> is not a subtype of <code>Long</code>. However, object <a href="#the-predef-object"><code>Predef</code></a> defines <a href="#views">views</a> from every numeric value type to all higher-ranked numeric value types. Therefore, lower-ranked types are implicitly converted to higher-ranked types when required by the <a href="#implicit-conversions">context</a>.</p>
<p>Given two numeric value types <span class="math">\(S\)</span> and <span class="math">\(T\)</span>, the <em>operation type</em> of <span class="math">\(S\)</span> and <span class="math">\(T\)</span> is defined as follows: If both <span class="math">\(S\)</span> and <span class="math">\(T\)</span> are subrange types then the operation type of <span class="math">\(S\)</span> and <span class="math">\(T\)</span> is <code>Int</code>. Otherwise the operation type of <span class="math">\(S\)</span> and <span class="math">\(T\)</span> is the larger of the two types wrt ranking. Given two numeric values <span class="math">\(v\)</span> and <span class="math">\(w\)</span> the operation type of <span class="math">\(v\)</span> and <span class="math">\(w\)</span> is the operation type of their run-time types.</p>
<p>Any numeric value type <span class="math">\(T\)</span> supports the following methods.</p>
<ul>
<li>Comparison methods for equals (<code>==</code>), not-equals (<code>!=</code>), less-than (<code>&lt;</code>), greater-than (<code>&gt;</code>), less-than-or-equals (<code>&lt;=</code>), greater-than-or-equals (<code>&gt;=</code>), which each exist in 7 overloaded alternatives. Each alternative takes a parameter of some numeric value type. Its result type is type <code>Boolean</code>. The operation is evaluated by converting the receiver and its argument to their operation type and performing the given comparison operation of that type.</li>
<li>Arithmetic methods addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and remainder (<code>%</code>), which each exist in 7 overloaded alternatives. Each alternative takes a parameter of some numeric value type <span class="math">\(U\)</span>. Its result type is the operation type of <span class="math">\(T\)</span> and <span class="math">\(U\)</span>. The operation is evaluated by converting the receiver and its argument to their operation type and performing the given arithmetic operation of that type.</li>
<li>Parameterless arithmethic methods identity (<code>+</code>) and negation (<code>-</code>), with result type <span class="math">\(T\)</span>. The first of these returns the receiver unchanged, whereas the second returns its negation.</li>
<li>Conversion methods <code>toByte</code>, <code>toShort</code>, <code>toChar</code>, <code>toInt</code>, <code>toLong</code>, <code>toFloat</code>, <code>toDouble</code> which convert the receiver object to the target type, using the rules of Java's numeric type cast operation. The conversion might truncate the numeric value (as when going from <code>Long</code> to <code>Int</code> or from <code>Int</code> to <code>Byte</code>) or it might lose precision (as when going from <code>Double</code> to <code>Float</code> or when converting between <code>Long</code> and <code>Float</code>).</li>
</ul>
<p>Integer numeric value types support in addition the following operations:</p>
<ul>
<li><p>Bit manipulation methods bitwise-and (<code>&amp;</code>), bitwise-or {<code>|</code>}, and bitwise-exclusive-or (<code>^</code>), which each exist in 5 overloaded alternatives. Each alternative takes a parameter of some integer numeric value type. Its result type is the operation type of <span class="math">\(T\)</span> and <span class="math">\(U\)</span>. The operation is evaluated by converting the receiver and its argument to their operation type and performing the given bitwise operation of that type.</p></li>
<li>A parameterless bit-negation method (<code>~</code>). Its result type is the reciver type <span class="math">\(T\)</span> or <code>Int</code>, whichever is larger. The operation is evaluated by converting the receiver to the result type and negating every bit in its value.</li>
<li><p>Bit-shift methods left-shift (<code>&lt;&lt;</code>), arithmetic right-shift (<code>&gt;&gt;</code>), and unsigned right-shift (<code>&gt;&gt;&gt;</code>). Each of these methods has two overloaded alternatives, which take a parameter <span class="math">\(n\)</span> of type <code>Int</code>, respectively <code>Long</code>. The result type of the operation is the receiver type <span class="math">\(T\)</span>, or <code>Int</code>, whichever is larger. The operation is evaluated by converting the receiver to the result type and performing the specified shift by <span class="math">\(n\)</span> bits.</p></li>
</ul>
<p>Numeric value types also implement operations <code>equals</code>, <code>hashCode</code>, and <code>toString</code> from class <code>Any</code>.</p>
<p>The <code>equals</code> method tests whether the argument is a numeric value type. If this is true, it will perform the <code>==</code> operation which is appropriate for that type. That is, the <code>equals</code> method of a numeric value type can be thought of being defined as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">equals</span>(other: Any): Boolean = other <span class="kw">match</span> {
  <span class="kw">case</span> that: Byte   =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Short  =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Char   =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Int    =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Long   =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Float  =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> that: Double =&gt; <span class="kw">this</span> == that
  <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
}</code></pre>
<p>The <code>hashCode</code> method returns an integer hashcode that maps equal numeric values to equal results. It is guaranteed to be the identity for for type <code>Int</code> and for all subrange types.</p>
<p>The <code>toString</code> method displays its receiver as an integer or floating point number.</p>
<ol start="86" type="1">
<li><p>As an example, here is the signature of the numeric value type <code>Int</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">abstract</span> <span class="kw">sealed</span> <span class="kw">class</span> Int <span class="kw">extends</span> AnyVal {
  <span class="kw">def</span> == (that: Double): Boolean  <span class="co">// double equality</span>
  <span class="kw">def</span> == (that: Float): Boolean   <span class="co">// float equality</span>
  <span class="kw">def</span> == (that: Long): Boolean    <span class="co">// long equality</span>
  <span class="kw">def</span> == (that: Int): Boolean     <span class="co">// int equality</span>
  <span class="kw">def</span> == (that: Short): Boolean   <span class="co">// int equality</span>
  <span class="kw">def</span> == (that: Byte): Boolean    <span class="co">// int equality</span>
  <span class="kw">def</span> == (that: Char): Boolean    <span class="co">// int equality</span>
  <span class="co">/* analogous for !=, &lt;, &gt;, &lt;=, &gt;= */</span>

  <span class="kw">def</span> + (that: Double): Double    <span class="co">// double addition</span>
  <span class="kw">def</span> + (that: Float): Double     <span class="co">// float addition</span>
  <span class="kw">def</span> + (that: Long): Long        <span class="co">// long addition</span>
  <span class="kw">def</span> + (that: Int): Int          <span class="co">// int addition</span>
  <span class="kw">def</span> + (that: Short): Int        <span class="co">// int addition</span>
  <span class="kw">def</span> + (that: Byte): Int         <span class="co">// int addition</span>
  <span class="kw">def</span> + (that: Char): Int         <span class="co">// int addition</span>
  <span class="co">/* analogous for -, *, /, % */</span>

  <span class="kw">def</span> &amp; (that: Long): Long        <span class="co">// long bitwise and</span>
  <span class="kw">def</span> &amp; (that: Int): Int          <span class="co">// int bitwise and</span>
  <span class="kw">def</span> &amp; (that: Short): Int        <span class="co">// int bitwise and</span>
  <span class="kw">def</span> &amp; (that: Byte): Int         <span class="co">// int bitwise and</span>
  <span class="kw">def</span> &amp; (that: Char): Int         <span class="co">// int bitwise and</span>
  <span class="co">/* analogous for |, ^ */</span>

  <span class="kw">def</span> &lt;&lt; (cnt: Int): Int          <span class="co">// int left shift</span>
  <span class="kw">def</span> &lt;&lt; (cnt: Long): Int         <span class="co">// long left shift</span>
  <span class="co">/* analogous for &gt;&gt;, &gt;&gt;&gt; */</span>

  <span class="kw">def</span> unary_+ : Int               <span class="co">// int identity</span>
  <span class="kw">def</span> unary_- : Int               <span class="co">// int negation</span>
  <span class="kw">def</span> unary_~ : Int               <span class="co">// int bitwise negation</span>

  <span class="kw">def</span> toByte: Byte                <span class="co">// convert to Byte</span>
  <span class="kw">def</span> toShort: Short              <span class="co">// convert to Short</span>
  <span class="kw">def</span> toChar: Char                <span class="co">// convert to Char</span>
  <span class="kw">def</span> toInt: Int                  <span class="co">// convert to Int</span>
  <span class="kw">def</span> toLong: Long                <span class="co">// convert to Long</span>
  <span class="kw">def</span> toFloat: Float              <span class="co">// convert to Float</span>
  <span class="kw">def</span> toDouble: Double            <span class="co">// convert to Double</span>
}</code></pre></li>
</ol>
<h3 id="class-boolean"><a href="#class-boolean"><span class="header-section-number">12.2.2</span> Class <code>Boolean</code></a></h3>
<p>Class <code>Boolean</code> has only two values: <code>true</code> and <code>false</code>. It implements operations as given in the following class definition.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">abstract</span> <span class="kw">sealed</span> <span class="kw">class</span> Boolean <span class="kw">extends</span> AnyVal {
  <span class="kw">def</span> &amp;&amp; (p: =&gt; Boolean): Boolean = <span class="co">// boolean and</span>
    <span class="kw">if</span> (<span class="kw">this</span>) p <span class="kw">else</span> <span class="kw">false</span>
  <span class="kw">def</span> || (p: =&gt; Boolean): Boolean = <span class="co">// boolean or</span>
    <span class="kw">if</span> (<span class="kw">this</span>) <span class="kw">true</span> <span class="kw">else</span> p
  <span class="kw">def</span> &amp;  (x: Boolean): Boolean =    <span class="co">// boolean strict and</span>
    <span class="kw">if</span> (<span class="kw">this</span>) x <span class="kw">else</span> <span class="kw">false</span>
  <span class="kw">def</span> |  (x: Boolean): Boolean =    <span class="co">// boolean strict or</span>
    <span class="kw">if</span> (<span class="kw">this</span>) <span class="kw">true</span> <span class="kw">else</span> x
  <span class="kw">def</span> == (x: Boolean): Boolean =    <span class="co">// boolean equality</span>
    <span class="kw">if</span> (<span class="kw">this</span>) x <span class="kw">else</span> x.<span class="fu">unary_</span>!
  <span class="kw">def</span> != (x: Boolean): Boolean =    <span class="co">// boolean inequality</span>
    <span class="kw">if</span> (<span class="kw">this</span>) x.<span class="fu">unary_</span>! <span class="kw">else</span> x
  <span class="kw">def</span> unary_!: Boolean =            <span class="co">// boolean negation</span>
    <span class="kw">if</span> (<span class="kw">this</span>) <span class="kw">false</span> <span class="kw">else</span> <span class="kw">true</span>
}</code></pre>
<p>The class also implements operations <code>equals</code>, <code>hashCode</code>, and <code>toString</code> from class <code>Any</code>.</p>
<p>The <code>equals</code> method returns <code>true</code> if the argument is the same boolean value as the receiver, <code>false</code> otherwise. The <code>hashCode</code> method returns a fixed, implementation-specific hash-code when invoked on <code>true</code>, and a different, fixed, implementation-specific hash-code when invoked on <code>false</code>. The <code>toString</code> method returns the receiver converted to a string, i.e. either <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>.</p>
<h3 id="class-unit"><a href="#class-unit"><span class="header-section-number">12.2.3</span> Class <code>Unit</code></a></h3>
<p>Class <code>Unit</code> has only one value: <code>()</code>. It implements only the three methods <code>equals</code>, <code>hashCode</code>, and <code>toString</code> from class <code>Any</code>.</p>
<p>The <code>equals</code> method returns <code>true</code> if the argument is the unit value <code>()</code>, <code>false</code> otherwise. The <code>hashCode</code> method returns a fixed, implementation-specific hash-code, The <code>toString</code> method returns <code>&quot;()&quot;</code>.</p>
<h2 id="standard-reference-classes"><a href="#standard-reference-classes"><span class="header-section-number">12.3</span> Standard Reference Classes</a></h2>
<p>This section presents some standard Scala reference classes which are treated in a special way in Scala compiler -- either Scala provides syntactic sugar for them, or the Scala compiler generates special code for their operations. Other classes in the standard Scala library are documented in the Scala library documentation by HTML pages.</p>
<h3 id="class-string"><a href="#class-string"><span class="header-section-number">12.3.1</span> Class <code>String</code></a></h3>
<p>Scala's <code>String</code> class is usually derived from the standard String class of the underlying host system (and may be identified with it). For Scala clients the class is taken to support in each case a method</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> + (that: Any): String </code></pre>
<p>which concatenates its left operand with the textual representation of its right operand.</p>
<h3 id="the-tuple-classes"><a href="#the-tuple-classes"><span class="header-section-number">12.3.2</span> The <code>Tuple</code> classes</a></h3>
<p>Scala defines tuple classes <code>Tuple$n$</code> for <span class="math">\(n = 2 , \ldots , 9\)</span>. These are defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">case</span> <span class="kw">class</span> Tuple$n$[+a_1, ..., +a_n](_1: a_1, ..., _$n$: a_$n$) {
  <span class="kw">def</span> toString = <span class="st">&quot;(&quot;</span> ++ _1 ++ <span class="st">&quot;,&quot;</span> ++ $\ldots$ ++ <span class="st">&quot;,&quot;</span> ++ _$n$ ++ <span class="st">&quot;)&quot;</span>
}</code></pre>
<p>The implicitly imported <a href="#the-predef-object"><code>Predef</code></a> object defines the names <code>Pair</code> as an alias of <code>Tuple2</code> and <code>Triple</code> as an alias for <code>Tuple3</code>.</p>
<h3 id="the-function-classes"><a href="#the-function-classes"><span class="header-section-number">12.3.3</span> The <code>Function</code> Classes</a></h3>
<p>Scala defines function classes <code>Function$n$</code> for <span class="math">\(n = 1 , \ldots , 9\)</span>. These are defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala 
<span class="kw">trait</span> Function$n$[-a_1, ..., -a_$n$, +b] {
  <span class="kw">def</span> <span class="fu">apply</span>(x_1: a_1, ..., x_$n$: a_$n$): b 
  <span class="kw">def</span> toString = <span class="st">&quot;&lt;function&gt;&quot;</span> 
}</code></pre>
<p>A subclass of <code>Function1</code> represents partial functions, which are undefined on some points in their domain. In addition to the <code>apply</code> method of functions, partial functions also have a <code>isDefined</code> method, which tells whether the function is defined at the given argument:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> PartialFunction[-A, +B] <span class="kw">extends</span> Function1[A, B] {
  <span class="kw">def</span> <span class="fu">isDefinedAt</span>(x: A): Boolean
}</code></pre>
<p>The implicitly imported <a href="#the-predef-object"><code>Predef</code></a> object defines the name <code>Function</code> as an alias of <code>Function1</code>.</p>
<h3 id="class-array"><a href="#class-array"><span class="header-section-number">12.3.4</span> Class <code>Array</code></a></h3>
<p>The class of generic arrays is given as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">class</span> Array[A](len: Int) <span class="kw">extends</span> Seq[A] {
  <span class="kw">def</span> length: Int = len
  <span class="kw">def</span> <span class="fu">apply</span>(i: Int): A = $\ldots$
  <span class="kw">def</span> <span class="fu">update</span>(i: Int, x: A): Unit = $\ldots$
  <span class="kw">def</span> elements: Iterator[A] = $\ldots$
  <span class="kw">def</span> <span class="fu">subArray</span>(from: Int, end: Int): Array[A] = $\ldots$
  <span class="kw">def</span> <span class="fu">filter</span>(p: A =&gt; Boolean): Array[A] = $\ldots$
  <span class="kw">def</span> map[B](f: A =&gt; B): Array[B] = $\ldots$
  <span class="kw">def</span> flatMap[B](f: A =&gt; Array[B]): Array[B] = $\ldots$
}</code></pre>
<p>If <span class="math">\(T\)</span> is not a type parameter or abstract type, the type Array[<span class="math">\(T\)</span>] is represented as the native array type <code>[]$T$</code> in the underlying host system. In that case <code>length</code> returns the length of the array, <code>apply</code> means subscripting, and <code>update</code> means element update. Because of the syntactic sugar for <code>apply</code> and <code>update</code> <a href="#implicit-conversions">operations</a>, we have the following correspondences between Scala and Java/C# code for operations on an array <code>xs</code>:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>Scala</em></td>
<td style="text-align: left;"><em>Java/C#</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>xs.length</code></td>
<td style="text-align: left;"><code>xs.length</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>xs(i)</code></td>
<td style="text-align: left;"><code>xs[i]</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>xs(i) = e</code></td>
<td style="text-align: left;"><code>xs[i] = e</code></td>
</tr>
</tbody>
</table>
<p>Arrays also implement the sequence trait <code>scala.Seq</code> by defining an <code>elements</code> method which returns all elements of the array in an <code>Iterator</code>.</p>
<p>Because of the tension between parametrized types in Scala and the ad-hoc implementation of arrays in the host-languages, some subtle points need to be taken into account when dealing with arrays. These are explained in the following.</p>
<p>First, unlike arrays in Java or C#, arrays in Scala are <em>not</em> co-variant; That is, <span class="math">\(S &lt;: T\)</span> does not imply <code>Array[$S$] $&lt;:$ Array[$T$]</code> in Scala.<br />However, it is possible to cast an array of <span class="math">\(S\)</span> to an array of <span class="math">\(T\)</span> if such a cast is permitted in the host environment.</p>
<p>For instance <code>Array[String]</code> does not conform to <code>Array[Object]</code>, even though <code>String</code> conforms to <code>Object</code>. However, it is possible to cast an expression of type <code>Array[String]</code> to <code>Array[Object]</code>, and this cast will succeed without raising a <code>ClassCastException</code>. Example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> xs = <span class="kw">new</span> Array[String](<span class="dv">2</span>)
<span class="co">// val ys: Array[Object] = xs   // **** error: incompatible types</span>
<span class="kw">val</span> ys: Array[Object] = xs.<span class="fu">asInstanceOf</span>[Array[Object]] <span class="co">// OK</span></code></pre>
<p>Second, for <em>polymorphic arrays</em>, that have a type parameter or abstract type <span class="math">\(T\)</span> as their element type, a representation different from <code>[]T</code> might be used. However, it is guaranteed that <code>isInstanceOf</code> and <code>asInstanceOf</code> still work as if the array used the standard representation of monomorphic arrays:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> ss = <span class="kw">new</span> Array[String](<span class="dv">2</span>)

<span class="kw">def</span> f[T](xs: Array[T]): Array[String] = 
  <span class="kw">if</span> (xs.<span class="fu">isInstanceOf</span>[Array[String]]) xs.<span class="fu">asInstanceOf</span>[Array[String])
  <span class="kw">else</span> <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="st">&quot;not an instance&quot;</span>)

<span class="fu">f</span>(ss)                                     <span class="co">// returns ss</span></code></pre>
<p>The representation chosen for polymorphic arrays also guarantees that polymorphic array creations work as expected. An example is the following implementation of method <code>mkArray</code>, which creates an array of an arbitrary type <span class="math">\(T\)</span>, given a sequence of <span class="math">\(T\)</span>'s which defines its elements.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> mkArray[T](elems: Seq[T]): Array[T] = {
  <span class="kw">val</span> result = <span class="kw">new</span> Array[T](elems.<span class="fu">length</span>)
  <span class="kw">var</span> i = <span class="dv">0</span>
  <span class="kw">for</span> (elem &lt;- elems) {
    <span class="fu">result</span>(i) = elem
    i += <span class="dv">1</span>
  }
}</code></pre>
<p>Note that under Java's erasure model of arrays the method above would not work as expected -- in fact it would always return an array of <code>Object</code>.</p>
<p>Third, in a Java environment there is a method <code>System.arraycopy</code> which takes two objects as parameters together with start indices and a length argument, and copies elements from one object to the other, provided the objects are arrays of compatible element types. <code>System.arraycopy</code> will not work for Scala's polymorphic arrays because of their different representation. One should instead use method <code>Array.copy</code> which is defined in the companion object of class <code>Array</code>. This companion object also defines various constructor methods for arrays, as well as the <a href="#extractor-patterns">extractor method</a> <code>unapplySeq</code> which enables pattern matching over arrays.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">object</span> Array { 
  <span class="co">/** copies array elements from `src&#39; to `dest&#39;. */</span>
  <span class="kw">def</span> <span class="fu">copy</span>(src: AnyRef, srcPos: Int, 
           dest: AnyRef, destPos: Int, length: Int): Unit = $\ldots$

  <span class="co">/** Concatenate all argument arrays into a single array. */</span>
  <span class="kw">def</span> concat[T](xs: Array[T]*): Array[T] = $\ldots$

  <span class="co">/** Create a an array of successive integers. */</span>
  <span class="kw">def</span> <span class="fu">range</span>(start: Int, end: Int): Array[Int] = $\ldots$

  <span class="co">/** Create an array with given elements. */</span>
  <span class="kw">def</span> apply[A &lt;: AnyRef](xs: A*): Array[A] = $\ldots$

  <span class="co">/** Analogous to above. */</span>
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Boolean*): Array[Boolean] = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Byte*)   : Array[Byte]    = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Short*)  : Array[Short]   = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Char*)   : Array[Char]    = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Int*)    : Array[Int]     = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Long*)   : Array[Long]    = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Float*)  : Array[Float]   = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Double*) : Array[Double]  = $\ldots$
  <span class="kw">def</span> <span class="fu">apply</span>(xs: Unit*)   : Array[Unit]    = $\ldots$

  <span class="co">/** Create an array containing several copies of an element. */</span>
  <span class="kw">def</span> make[A](n: Int, elem: A): Array[A] = {

  <span class="co">/** Enables pattern matching over arrays */</span>
  <span class="kw">def</span> unapplySeq[A](x: Array[A]): Option[Seq[A]] = Some(x)
}</code></pre>
<ol start="87" type="1">
<li><p>The following method duplicates a given argument array and returns a pair consisting of the original and the duplicate:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> duplicate[T](xs: Array[T]) = {
  <span class="kw">val</span> ys = <span class="kw">new</span> Array[T](xs.<span class="fu">length</span>)
  Array.<span class="fu">copy</span>(xs, <span class="dv">0</span>, ys, <span class="dv">0</span>, xs.<span class="fu">length</span>)
  (xs, ys)
}</code></pre></li>
</ol>
<h2 id="class-node"><a href="#class-node"><span class="header-section-number">12.4</span> Class Node</a></h2>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala.<span class="fu">xml</span> 

<span class="kw">trait</span> Node {

  <span class="co">/** the label of this node */</span>
  <span class="kw">def</span> label: String               

  <span class="co">/** attribute axis */</span>
  <span class="kw">def</span> attribute: Map[String, String] 

  <span class="co">/** child axis (all children of this node) */</span>
  <span class="kw">def</span> child: Seq[Node]          

  <span class="co">/** descendant axis (all descendants of this node) */</span>
  <span class="kw">def</span> descendant: Seq[Node] = child.<span class="fu">toList</span>.<span class="fu">flatMap</span> { 
    x =&gt; x::x.<span class="fu">descendant</span>.<span class="fu">asInstanceOf</span>[List[Node]] 
  } 

  <span class="co">/** descendant axis (all descendants of this node) */</span>
  <span class="kw">def</span> descendant_or_self: Seq[Node] = <span class="kw">this</span>::child.<span class="fu">toList</span>.<span class="fu">flatMap</span> { 
    x =&gt; x::x.<span class="fu">descendant</span>.<span class="fu">asInstanceOf</span>[List[Node]] 
  } 

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(x: Any): Boolean = x <span class="kw">match</span> {
    <span class="kw">case</span> that:Node =&gt; 
      that.<span class="fu">label</span> == <span class="kw">this</span>.<span class="fu">label</span> &amp;&amp; 
        that.<span class="fu">attribute</span>.<span class="fu">sameElements</span>(<span class="kw">this</span>.<span class="fu">attribute</span>) &amp;&amp; 
          that.<span class="fu">child</span>.<span class="fu">sameElements</span>(<span class="kw">this</span>.<span class="fu">child</span>)
    <span class="kw">case</span> _ =&gt; <span class="kw">false</span>
  } 

 <span class="co">/** XPath style projection function. Returns all children of this node</span>
<span class="co">  *  that are labeled with &#39;that&#39;. The document order is preserved.</span>
<span class="co">  */</span>
    <span class="kw">def</span> \(that: Symbol): NodeSeq = {
      <span class="kw">new</span> <span class="fu">NodeSeq</span>({
        that.<span class="fu">name</span> <span class="kw">match</span> {
          <span class="kw">case</span> <span class="st">&quot;_&quot;</span> =&gt; child.<span class="fu">toList</span>  
          <span class="kw">case</span> _ =&gt;
            <span class="kw">var</span> res:List[Node] = Nil 
            <span class="kw">for</span> (x &lt;- child.<span class="fu">elements</span> <span class="kw">if</span> x.<span class="fu">label</span> == that.<span class="fu">name</span>) {
              res = x::res 
            }
            res.<span class="fu">reverse</span>
        }
      }) 
    }

 <span class="co">/** XPath style projection function. Returns all nodes labeled with the </span>
<span class="co">  *  name &#39;that&#39; from the &#39;descendant_or_self&#39; axis. Document order is preserved.</span>
<span class="co">  */</span>
  <span class="kw">def</span> \\(that: Symbol): NodeSeq = {
    <span class="kw">new</span> <span class="fu">NodeSeq</span>(
      that.<span class="fu">name</span> <span class="kw">match</span> {
        <span class="kw">case</span> <span class="st">&quot;_&quot;</span> =&gt; <span class="kw">this</span>.<span class="fu">descendant_or_self</span> 
        <span class="kw">case</span> _ =&gt; <span class="kw">this</span>.<span class="fu">descendant_or_self</span>.<span class="fu">asInstanceOf</span>[List[Node]].
        <span class="fu">filter</span>(x =&gt; x.<span class="fu">label</span> == that.<span class="fu">name</span>) 
      })
  }

  <span class="co">/** hashcode for this XML node */</span>
  <span class="kw">override</span> <span class="kw">def</span> hashCode = 
    Utility.<span class="fu">hashCode</span>(label, attribute.<span class="fu">toList</span>.<span class="fu">hashCode</span>, child) 

  <span class="co">/** string representation of this node */</span>
  <span class="kw">override</span> <span class="kw">def</span> toString = Utility.<span class="fu">toXML</span>(<span class="kw">this</span>) 

}</code></pre>
<h2 id="the-predef-object"><a href="#the-predef-object"><span class="header-section-number">12.5</span> The <code>Predef</code> Object</a></h2>
<p>The <code>Predef</code> object defines standard functions and type aliases for Scala programs. It is always implicitly imported, so that all its defined members are available without qualification. Its definition for the JVM environment conforms to the following signature:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">package</span> scala
<span class="kw">object</span> Predef {

  <span class="co">// classOf ---------------------------------------------------------</span>

  <span class="co">/** Returns the runtime representation of a class type. */</span>
  <span class="kw">def</span> classOf[T]: Class[T] = <span class="kw">null</span>  
   <span class="co">// this is a dummy, classOf is handled by compiler.</span>

  <span class="co">// Standard type aliases ---------------------------------------------</span>

  <span class="kw">type</span> String    = java.<span class="fu">lang</span>.<span class="fu">String</span>
  <span class="kw">type</span> Class[T]  = java.<span class="fu">lang</span>.<span class="fu">Class</span>[T]

  <span class="co">// Miscellaneous -----------------------------------------------------</span>
  
  <span class="kw">type</span> Function[-A, +B] = Function1[A, B]

  <span class="kw">type</span> Map[A, +B] = collection.<span class="fu">immutable</span>.<span class="fu">Map</span>[A, B]
  <span class="kw">type</span> Set[A] = collection.<span class="fu">immutable</span>.<span class="fu">Set</span>[A]

  <span class="kw">val</span> Map = collection.<span class="fu">immutable</span>.<span class="fu">Map</span>
  <span class="kw">val</span> Set = collection.<span class="fu">immutable</span>.<span class="fu">Set</span>

  <span class="co">// Manifest types, companions, and incantations for summoning ---------</span>

  <span class="kw">type</span> ClassManifest[T] = scala.<span class="fu">reflect</span>.<span class="fu">ClassManifest</span>[T]
  <span class="kw">type</span> Manifest[T]      = scala.<span class="fu">reflect</span>.<span class="fu">Manifest</span>[T]
  <span class="kw">type</span> OptManifest[T]   = scala.<span class="fu">reflect</span>.<span class="fu">OptManifest</span>[T]
  <span class="kw">val</span> ClassManifest     = scala.<span class="fu">reflect</span>.<span class="fu">ClassManifest</span>
  <span class="kw">val</span> Manifest          = scala.<span class="fu">reflect</span>.<span class="fu">Manifest</span>
  <span class="kw">val</span> NoManifest        = scala.<span class="fu">reflect</span>.<span class="fu">NoManifest</span>
  
  <span class="kw">def</span> manifest[T](<span class="kw">implicit</span> m: Manifest[T])           = m
  <span class="kw">def</span> classManifest[T](<span class="kw">implicit</span> m: ClassManifest[T]) = m
  <span class="kw">def</span> optManifest[T](<span class="kw">implicit</span> m: OptManifest[T])     = m

  <span class="co">// Minor variations on identity functions -----------------------------</span>
  <span class="kw">def</span> identity[A](x: A): A         = x    <span class="co">// @see `conforms` for the implicit version</span>
  <span class="kw">def</span> implicitly[T](<span class="kw">implicit</span> e: T) = e    <span class="co">// for summoning implicit values from the nether world</span>
  @inline <span class="kw">def</span> locally[T](x: T): T  = x    <span class="co">// to communicate intent and avoid unmoored statements</span>

  <span class="co">// Asserts, Preconditions, Postconditions -----------------------------</span>

  <span class="kw">def</span> <span class="fu">assert</span>(assertion: Boolean) {
    <span class="kw">if</span> (!assertion)
      <span class="kw">throw</span> <span class="kw">new</span> java.<span class="fu">lang</span>.<span class="fu">AssertionError</span>(<span class="st">&quot;assertion failed&quot;</span>)
  }

  <span class="kw">def</span> <span class="fu">assert</span>(assertion: Boolean, message: =&gt; Any) {
    <span class="kw">if</span> (!assertion)
      <span class="kw">throw</span> <span class="kw">new</span> java.<span class="fu">lang</span>.<span class="fu">AssertionError</span>(<span class="st">&quot;assertion failed: &quot;</span> + message)
  }

  <span class="kw">def</span> <span class="fu">assume</span>(assumption: Boolean) {
    <span class="kw">if</span> (!assumption)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;assumption failed&quot;</span>)
  }

  <span class="kw">def</span> <span class="fu">assume</span>(assumption: Boolean, message: =&gt; Any) {
    <span class="kw">if</span> (!assumption)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(message.<span class="fu">toString</span>)
  }

  <span class="kw">def</span> <span class="fu">require</span>(requirement: Boolean) {
    <span class="kw">if</span> (!requirement)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;requirement failed&quot;</span>)
  }

  <span class="kw">def</span> <span class="fu">require</span>(requirement: Boolean, message: =&gt; Any) {
    <span class="kw">if</span> (!requirement)
      <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;requirement failed: &quot;</span>+ message)
  }</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala">
  <span class="co">// tupling ---------------------------------------------------------</span>

  <span class="kw">type</span> Pair[+A, +B] = Tuple2[A, B]
  <span class="kw">object</span> Pair {
    <span class="kw">def</span> apply[A, B](x: A, y: B) = <span class="fu">Tuple2</span>(x, y)
    <span class="kw">def</span> unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
  }

  <span class="kw">type</span> Triple[+A, +B, +C] = Tuple3[A, B, C]
  <span class="kw">object</span> Triple {
    <span class="kw">def</span> apply[A, B, C](x: A, y: B, z: C) = <span class="fu">Tuple3</span>(x, y, z)
    <span class="kw">def</span> unapply[A, B, C](x: Tuple3[A, B, C]): Option[Tuple3[A, B, C]] = Some(x)
  }

  <span class="co">// Printing and reading -----------------------------------------------</span>

  <span class="kw">def</span> <span class="fu">print</span>(x: Any) = Console.<span class="fu">print</span>(x)
  <span class="kw">def</span> <span class="fu">println</span>() = Console.<span class="fu">println</span>()
  <span class="kw">def</span> <span class="fu">println</span>(x: Any) = Console.<span class="fu">println</span>(x)
  <span class="kw">def</span> <span class="fu">printf</span>(text: String, xs: Any*) = Console<span class="fu">.printf</span>(text.format(xs: _*))

  <span class="kw">def</span> <span class="fu">readLine</span>(): String = Console.<span class="fu">readLine</span>()
  <span class="kw">def</span> <span class="fu">readLine</span>(text: String, args: Any*) = Console.<span class="fu">readLine</span>(text, args)
  <span class="kw">def</span> <span class="fu">readBoolean</span>() = Console.<span class="fu">readBoolean</span>()
  <span class="kw">def</span> <span class="fu">readByte</span>() = Console.<span class="fu">readByte</span>()
  <span class="kw">def</span> <span class="fu">readShort</span>() = Console.<span class="fu">readShort</span>()
  <span class="kw">def</span> <span class="fu">readChar</span>() = Console.<span class="fu">readChar</span>()
  <span class="kw">def</span> <span class="fu">readInt</span>() = Console.<span class="fu">readInt</span>()
  <span class="kw">def</span> <span class="fu">readLong</span>() = Console.<span class="fu">readLong</span>()
  <span class="kw">def</span> <span class="fu">readFloat</span>() = Console.<span class="fu">readFloat</span>()
  <span class="kw">def</span> <span class="fu">readDouble</span>() = Console.<span class="fu">readDouble</span>()
  <span class="kw">def</span> <span class="fu">readf</span>(format: String) = Console.<span class="fu">readf</span>(format)
  <span class="kw">def</span> <span class="fu">readf1</span>(format: String) = Console.<span class="fu">readf1</span>(format)
  <span class="kw">def</span> <span class="fu">readf2</span>(format: String) = Console.<span class="fu">readf2</span>(format)
  <span class="kw">def</span> <span class="fu">readf3</span>(format: String) = Console.<span class="fu">readf3</span>(format)

  <span class="co">// Implict conversions ------------------------------------------------</span>

  ...
}</code></pre>
<h3 id="predefined-implicit-definitions"><a href="#predefined-implicit-definitions"><span class="header-section-number">12.5.1</span> Predefined Implicit Definitions</a></h3>
<p>The <code>Predef</code> object also contains a number of implicit definitions, which are available by default (because <code>Predef</code> is implicitly imported). Implicit definitions come in two priorities. High-priority implicits are defined in the <code>Predef</code> class itself whereas low priority implicits are defined in a class inherited by <code>Predef</code>. The rules of static <a href="#overloading-resolution">overloading resolution</a> stipulate that, all other things being equal, implicit resolution prefers high-priority implicits over low-priority ones.</p>
<p>The available low-priority implicits include definitions falling into the following categories.</p>
<ol>
<li><p>For every primitive type, a wrapper that takes values of that type to instances of a <code>runtime.Rich*</code> class. For instance, values of type <code>Int</code> can be implicitly converted to instances of class <code>runtime.RichInt</code>.</p></li>
<li><p>For every array type with elements of primitive type, a wrapper that takes the arrays of that type to instances of a <code>runtime.WrappedArray</code> class. For instance, values of type <code>Array[Float]</code> can be implicitly converted to instances of class <code>runtime.WrappedArray[Float]</code>. There are also generic array wrappers that take elements of type <code>Array[T]</code> for arbitrary <code>T</code> to <code>WrappedArray</code>s.</p></li>
<li><p>An implicit conversion from <code>String</code> to <code>WrappedString</code>.</p></li>
</ol>
<p>The available high-priority implicits include definitions falling into the following categories.</p>
<ul>
<li><p>An implicit wrapper that adds <code>ensuring</code> methods with the following overloaded variants to type <code>Any</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">ensuring</span>(cond: Boolean): A = { <span class="fu">assert</span>(cond); x }
<span class="kw">def</span> <span class="fu">ensuring</span>(cond: Boolean, msg: Any): A = { <span class="fu">assert</span>(cond, msg); x }
<span class="kw">def</span> <span class="fu">ensuring</span>(cond: A =&gt; Boolean): A = { <span class="fu">assert</span>(<span class="fu">cond</span>(x)); x }
<span class="kw">def</span> <span class="fu">ensuring</span>(cond: A =&gt; Boolean, msg: Any): A = { <span class="fu">assert</span>(<span class="fu">cond</span>(x), msg); x }</code></pre></li>
<li><p>An implicit wrapper that adds a <code>-&gt;</code> method with the following implementation to type <code>Any</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> -&gt; [B](y: B): (A, B) = (x, y)</code></pre></li>
<li><p>For every array type with elements of primitive type, a wrapper that takes the arrays of that type to instances of a <code>runtime.ArrayOps</code> class. For instance, values of type <code>Array[Float]</code> can be implicitly converted to instances of class <code>runtime.ArrayOps[Float]</code>. There are also generic array wrappers that take elements of type <code>Array[T]</code> for arbitrary <code>T</code> to <code>ArrayOps</code>s.</p></li>
<li><p>An implicit wrapper that adds <code>+</code> and <code>formatted</code> method with the following implementations to type <code>Any</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> +(other: String) = String.<span class="fu">valueOf</span>(self) + other
<span class="kw">def</span> <span class="fu">formatted</span>(fmtstr: String): String = fmtstr format self</code></pre></li>
<li><p>Numeric primitive conversions that implement the transitive closure of the following mappings:</p>
<pre><code>Byte  -&gt; Short
Short -&gt; Int
Char  -&gt; Int
Int   -&gt; Long
Long  -&gt; Float
Float -&gt; Double</code></pre></li>
<li><p>Boxing and unboxing conversions between primitive types and their boxed versions:</p>
<pre><code>Byte    &lt;-&gt; java.lang.Byte
Short   &lt;-&gt; java.lang.Short
Char    &lt;-&gt; java.lang.Character
Int     &lt;-&gt; java.lang.Integer
Long    &lt;-&gt; java.lang.Long
Float   &lt;-&gt; java.lang.Float
Double  &lt;-&gt; java.lang.Double
Boolean &lt;-&gt; java.lang.Boolean</code></pre></li>
<li><p>An implicit definition that generates instances of type <code>T &lt;:&lt; T</code>, for any type <code>T</code>. Here, <code>&lt;:&lt;</code> is a class defined as follows.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> &lt;:&lt;[-From, +To] <span class="kw">extends</span> (From =&gt; To)</code></pre>
<p>Implicit parameters of <code>&lt;:&lt;</code> types are typically used to implement type constraints.</p></li>
</ul>
<h1 id="scala-syntax-summary"><a href="#scala-syntax-summary"><span class="header-section-number">13</span> Scala Syntax Summary</a></h1>
<!-- TODO: introduce SeqPattern syntax -->

<p>The lexical syntax of Scala is given by the following grammar in EBNF form.</p>
<pre class="grammar"><code>upper            ::=  ‘A’ | … | ‘Z’ | ‘\$’ | ‘_’  // and Unicode category Lu
lower            ::=  ‘a’ | … | ‘z’ // and Unicode category Ll
letter           ::=  upper | lower // and Unicode categories Lo, Lt, Nl
digit            ::=  ‘0’ | … | ‘9’
opchar           ::= // “all other characters in \u0020-\u007F and Unicode
                     // categories Sm, So except parentheses ([{}]) and periods”

op               ::=  opchar {opchar} 
varid            ::=  lower idrest
plainid          ::=  upper idrest
                 |  varid
                 |  op
id               ::=  plainid
                 |  ‘\`’ stringLit ‘\`’
idrest           ::=  {letter | digit} [‘_’ op]

integerLiteral   ::=  (decimalNumeral | hexNumeral | octalNumeral) [‘L’ | ‘l’]
decimalNumeral   ::=  ‘0’ | nonZeroDigit {digit}
hexNumeral       ::=  ‘0’ ‘x’ hexDigit {hexDigit}
octalNumeral     ::=  ‘0’ octalDigit {octalDigit}
digit            ::=  ‘0’ | nonZeroDigit
nonZeroDigit     ::=  ‘1’ | … | ‘9’
octalDigit       ::=  ‘0’ | … | ‘7’

floatingPointLiteral 
               ::=  digit {digit} ‘.’ {digit} [exponentPart] [floatType]
                 |  ‘.’ digit {digit} [exponentPart] [floatType]
                 |  digit {digit} exponentPart [floatType]
                 |  digit {digit} [exponentPart] floatType
exponentPart     ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit {digit}
floatType        ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’

booleanLiteral   ::=  ‘true’ | ‘false’

characterLiteral ::=  ‘\&#39;‘ printableChar ‘\&#39;’
                 |  ‘\’ charEscapeSeq ‘\&#39;’

stringLiteral    ::=  ‘&quot;’ {stringElement} ‘&quot;’
                 |  ‘&quot;&quot;&quot;’ multiLineChars ‘&quot;&quot;&quot;’
stringElement    ::=  printableCharNoDoubleQuote 
                 |  charEscapeSeq
multiLineChars   ::=  {[‘&quot;’] [‘&quot;’] charNoDoubleQuote} {‘&quot;’}

symbolLiteral    ::=  ‘&#39;’ plainid

comment          ::=  ‘/*’ “any sequence of characters” ‘*/’
                 |  ‘//’ “any sequence of characters up to end of line”

nl               ::=  $\mathit{“new line character”}$
semi             ::=  ‘;’ |  nl {nl}</code></pre>
<p>The context-free syntax of Scala is given by the following EBNF grammar.</p>
<pre class="grammar"><code>  Literal           ::=  [‘-’] integerLiteral
                      |  [‘-’] floatingPointLiteral
                      |  booleanLiteral
                      |  characterLiteral
                      |  stringLiteral
                      |  symbolLiteral
                      |  ‘null’

  QualId            ::=  id {‘.’ id}
  ids               ::=  id {‘,’ id}

  Path              ::=  StableId
                      |  [id ‘.’] ‘this’
  StableId          ::=  id
                      |  Path ‘.’ id
                      |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id
  ClassQualifier    ::=  ‘[’ id ‘]’

  Type              ::=  FunctionArgTypes ‘=&gt;’ Type
                      |  InfixType [ExistentialClause]
  FunctionArgTypes  ::= InfixType
                      | ‘(’ [ ParamType {‘,’ ParamType } ] ‘)’
  ExistentialClause ::=  ‘forSome’ ‘{’ ExistentialDcl {semi ExistentialDcl} ‘}’
  ExistentialDcl    ::=  ‘type’ TypeDcl 
                      |  ‘val’ ValDcl
  InfixType         ::=  CompoundType {id [nl] CompoundType}
  CompoundType      ::=  AnnotType {‘with’ AnnotType} [Refinement]
                      |  Refinement
  AnnotType         ::=  SimpleType {Annotation}
  SimpleType        ::=  SimpleType TypeArgs
                      |  SimpleType ‘#’ id
                      |  StableId
                      |  Path ‘.’ ‘type’
                      |  ‘(’ Types ‘)’
  TypeArgs          ::=  ‘[’ Types ‘]’
  Types             ::=  Type {‘,’ Type}
  Refinement        ::=  [nl] ‘{’ RefineStat {semi RefineStat} ‘}’
  RefineStat        ::=  Dcl
                      |  ‘type’ TypeDef
                      |
  TypePat           ::=  Type

  Ascription        ::=  ‘:’ InfixType
                      |  ‘:’ Annotation {Annotation} 
                      |  ‘:’ ‘_’ ‘*’

  Expr              ::=  (Bindings | [‘implicit’] id | ‘_’) ‘=&gt;’ Expr
                      |  Expr1
  Expr1             ::=  ‘if’ ‘(’ Expr ‘)’ {nl} Expr [[semi] else Expr]
                      |  ‘while’ ‘(’ Expr ‘)’ {nl} Expr
                      |  ‘try’ ‘{’ Block ‘}’ [‘catch’  ‘{’ CaseClauses ‘}’] 
                         [‘finally’ Expr]
                      |  ‘do’ Expr [semi] ‘while’ ‘(’ Expr ‘)’
                      |  ‘for’ (‘(’ Enumerators ‘)’ | ‘{’ Enumerators ‘}’) 
                         {nl} [‘yield’] Expr
                      |  ‘throw’ Expr
                      |  ‘return’ [Expr]
                      |  [SimpleExpr ‘.’] id ‘=’ Expr
                      |  SimpleExpr1 ArgumentExprs ‘=’ Expr
                      |  PostfixExpr
                      |  PostfixExpr Ascription
                      |  PostfixExpr ‘match’ ‘{’ CaseClauses ‘}’
  PostfixExpr       ::=  InfixExpr [id [nl]]
  InfixExpr         ::=  PrefixExpr
                      |  InfixExpr id [nl] InfixExpr
  PrefixExpr        ::=  [‘-’ | ‘+’ | ‘~’ | ‘!’] SimpleExpr 
  SimpleExpr        ::=  ‘new’ (ClassTemplate | TemplateBody)
                      |  BlockExpr
                      |  SimpleExpr1 [‘_’]
  SimpleExpr1       ::=  Literal
                      |  Path
                      |  ‘_’
                      |  ‘(’ [Exprs] ‘)’
                      |  SimpleExpr ‘.’ id 
                      |  SimpleExpr TypeArgs
                      |  SimpleExpr1 ArgumentExprs
                      |  XmlExpr
  Exprs             ::=  Expr {‘,’ Expr}
  ArgumentExprs     ::=  ‘(’ [Exprs] ‘)’
                      |  ‘(’ [Exprs ‘,’] PostfixExpr ‘:’ ‘_’ ‘*’ ‘)’
                      |  [nl] BlockExpr
  BlockExpr         ::=  ‘{’ CaseClauses ‘}’
                      |  ‘{’ Block ‘}’
  Block             ::=  {BlockStat semi} [ResultExpr]
  BlockStat         ::=  Import
                      |  {Annotation} [‘implicit’ | ‘lazy’] Def
                      |  {Annotation} {LocalModifier} TmplDef
                      |  Expr1
                      |
  ResultExpr        ::=  Expr1
                      |  (Bindings | ([‘implicit’] id | ‘_’) ‘:’ CompoundType) ‘=&gt;’ Block

  Enumerators       ::=  Generator {semi Enumerator}
  Enumerator        ::=  Generator
                      |  Guard
                      |  ‘val’ Pattern1 ‘=’ Expr
  Generator         ::=  Pattern1 ‘&lt;-’ Expr [Guard]

  CaseClauses       ::=  CaseClause { CaseClause }
  CaseClause        ::=  ‘case’ Pattern [Guard] ‘=&gt;’ Block 
  Guard             ::=  ‘if’ PostfixExpr

  Pattern           ::=  Pattern1 { ‘|’ Pattern1 }
  Pattern1          ::=  varid ‘:’ TypePat
                      |  ‘_’ ‘:’ TypePat
                      |  Pattern2
  Pattern2          ::=  varid [‘@’ Pattern3]
                      |  Pattern3
  Pattern3          ::=  SimplePattern
                      |  SimplePattern { id [nl] SimplePattern }
  SimplePattern     ::=  ‘_’
                      |  varid
                      |  Literal
                      |  StableId
                      |  StableId ‘(’ [Patterns ‘)’
                      |  StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’
                      |  ‘(’ [Patterns] ‘)’
                      |  XmlPattern
  Patterns          ::=  Pattern [‘,’ Patterns]
                      |  ‘_’ *

  TypeParamClause   ::=  ‘[’ VariantTypeParam {‘,’ VariantTypeParam} ‘]’
  FunTypeParamClause::=  ‘[’ TypeParam {‘,’ TypeParam} ‘]’
  VariantTypeParam  ::=  {Annotation} [‘+’ | ‘-’] TypeParam
  TypeParam         ::=  (id | ‘_’) [TypeParamClause] [‘&gt;:’ Type] [‘&lt;:’ Type] 
                         {‘&lt;%’ Type} {‘:’ Type}
  ParamClauses      ::=  {ParamClause} [[nl] ‘(’ ‘implicit’ Params ‘)’]
  ParamClause       ::=  [nl] ‘(’ [Params] ‘)’
  Params            ::=  Param {‘,’ Param}
  Param             ::=  {Annotation} id [‘:’ ParamType] [‘=’ Expr]
  ParamType         ::=  Type 
                      |  ‘=&gt;’ Type 
                      |  Type ‘*’
  ClassParamClauses ::=  {ClassParamClause} 
                         [[nl] ‘(’ ‘implicit’ ClassParams ‘)’]
  ClassParamClause  ::=  [nl] ‘(’ [ClassParams] ‘)’
  ClassParams       ::=  ClassParam {‘’ ClassParam}
  ClassParam        ::=  {Annotation} [{Modifier} (‘val’ | ‘var’)] 
                         id ‘:’ ParamType [‘=’ Expr]
  Bindings          ::=  ‘(’ Binding {‘,’ Binding ‘)’
  Binding           ::=  (id | ‘_’) [‘:’ Type]

  Modifier          ::=  LocalModifier 
                      |  AccessModifier
                      |  ‘override’
  LocalModifier     ::=  ‘abstract’
                      |  ‘final’
                      |  ‘sealed’
                      |  ‘implicit’
                      |  ‘lazy’
  AccessModifier    ::=  (‘private’ | ‘protected’) [AccessQualifier]
  AccessQualifier   ::=  ‘[’ (id | ‘this’) ‘]’

  Annotation        ::=  ‘@’ SimpleType {ArgumentExprs}
  ConstrAnnotation  ::=  ‘@’ SimpleType ArgumentExprs
  NameValuePair     ::=  ‘val’ id ‘=’ PrefixExpr

  TemplateBody      ::=  [nl] ‘{’ [SelfType] TemplateStat {semi TemplateStat} ‘}’
  TemplateStat      ::=  Import
                      |  {Annotation [nl]} {Modifier} Def
                      |  {Annotation [nl]} {Modifier} Dcl
                      |  Expr
                      |
  SelfType          ::=  id [‘:’ Type] ‘=&gt;’
                      |  ‘this’ ‘:’ Type ‘=&gt;’ 

  Import            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}
  ImportExpr        ::=  StableId ‘.’ (id | ‘_’ | ImportSelectors)
  ImportSelectors   ::=  ‘{’ {ImportSelector ‘,’} (ImportSelector | ‘_’) ‘}’
  ImportSelector    ::=  id [‘=&gt;’ id | ‘=&gt;’ ‘_’]

  Dcl               ::=  ‘val’ ValDcl
                      |  ‘var’ VarDcl
                      |  ‘def’ FunDcl
                      |  ‘type’ {nl} TypeDcl

  ValDcl            ::=  ids ‘:’ Type
  VarDcl            ::=  ids ‘:’ Type
  FunDcl            ::=  FunSig [‘:’ Type]
  FunSig            ::=  id [FunTypeParamClause] ParamClauses
  TypeDcl           ::=  id [TypeParamClause] [‘&gt;:’ Type] [‘&lt;:’ Type]

  PatVarDef         ::=  ‘val’ PatDef
                      |  ‘var’ VarDef
  Def               ::=  PatVarDef
                      |  ‘def’ FunDef
                      |  ‘type’ {nl} TypeDef
                      |  TmplDef
  PatDef            ::=  Pattern2 {‘,’ Pattern2} [‘:’ Type] ‘=’ Expr
  VarDef            ::=  PatDef
                      |  ids ‘:’ Type ‘=’ ‘_’
  FunDef            ::=  FunSig [‘:’ Type] ‘=’ Expr
                      |  FunSig [nl] ‘{’ Block ‘}’
                      |  ‘this’ ParamClause ParamClauses 
                         (‘=’ ConstrExpr | [nl] ConstrBlock)
  TypeDef           ::=  id [TypeParamClause] ‘=’ Type

  TmplDef           ::=  [‘case’] ‘class’ ClassDef
                      |  [‘case’] ‘object’ ObjectDef
                      |  ‘trait’ TraitDef
  ClassDef          ::=  id [TypeParamClause] {ConstrAnnotation} [AccessModifier] 
                         ClassParamClauses ClassTemplateOpt 
  TraitDef          ::=  id [TypeParamClause] TraitTemplateOpt
  ObjectDef         ::=  id ClassTemplateOpt
  ClassTemplateOpt  ::=  ‘extends’ ClassTemplate | [[‘extends’] TemplateBody]
  TraitTemplateOpt  ::=  ‘extends’ TraitTemplate | [[‘extends’] TemplateBody]
  ClassTemplate     ::=  [EarlyDefs] ClassParents [TemplateBody]
  TraitTemplate     ::=  [EarlyDefs] TraitParents [TemplateBody]
  ClassParents      ::=  Constr {‘with’ AnnotType}
  TraitParents      ::=  AnnotType {‘with’ AnnotType}
  Constr            ::=  AnnotType {ArgumentExprs}
  EarlyDefs         ::= ‘{’ [EarlyDef {semi EarlyDef}] ‘}’ ‘with’
  EarlyDef          ::=  {Annotation [nl]} {Modifier} PatVarDef

  ConstrExpr        ::=  SelfInvocation 
                      |  ConstrBlock
  ConstrBlock       ::=  ‘{’ SelfInvocation {semi BlockStat} ‘}’
  SelfInvocation    ::=  ‘this’ ArgumentExprs {ArgumentExprs}

  TopStatSeq        ::=  TopStat {semi TopStat}
  TopStat           ::=  {Annotation [nl]} {Modifier} TmplDef
                      |  Import
                      |  Packaging
                      |  PackageObject
                      |  
  Packaging         ::=  ‘package’ QualId [nl] ‘{’ TopStatSeq ‘}’
  PackageObject     ::=  ‘package’ ‘object’ ObjectDef

  CompilationUnit   ::=  {‘package’ QualId semi} TopStatSeq</code></pre>
<!-- TODO add:

SimplePattern    ::= StableId  [TypePatArgs] [‘(’ [SeqPatterns] ‘)’]
TypePatArgs ::= ‘[’ TypePatArg {‘,’ TypePatArg} ‘]’
TypePatArg    ::=  ‘_’ |   varid}

-->


<h1 id="references"><a href="#references"><span class="header-section-number">14</span> References</a></h1>
<!-- this is deliberately empty, and must be at the very end of the
     document as pandoc will inject all citation information here.
-->

<p>Kennedy, Andrew J., and Benjamin C. Pierce. 2007. “On Decidability of Nominal Subtyping with Variance.”</p>
<p>Odersky, Martin. 2006. “The Scala Experiment – Can We Provide Better Language Support for Component Systems?” In <em>Proc. ACM Symposium on Principles of Programming Languages</em>.</p>
<p>Odersky, Martin, Vincent Cremet, Christine Röckl, and Matthias Zenger. 2003. “A Nominal Theory of Objects with Dependent Types.” In <em>Proc. ECOOP’03</em>.</p>
<p>Odersky, Martin, and Matthias Zenger. 2005a. “Scalable Component Abstractions.” In <em>Proc. OOPSLA</em>.</p>
<p>———. 2005b. “Independently Extensible Solutions to the Expression Problem.” In <em>Proc. FOOL 12</em>.</p>
<p>Odersky, Martin, and al. 2004. <em>An Overview of the Scala Programming Language</em>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>We assume that objects and packages also implicitly define a class (of the same name as the object or package, but inaccessible to user programs).<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>A reference to a structurally defined member (method call or access to a value or variable) may generate binary code that is significantly slower than an equivalent code to a non-structural member.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>A congruence is an equivalence relation which is closed under formation of contexts.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>The current Scala compiler limits the nesting level of parameterization in such bounds to be at most two deeper than the maximum nesting level of the operand types.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>However, at present singleton types of method parameters may only appear in the method body; so <em>dependent method types</em> are not supported.<a href="#fnref5">↩</a></p></li>
</ol>
</section>
</div>
</body>
</html>
